<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="陈嘉俊">
    
    <title>
        
            二叉树 |
        
        keep
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/%E5%AE%89%E5%85%A8%E5%B8%BD.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/网站头像.jpg","favicon":"/images/安全帽.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"https://1-1309415301.cos.ap-shanghai.myqcloud.com/C/wallhaven-l3zyg2_1920x1080.png","description":null},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
.progress-bar-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  z-index: $z-index-9;

  if (hexo-config('pjax.enable') == true) {

    .pjax-progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 2px;
      width: 0;
      background: var(--pjax-progress-bar-color);
      visibility: hidden;
      opacity: 0;
      z-index: $z-index-8;
      transition-t("width", "0", "0.1", "linear");


      &.show {
        opacity: 1;
        visibility: visible;
      }
    }


    .pjax-progress-icon {
      position: absolute;
      top: 0;
      right: 0;
      z-index: $z-index-8;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 7px 6px 0 0;
      visibility: hidden;
      font-size: 1.1rem;
      color: var(--default-text-color);

      +keep-tablet() {
        padding: 6px 5px 0 0;
        font-size: 1rem;
      }

      &.show {
        visibility: visible;
      }
    }

  }

  if (hexo-config('style.scroll.progress_bar.enable') == true) {

    .scroll-progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: $scroll-progress-bar-height;
      visibility: hidden;
      z-index: $z-index-7;
      background: var(--primary-color);
      transition-t("width", "0", "0.1", "linear");

      &.hide {
        display: none !important;
      }
    }

  }
}

<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            $logo-title-font-size = 2rem;
$pc-search-icon-font-size = 1.5rem;
$menu-bar-line-height = 2.5px;
$logo-image-box-width = 46px;

.header-wrapper {
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--background-color);
  padding-top: $scroll-progress-bar-height;

  hover-style(false, 0, 0);

  .header-content {
    position: relative;
    height: 100%;
    width: $main-content-width;
    max-width: $content-max-width;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    z-index: $z-index-5;


    &.has-first-screen {
      max-width: $content-max-width * 1.2;
    }

    +keep-tablet() {
      width: $main-content-width-tablet;
    }

    +keep-mobile() {
      width: $main-content-width-mobile;
    }

    .left {
      display: flex;
      align-items: center;
      transition-t("transform", "0", "0.2", "linear");

      .header-shrink & {
        transform: scale(0.72);
        transform-origin: left;
      }


      if (hexo-config('base_info.logo_img') && hexo-config('base_info.logo_img') != '') {
        .logo-image {
          width: $logo-image-box-width;
          height: $logo-image-box-width;
          margin-right: 8px;


          +keep-tablet() {
            width: $logo-image-box-width * 0.9;
            height: $logo-image-box-width * 0.9;
          }

          +keep-mobile() {
            width: $logo-image-box-width * 0.8;
            height: $logo-image-box-width * 0.8;
          }

          img {
            border-radius: 6px;
            width: 100%;
          }
        }

      }

      .logo-title {
        font-size: $logo-title-font-size;
        font-weight: bold;
        letter-spacing: 1px;
        line-height: 1;
        color: var(--first-text-color);

        +keep-tablet() {
          font-size: $logo-title-font-size * 0.9;
        }

        +keep-mobile() {
          font-size: $logo-title-font-size * 0.8;
        }
      }

    }


    .right {

      .pc {

        .menu-list {
          display: flex;
          align-items: center;

          +keep-tablet() {
            display: none;
          }


          .menu-item {
            float: left;
            position: relative;
            margin-left: 30px;
            font-size: 1rem;
            cursor: pointer;
            color: var(--default-text-color);

            &:first-child {
              margin-left: 0;
            }


            a:hover, .active {

              &::after {
                content: '';
                position: absolute;
                bottom: -10px;
                left: 50%;
                width: 100%;
                height: 2px;
                transform: translateX(-50%);
                background: var(--primary-color);
                transition-t("transform, bottom", "0, 0", "0.2, 0.2", "linear, linear");

                .header-shrink & {
                  bottom: -($header-shrink-height / 2 - 12);
                }
              }
            }

            &.search {
              font-size: $pc-search-icon-font-size;
              margin-left: 26px;

              i {
                color: var(--default-text-color);
              }

            }
          }


        }

      }


      .mobile {
        display: flex;
        justify-content: space-between;
        align-items: center;

        .icon-item {
          display: none;
          position: relative;
          cursor: pointer;
          font-size: 18px;
          margin-left: 12px;
          width: 20px;
          height: 20px;
          color: var(--default-text-color);

          i {
            color: var(--default-text-color);
          }

          &:first-child {
            margin-left: 0;
          }

          +keep-tablet() {
            display: flex;
            justify-content: center;
            align-items: center;
          }
        }

        .menu-bar {

          .menu-bar-middle {
            width: 18px;
            height: $menu-bar-line-height;
            position: relative;
            background: var(--default-text-color);

            .header-drawer-show & {
              background: transparent;
            }


            &::before, &::after {
              content: '';
              position: absolute;
              left: 0;
              width: 100%;
              height: $menu-bar-line-height;
              background: var(--default-text-color);
              transition-t("transform", "0", "0.38", "ease");
            }


            &::before {
              top: -6px;

              .header-drawer-show & {
                transform: translateY(6px) rotate(45deg);
              }
            }


            &::after {
              bottom: -6px;

              .header-drawer-show & {
                transform: translateY(-6px) rotate(-45deg);
              }
            }
          }
        }
      }
    }
  }


  .header-drawer {
    width: 100%;
    padding: $header-height 0 20px 0;
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleY(0);
    transform-origin: top;
    z-index: $z-index-2;
    background: var(--background-color);
    transition-t("transform", "0", "0.38", "ease");

    .header-drawer-show & {
      transform: scaleY(1);
    }

    .drawer-menu-list {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;

      .drawer-menu-item {
        font-size: 1rem;
        margin: 6px 0;
        height: 38px;

        a {
          padding: 6px 20px;
          border-radius: 20px;
          color: var(--default-text-color);

          &:hover {
            color: var(--second-text-color);
            border: 1px solid var(--default-text-color);
          }


          &.active {
            border: 1px solid var(--default-text-color);
            color: var(--second-text-color);
          }
        }


      }
    }
  }


  .window-mask {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100vh;
    background: rgba(0, 0, 0, 0.4);
    z-index: $z-index-1;
    visibility: hidden;
    opacity: 0;
    transition-t("transform, opacity", "0, 0", "0.38, 0.38", "ease, ease");

    .header-drawer-show & {
      visibility: visible;
      opacity: 1;
    }
  }

}

.header-drawer-show {
  overflow: hidden;
}

        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">二叉树</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/%E7%BD%91%E7%AB%99%E5%A4%B4%E5%83%8F.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">陈嘉俊</span>
                        
                    </div>
                    <div class="meta-info">
                        .article-meta-info {
  font-size: 0.8rem;
  color: var(--third-text-color);

  .article-meta-item {
    margin-right: 10px;

    &:last-child {
      margin-right: 0;
    }
  }

  .article-date {

    .mobile {
      display: none;
    }

    +keep-tablet() {
      .pc {
        display: none;
      }

      .mobile {
        display: inline;
      }
    }

  }


  .article-tags, .article-categories {
    display: inline;

    ul, li {
      display: inline;
    }

    a {
      color: var(--third-text-color);

      &:hover {
        color: var(--primary-color);
      }
    }
  }

  .article-tags {
    +keep-tablet() {
      display: none;
    }
  }

  .article-min2read, .article-wordcount {
    +keep-mobile() {
      display: none;
    }
  }
}

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>无论是向量还是列表都无法做到兼顾静态和动态的高效</p>
<p>半线性结构：树型结构不是狭义的线性结构，却带有线性的特征</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E6%A0%91%E7%9A%84%E5%8A%A8%E6%9C%BA.png"></p>
<p><strong>树是按照层次关系来组织数据项的方式</strong></p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E6%9C%89%E6%A0%B9%E6%A0%91.png"></p>
<p>有根树：r树根（父亲），subtree子树，ri之间互称兄弟（sibling），d = degree（r)为r的度，e树的边数，n顶点总数</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E6%A0%91%E7%9A%84%E8%BE%B9%E4%B8%8E%E9%A1%B6%E7%82%B9.png"></p>
<p>故在衡量相关复杂度时，可以n作为参照</p>
<p>若指定Ti作为T的第i棵子树，ri作为r的第i个孩子，则T称作有序树(ordered tree)</p>
<h4 id="路径-环路"><a href="#路径-环路" class="headerlink" title="路径+环路"></a>路径+环路</h4><p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E8%B7%AF%E5%BE%84%2B%E7%8E%AF%E8%B7%AF.png"></p>
<h4 id="连通-无环"><a href="#连通-无环" class="headerlink" title="连通+无环"></a>连通+无环</h4><p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E8%BF%9E%E9%80%9A%2B%E6%97%A0%E7%8E%AF.png"></p>
<p>一旦指定了根，其他的节点都将获得一个确定的指标，通过指标，同一类顶点所具有的指标都是相等的，也称为等价类</p>
<h4 id="深度-层次"><a href="#深度-层次" class="headerlink" title="深度+层次"></a>深度+层次</h4><p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E6%B7%B1%E5%BA%A6%2B%E5%B1%82%E6%AC%A1.png"></p>
<p>根节点是所有节点的公共祖先，深度为0</p>
<p>没有后代的节点称作叶子（leaf）</p>
<p>所有叶子深度中的最大者，称作树的高度</p>
<p>一个节点都没有的树称作空树，高度为-1</p>
<p>depth(v) + height(v) &lt;= height(T)</p>
<h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E6%A0%91%E7%9A%84%E6%8E%A5%E5%8F%A3.png"></p>
<p><strong>性能</strong>：</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E7%88%B6%E8%8A%82%E7%82%B9.png"></p>
<h4 id="长子-兄弟"><a href="#长子-兄弟" class="headerlink" title="长子+兄弟"></a>长子+兄弟</h4><p>每个节点均设两个引用</p>
<p>纵：firstChild（）</p>
<p>横：nextSibling（）</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E7%88%B6%E8%8A%82%E7%82%B9.png"></p>
<h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3><p>节点度数不超过2的树称作二叉树（binary tree）</p>
<p>同一节点的孩子和子树，均以左、右区分</p>
<p>在有根性和有序性能够保证的前提下，二叉树足以描述所有的树</p>
<ul>
<li><p>深度为k的节点，至多为2^k个</p>
</li>
<li><p>含n个节点，高度为h的二叉树中</p>
<p>h &lt; n &lt; 2^h+1</p>
</li>
<li><p>n = h + 1时，退化为一条单链</p>
</li>
<li><p>n = 2^h+1 - 1时，即所谓满二叉树（full binary tree）</p>
</li>
</ul>
<h4 id="真二叉树"><a href="#真二叉树" class="headerlink" title="真二叉树"></a>真二叉树</h4><p>每个节点的度数都是偶数</p>
<p><strong>假想添加</strong>：</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E7%9C%9F%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
<p>用长子兄弟法将多叉树转化为二叉树</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E5%A4%9A%E5%8F%89%E8%BD%AC%E4%BA%8C%E5%8F%89.png"></p>
<p>即可以用二叉树来表示任何一棵有根有序树</p>
<p>正因如此，二叉树虽是树的特例，却可直接研究二叉树</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="BinNode类"><a href="#BinNode类" class="headerlink" title="BinNode类"></a>BinNode类</h5><p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/BinNode%E7%B1%BB.png"></p>
<p>每个节点通过引用指向其他节点，每个节点所占据的一个空间为一个位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BinNodePosi(T) BinNode<span class="meta-string">&lt;T&gt;</span>* <span class="comment">//节点位置</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span>&#123;</span></span><br><span class="line">    <span class="built_in">BinNodePosi</span>(T) parent,lChild,rChild; <span class="comment">//父亲，孩子</span></span><br><span class="line">    T data; <span class="keyword">int</span> height; <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//高度，子树规模</span></span><br><span class="line">    <span class="built_in">BinNodePosi</span>(T) <span class="built_in">insertAsLc</span>(T <span class="keyword">const</span> &amp;); <span class="comment">//作为左孩子插入新节点</span></span><br><span class="line">    <span class="built_in">BinNodePosi</span>(T) <span class="built_in">insertAsRc</span>(T <span class="keyword">const</span> &amp;); <span class="comment">//作为右孩子插入新节点</span></span><br><span class="line">    <span class="built_in">BinNodePosi</span>(T) <span class="built_in">succ</span>(); <span class="comment">//(中序遍历意义下)当前节点的直接后继</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travLevel</span><span class="params">( VST &amp; )</span></span>; <span class="comment">//子树层次遍历</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travPre</span><span class="params">( VST &amp; )</span></span>; <span class="comment">//子树先序遍历</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travIn</span><span class="params">( VST &amp; )</span></span>; <span class="comment">//子树中序遍历</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travPost</span><span class="params">( VST &amp; )</span></span>; <span class="comment">//子树后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口实现</strong></p>
<p>传入参数e进行封装，并且将它作为当前节点的左/右孩子，接入所属树中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">BinNodePosi</span><span class="params">(T)</span>::<span class="title">insertAsLc</span><span class="params">(T <span class="keyword">const</span> &amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> l Child = <span class="keyword">new</span> <span class="built_in">BinNode</span>(e,<span class="keyword">this</span>); &#125; <span class="comment">//O(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>size</strong>(后代总数，即以其为根的子树的规模)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> BinNode&lt;T&gt;::<span class="built_in">size</span>()&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>; <span class="comment">//计入本身</span></span><br><span class="line">    <span class="keyword">if</span>(lChild) s += lChild-&gt;<span class="built_in">size</span>(); <span class="comment">//递归计入左子树规模</span></span><br><span class="line">    <span class="keyword">if</span>(rChild) s += rChild-&gt;<span class="built_in">size</span>(); <span class="comment">//递归计入右子树规模</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125; <span class="comment">//O(n=size)</span></span><br></pre></td></tr></table></figure>

<h5 id="BinTree模板类"><a href="#BinTree模板类" class="headerlink" title="BinTree模板类"></a>BinTree模板类</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BinTree</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> _size; <span class="comment">//规模</span></span><br><span class="line">    <span class="built_in">BinNodePosi</span>(T) _root; <span class="comment">//根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">updateHeight</span><span class="params">( BinNodePosi(T) x)</span></span>; <span class="comment">//更新节点x的速度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateHeightAbove</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//更新x即祖先的速度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_root; &#125; <span class="comment">//判空</span></span><br><span class="line">    <span class="built_in">BinNodePosi</span>(T) <span class="built_in">root</span>() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _root; &#125; <span class="comment">//树根</span></span><br><span class="line">    <span class="comment">/* ...子树接入、删除和分离接口...*/</span></span><br><span class="line">    <span class="comment">/* ...遍历接口... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="高度更新"><a href="#高度更新" class="headerlink" title="高度更新"></a>高度更新</h5><p>根节点高度为0，空树高度为-1</p>
<p>一个节点的高度恰好等于左右孩子中的更大者+1</p>
<p>定义一个新的等价意义上的高度，使得算法更为简便：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stature(p) ( (p) ? (p)-&gt;height : -1)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//更新节点x高度，具体规则因树不同而异</span></span><br><span class="line"><span class="keyword">int</span> BinTree&lt;T&gt;::<span class="built_in">updateHeight</span>( <span class="built_in">BinNodePosi</span>(T) x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x-&gt;height = <span class="number">1</span> + <span class="built_in">max</span>( <span class="built_in">stature</span>( x-&gt;lChild ),<span class="built_in">stature</span>( x-&gt;rChild ) );</span><br><span class="line">&#125; <span class="comment">//此处采用常规二叉树规则，O(1)</span></span><br></pre></td></tr></table></figure>

<p>如果x的父节点存在，那么x的高度变化，则会连锁到父节点，祖父节点…，因此更新节点从x出发，向上逐层追溯它的历代祖先直到抵达根节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//更新v及其历代祖先的高度</span></span><br><span class="line"><span class="keyword">void</span> BinTree&lt;T&gt;::<span class="built_in">updateHeightAbove</span>( <span class="built_in">BinNodePosi</span>(T) x )&#123;</span><br><span class="line">    <span class="keyword">while</span>(x) <span class="comment">//可优化：一旦高度未变，即可终止</span></span><br><span class="line">    &#123; <span class="built_in">updateHeight</span>(x); x = x-&gt;parent; &#125;</span><br><span class="line">&#125; <span class="comment">//O( n = depth(x) )</span></span><br></pre></td></tr></table></figure>

<h5 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h5><p>在一棵二叉树中，将某个新生成的节点，作为树中某一原本没有右孩子的节点的右孩子接入</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function">BinTree&lt;T&gt;::<span class="title">insertAsRc</span><span class="params">( BinNodePosi(T) X,T <span class="keyword">const</span> &amp; e )</span></span>&#123;</span><br><span class="line">    _size++;</span><br><span class="line">    x-&gt;<span class="built_in">insertAsRc</span>(e); <span class="comment">//x祖先的高度可能增加，其余节点必要不变</span></span><br><span class="line">    <span class="built_in">updateHeightAbove</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x-&gt;rChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><strong>遍历</strong>：按照某种<strong>次序</strong>访问树中各节点，每个节点被访问恰好一次</p>
<p>先序：V-&gt;L-&gt;R        中序：L-&gt;V-&gt;R        后序：L-&gt;R-&gt;V</p>
<p><strong>先序遍历顺序</strong>：自上而下访问左侧链上的节点，再自下而上访问它们的右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(BinNodePosi(T) x,VST &amp; visit)</span></span>&#123; <span class="comment">//递归实现</span></span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>; <span class="comment">//递归基的处理</span></span><br><span class="line">    <span class="built_in">visit</span>( x-&gt;data ); </span><br><span class="line">    <span class="built_in">traverse</span>( x-&gt;lChild,visit );</span><br><span class="line">    <span class="built_in">traverse</span>( x-&gt;rChild,visit );</span><br><span class="line">&#125; <span class="comment">//T(n) = O(1) + T(a) + T(n-a-1) = O(n)</span></span><br></pre></td></tr></table></figure>

<p>这种算法只具有渐进的意义，在实际过程中，因为递归程序的实现机制，只能采用通用的方法，运行栈中每个递归实例都具有一帧，但是因为它们必须具有通用格式，所以并不能做到足够的小。因此，作为树算法的重要基石，遍历算法非常有必要从递归改写为迭代</p>
<h4 id="迭代实现-1"><a href="#迭代实现-1" class="headerlink" title="迭代实现(1)"></a>迭代实现(1)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I1</span><span class="params">( BinNodePosi(T) x,VST &amp; visit)</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="built_in">BinNodePosi</span>(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="keyword">if</span>(x) S.<span class="built_in">push</span>(x); <span class="comment">//根节点入栈</span></span><br><span class="line">    <span class="keyword">while</span>( !S.<span class="built_in">empty</span>() )&#123; <span class="comment">//在栈变空之前反复循环</span></span><br><span class="line">        x = S.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>( x-&gt;data ); <span class="comment">//弹出并访问当前节点</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">HasRChild</span>(*x) ) S.<span class="built_in">push</span>(x-&gt;rChild); <span class="comment">//右孩子先入后出</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">HasLchild</span>(*x) ) S.<span class="built_in">push</span>(x-&gt;lChild); <span class="comment">//左孩子后入先出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的遍历算法都是先访问左孩子再访问右孩子，所以依据栈的特性，右孩子先入后出（后遍历）</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E5%85%88%E5%BA%8F%E8%BF%AD%E4%BB%A3%E5%AE%9E%E4%BE%8B1.png"></p>
<p>对于任何一根子树，我们都将起始于树根的总是沿着左侧孩子分支不断下行的这条链，称作当前这棵子树的左侧链</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E5%85%88%E5%BA%8F%E6%96%B0%E6%9E%84%E6%80%9D.png"></p>
<p>首先自顶而下的依次访问左侧链上的沿途节点，再倒过来，自底而上地依次遍历各个层次上的右子树</p>
<h4 id="迭代实现-2"><a href="#迭代实现-2" class="headerlink" title="迭代实现(2)"></a>迭代实现(2)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt; <span class="comment">//分摊(1)</span></span><br><span class="line">	 <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongLeftBranch</span><span class="params">(BinNodePosi(T) x,VST &amp; visit,Stack&lt;BinNodePosi&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="built_in">visit</span>( x-&gt;data ); <span class="comment">//反复访问当前节点</span></span><br><span class="line">        S.<span class="built_in">push</span>( x-&gt;rChild ); <span class="comment">//右孩子入栈</span></span><br><span class="line">        x = x-&gt;lChild; <span class="comment">//沿左侧链下行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I2</span><span class="params">( BinNodePosi(T) x,VST &amp; visit )</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="built_in">BinNodePosi</span>(T)&gt;S; <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123; <span class="comment">//以右子树为单位，逐批访问节点</span></span><br><span class="line">        <span class="built_in">visitAlongLeftBranch</span>( x,visit,S); <span class="comment">//访问子树x的左侧链，右子树入栈缓冲</span></span><br><span class="line">        <span class="keyword">if</span>( S.<span class="built_in">empty</span>() ) <span class="keyword">break</span>; <span class="comment">//栈空即退出</span></span><br><span class="line">        x = S.<span class="built_in">pop</span>(); <span class="comment">//弹出下一子树的根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E5%85%88%E5%BA%8F%E8%BF%AD%E4%BB%A3%E5%AE%9E%E4%BE%8B2.png"></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">( BinNodePosi(T) x,VST &amp; visit )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !x ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traverse</span>( x-&gt;lChild,visit );</span><br><span class="line">    <span class="built_in">visit</span>( x-&gt;data );</span><br><span class="line">    <span class="built_in">traverse</span>( x-&gt;rChild,visit );</span><br><span class="line">&#125; <span class="comment">//T(n) = T(a) + O(1) + T(n-a-1) = O(n)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%A7%82%E5%AF%9F.png"></p>
<p>从根节点开始一直沿着左侧分支逐层向下直到末端</p>
<p>因此整个中序遍历分解为在不同尺度下的一系列的对左侧分支的逐步处理</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E6%80%9D.png"></p>
<ul>
<li>从根出发沿左分支下行，直到最深的节点——它就是全局首先被访问者</li>
<li>自上而下谦让，再自下而上访问</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlingLeftBranch</span><span class="params">( BinNodePosi(T) x,Stack&lt;BinNodePosi(T)&gt; &amp; S )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">while</span>(x) &#123; S.<span class="built_in">push</span>(x); x = x-&gt;lChild; &#125;&#125; <span class="comment">//反复地入栈，沿左分支深入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> v&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I1</span><span class="params">( BinNodePosi(T) x,V&amp; visit )</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="built_in">BinNodePosi</span>(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">goAlongLeftBranch</span>(x, S); <span class="comment">//从当前节点出发，逐批入栈</span></span><br><span class="line">        <span class="keyword">if</span>( S.<span class="built_in">empty</span>() ) <span class="keyword">break</span>; <span class="comment">//直至所有节点处理完毕</span></span><br><span class="line">        x = S.<span class="built_in">pop</span>(); <span class="comment">//x的左子树或为空，或已遍历（等效于空），故可以</span></span><br><span class="line">        <span class="built_in">visit</span>( x-&gt;data ); <span class="comment">//立即访问之</span></span><br><span class="line">        x = x-&gt;rChild; <span class="comment">//再转向其右子树(可能为空，需留意处理手法)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E4%B8%AD%E5%BA%8F%E6%8E%92%E5%88%97%E5%AE%9E%E4%BE%8B.png"></p>
<p>所有左侧链的长度集中在一起也就是O(n)</p>
<p>每一个节点的入栈操作对应的是左侧链上的一步，因此左侧链的长度就是push的操作次数</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">( BinNodePosi&lt;T&gt; x,VST &amp; visit )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !x ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traverse</span>( x-&gt;lc,visit );</span><br><span class="line">    <span class="built_in">traverse</span>( x-&gt;rc,visit );</span><br><span class="line">    <span class="built_in">visit</span>( x-&gt;data );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E8%97%A4%E7%BC%A0%E6%A0%91.png"></p>
<ul>
<li>从根出发下行，尽可能沿左分支，实不得已，才沿右分支</li>
<li>最后一个节点，必是叶子，而且是按中序遍历次序最靠左者，也是递归版中visit()首次执行处</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gotoleftmostleaf</span><span class="params">( Stack&lt;BinNodePosi&lt;T&gt;&gt; &amp; S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( BinNOdePosi&lt;T&gt; x = S.<span class="built_in">top</span>() ) <span class="comment">//自顶而下反复检查栈顶节点</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">HasLChild</span>(*x) )&#123; <span class="comment">//尽可能向左，在此之前</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">HasRChild</span>(*x) ) <span class="comment">//若有右孩子，则</span></span><br><span class="line">                S.<span class="built_in">push</span>( x-&gt;rc ); <span class="comment">//优先入栈</span></span><br><span class="line">            S.<span class="built_in">push</span>( x-&gt;lc ); <span class="comment">//然后转向左孩子</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="comment">//实不得已</span></span><br><span class="line">            S.<span class="built_in">push</span>( x-&gt;rc ); <span class="comment">//才转向右孩子</span></span><br><span class="line">    S.<span class="built_in">pop</span>(); <span class="comment">//返回之前，弹出栈顶的空节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> VST&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost_I</span><span class="params">( BinNodePosi&lt;T&gt; x,VST &amp; visit )</span></span>&#123;</span><br><span class="line">    Stack&lt;BinNodePosi&lt;T&gt;&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>在此前的三种遍历中，都是后代先于祖先访问，即逆序，为此，都会使用到栈</p>
<p>而在层次遍历中，所有节点都将按照深度次序由高至低访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinNode&lt;T&gt;::<span class="built_in">travLevel</span>( VST &amp; visit)</span><br><span class="line">    Queue&lt;<span class="built_in">BinNodePosi</span>(T) Q; <span class="comment">//引入辅助队列</span></span><br><span class="line">	Q.<span class="built_in">enqueue</span>( <span class="keyword">this</span> ); <span class="comment">//根节点入队</span></span><br><span class="line">	<span class="keyword">while</span>( !Q.<span class="built_in">empty</span>() )&#123; <span class="comment">//在队列再次清空之前，反复迭代</span></span><br><span class="line">        <span class="built_in">BinNodePosi</span>(T) x = Q.<span class="built_in">dequeue</span>(); <span class="comment">//在取出队首节点</span></span><br><span class="line">        <span class="built_in">visit</span>( x-&gt;data ); </span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">HasLChild</span>(*x) ) Q.<span class="built_in">enqueue</span>( x-&gt;lChild ); <span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">HasRChile</span>(*x) ) Q.<span class="built_in">enqueue</span>( x-&gt;rChild ); <span class="comment">//右孩子入队</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E5%AE%9E%E4%BE%8B.png"></p>
<h3 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h3><h4 id="无前缀冲突编码"><a href="#无前缀冲突编码" class="headerlink" title="无前缀冲突编码"></a>无前缀冲突编码</h4><p>各自的叶子不会待在另一叶子的通路上</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/PFC%E7%BC%96%E7%A0%81.png"></p>
<h4 id="编码成本"><a href="#编码成本" class="headerlink" title="编码成本"></a>编码成本</h4><p>相差一个bit，影响的是带宽，费用，成本等等</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/pfc%E7%BC%96%E7%A0%81%E6%88%90%E6%9C%AC.png"></p>
<p>之所以要平衡，是为了杜绝深度差够大，至少是2的瑕疵，一旦有这种瑕疵，就可以通过交换进行优化</p>
<h4 id="带权编码长度"><a href="#带权编码长度" class="headerlink" title="带权编码长度"></a>带权编码长度</h4><p>因为频度的不同</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E5%B8%A6%E5%85%A8%E7%BC%96%E7%A0%81%E9%95%BF%E5%BA%A6.png"></p>
<p>根据频率高/低的(超)字符，应尽可能放在高/低处</p>
<p>故此，通过适当的交换，同样可以缩短wald(T)</p>
<p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E9%AB%98%E4%BD%8E%E9%A2%91%E7%8E%87.png"></p>
<h4 id="编码算法"><a href="#编码算法" class="headerlink" title="编码算法"></a>编码算法</h4><p>贪婪策略：频率低的字符优先引入，位置亦更低</p>
<p>为每个字符创建一棵单节点的树，组成森林F</p>
<p>按照出现频率，对所有树排列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( F中的树不止一棵 )</span><br><span class="line">    取频率最小的两棵树：T1和T2</span><br><span class="line">    将它们合并成一棵新树T，并令：</span><br><span class="line">    	<span class="built_in">lchild</span>(T) = T1且<span class="built_in">rChild</span>(T) = T2</span><br><span class="line">    	<span class="built_in">w</span>(<span class="built_in">root</span>(T)) = <span class="built_in">w</span>(<span class="built_in">root</span>(t1)) + <span class="built_in">w</span>(<span class="built_in">root</span>(T2))</span><br></pre></td></tr></table></figure>

<h4 id="构造编码书"><a href="#构造编码书" class="headerlink" title="构造编码书"></a>构造编码书</h4><p><img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E6%9E%84%E9%80%A0%E7%BC%96%E7%A0%81%E6%A0%91.png"></p>
<p>每次取最小两个数合并(贪心)，并慢慢成长</p>
<p> <img src="https://1-1309415301.cos.ap-shanghai.myqcloud.com/notes/%E6%9E%84%E9%80%A0%E7%BC%96%E7%A0%81%E6%A0%911.png"></p>
<p>编码表：遍历，先中后序都可以，因为都是深度优先</p>
<p>解码：从根开始，走到叶子，打印字符，再重置到根循环</p>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">#数据结构与算法</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">图</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">栈与队列</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            .footer {
  font-size: 1rem;
  color: var(--third-text-color);


  a {
    color: var(--third-text-color);


    &:hover {
      color: var(--primary-color);

    }
  }

  .info-container {
    padding-bottom: 10px;
    text-align: center;
  }

  .info-item {
    margin: 5px 0;
  }

  .icon-animate {
    animation: icon-animate 1.2s ease-in-out infinite;
  }

}

        </div>
    </div>

    
        <div class="post-tools">
            $li-border-radius = 5px;
$li-margin-bottom = 12px;

.post-tools-container {

  .tools-list {

    li {
      cursor: pointer;
      width: $post-tool-button-width;
      height: $post-tool-button-width;
      border-radius: 50%;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: $li-margin-bottom;
      background: var(--background-color);
      color: var(--default-text-color);

      i {
        color: var(--default-text-color);
      }

      &:hover {
        background: var(--primary-color);
        color: var(--background-color);

        i {
          color: var(--background-color);
        }
      }


      &:last-child {
        margin-bottom: 0;
      }


      hover-style(true, 1.06, 1.06);

      &.page-aside-toggle {
        display: none;

        +keep-tablet() {
          display: none !important;
        }
      }
    }
  }

}

        </div>
    

    <div class="right-bottom-side-tools">
        $tools-item-width = 32px;
$tools-item-font-size = 1.1rem;
$tools-item-border-radius = 1px;


.side-tools-container {
  position: relative;

  .tools-item {
    width: $tools-item-width;
    height: $tools-item-width;
    font-size: $tools-item-font-size;
    margin-bottom: 3px;
    cursor: pointer;
    border-right: none;
    border-radius: $tools-item-border-radius;
    box-shadow: 1px 1px 3px var(--shadow-color);
    color: var(--default-text-color);
    background: var(--background-color);

    i {
      color: var(--default-text-color);
    }

    &:hover {
      color: var(--background-color);
      background: var(--primary-color);
      box-shadow: 2px 2px 6px var(--shadow-color);

      i {
        color: var(--background-color);
      }
    }

    +keep-tablet() {
      width: $tools-item-width * 0.9;
      height: $tools-item-width * 0.9;
      font-size: $tools-item-font-size * 0.9;
      margin-bottom: 2px;
    }

    &.rss {

      a {
        border-radius: $tools-item-border-radius;
        width: 100%;
        height: 100%;

        &:hover {
          color: var(--background-color);
          background: var(--primary-color);
          box-shadow: 2px 2px 6px var(--shadow-color);
        }
      }
    }
  }


  .side-tools-list {
    opacity: 0;
    transform: translateX(100%);
    transition-t("transform, opacity", "0, 0", "0.2, 0.2", "linear, linear");

    .tool-expand-width {
      +keep-tablet() {
        display: none;
      }
    }


    &.show {
      opacity: 1;
      transform: translateX(0);
    }
  }


  .exposed-tools-list {

    if (hexo-config('style.scroll.percent.enable') == true) {
      .tool-scroll-to-top {
        display: none;

        &.show {
          display: flex;
        }

        &:hover {

          .percent {
            display: none;
          }

          .arrow-up {
            display: flex;
          }

        }

        .arrow-up {
          display: none;
        }

        .percent {
          display: flex;
          font-size: 1rem;
        }

      }

    }
  }
}

    </div>

    
        <aside class="page-aside">
            .post-toc-wrap {
  width: 100%;
  font-size: 0.92rem;
  box-sizing: border-box;

  .post-toc {

    ol {
      list-style: none;
      margin: 0;
      padding: 0 2px 12px 10px;
      text-align: left;

      &:last-child {
        padding-bottom: 0;
      }

      > ol {
        padding-left: 0;
      }

      a {
        transition-property: all;
        transition();
      }
    }


    .nav-item {
      line-height: 1.8;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }


    .nav {
      .nav-child {
        display: hexo-config('toc.expand_all') ? block : none;
      }

      .active > .nav-child {
        display: block;
      }

      .active-current > .nav-child {
        display: block;

        > .nav-item {
          display: block;
        }
      }


      .nav-number, .nav-text {
        color: var(--default-text-color);
      }

      .active > a {
        .nav-number, .nav-text {
          color: var(--primary-color);
        }
      }

      .active-current > a {
        .nav-number, .nav-text {
          color: var(--primary-color);
        }
      }
    }
  }
}


        </aside>
    

    .image-viewer-container {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0);
  visibility: hidden;
  z-index: $z-index-8;
  padding: 6%;
  box-sizing: border-box;
  transition-t("visibility, background", "0, 0", "0.3, 0.3", "ease, ease");

  &.active {
    background: rgba(0, 0, 0, 0.5);
    visibility: visible;

    img {
      cursor: zoom-out;
      transform: scale(1);
      padding: 2px;
      background: var(--background-color);
    }
  }

  img {
    max-width: 100%;
    max-height: 100%;
    transform: scale(0);
    transition-t("transform", "0", "0.3", "ease");
  }
}




    
        $icon-size = 1.2rem;

.search-pop-overlay {
  position: fixed;
  display: flex;
  height: 100%;
  width: 100%;
  left: 0;
  top: 0;
  background: rgba(0, 0, 0, 0);
  visibility: hidden;
  z-index: $z-index-8;
  transition-t("visibility, background", "0, 0", "0.3, 0.3", "ease, ease");

  &.active {
    visibility: visible;
    background: rgba(0, 0, 0, 0.35);

    .search-popup {
      transform: scale(1);
    }

  }


  .search-popup {
    background: var(--background-color);
    border-radius: 5px;
    height: 80%;
    width: 70%;
    margin: auto;
    transform: scale(0);
    z-index: $z-index-6;
    transition-t("transform", "0", "0.3", "ease");

    +keep-tablet() {
      width: 80%;
    }

    +keep-mobile() {
      width: 90%;
    }

    .search-header {
      background: var(--fourth-text-color);
      border-top-left-radius: 2px;
      border-top-right-radius: 2px;
      display: flex;
      padding: 10px;

      .search-input-field-pre, .popup-btn-close {
        font-size: $icon-size;
        padding: 0 10px;
        display: flex;
        align-items: center;
      }

      .search-input-field-pre {
        cursor: pointer;
        color: var(--third-text-color);
      }

      .popup-btn-close {
        color: var(--default-text-color);
      }


      .search-input-container {

        flex-grow: 1;
        padding: 2px;

        .search-input {
          background: transparent;
          border: 0;
          outline: 0;
          width: 100%;
          font-size: 1.2rem;
          color: var(--default-text-color);

          &::-webkit-search-cancel-button {
            display: none;
          }
        }


      }


      .popup-btn-close {
        cursor: pointer;

        &:hover .fas, far, fab {
          color: var(--first-text-color);
        }
      }

    }


    #search-result {
      display: flex;
      height: calc(100% - 55px);
      overflow: auto;
      padding: 5px 25px;

      .search-result-list {
        width: 100%;
        height: 100%;
        font-size: 1rem;

        li {
          border-bottom: 1px dashed var(--border-color);
          padding: 10px 0;
          margin: 10px 0;
          box-sizing: border-box;

          &:last-child {
            border-bottom: none;
          }


          .search-result-title {
            position: relative;
            font-weight: bold;
            margin-bottom: 10px;
            padding-left: 16px;
            display: flex;
            align-items: center;

            &::after {
              content: '';
              position: absolute;
              width: 5px;
              height: 5px;
              border-radius: 50%;
              top: 50%;
              transform: translateY(-50%);
              left: 0;
              background: var(--default-text-color);
            }
          }


          .search-result {
            line-height: 2rem;
            margin: 0;
            padding-left: 16px;
            word-wrap: break-word;
          }

          a {
            &:hover {
              color: var(--default-text-color);
            }
          }

          .search-keyword {
            border-bottom: 1px dashed var(--primary-color);
            color: var(--primary-color);
            font-weight: bold;
          }

        }
      }


      #no-result {
        color: var(--third-text-color);
        margin: auto;
      }

    }
  }
}


    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>



</body>
</html>
