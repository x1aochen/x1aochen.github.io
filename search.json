[{"title":"Hello World","url":"/2022/01/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"text","url":"/2022/02/05/text/","content":"测试测试测试\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第三章 物理内存分配","url":"/2021/11/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter3%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第三章 物理内存分配3.1 计算机体系结构及内存分层体系计算机体系结构计算机组成原理\nCPU，内存，总线，I/O\n内存体系结构OS内存管理目标\n抽象（逻辑地址空间）：应用程序不需要考虑底层细节\n保护（独立地址空间）：内存中可以运行多个应用程序，多个程序可能访问别的程序的地址空间或者破坏其他程序\n共享（访问相同内存）：进程之间安全有效可靠的数据传递\n虚拟化（更多的地址空间）：当内存不够时，把最需要的数据放在内存中，暂时不需要访问的数据可以临时的放到硬盘上\n\nOS内存管理方法\n程序重定位\n分段\n分页\n虚拟内存\n按需分页虚拟内存\n\n实现高度依赖于硬件\n\nMMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求\n\n3.2 地址空间与地址生成地址空间物理地址空间——硬件支持的地址空间（起始0，MAX_sys）\n逻辑地址空间——一个运行的程序所拥有的的内存范围（0，MAX_prog）\n逻辑地址的生成\n\n物理地址的生成\n\n\n地址安全检查\n\n3.3 连续内存分配内存碎片内存碎片问题指的是空闲的内存无法被利用\n\n外部碎片：分配单元之间的未使用内存\n内部碎片 :  分配给应用程序的单元内的未使用内存\n\n分区的动态分配\n第一匹配分配：在内存中找到第一个比需求大的空闲块, 分配给应用程序\n\n\n\n\n分配方式\n第一匹配分配\n最优适配分配\n最差适配分配\n\n\n\n实现需求\n1. 按地址排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配最大的分区3. 重分配需要检查是否可以合并相邻空闲分区\n\n\n优势\n简单 / 易于产生更大空闲块\n比较简单 / 大部分分配是小尺寸时有效\n分配很快 / 大部分分配是中尺寸时高效\n\n\n劣势\n产生外部碎片 / 不确定性\n产生外部碎片 / 重分配慢 / 易产生很多没用的微小碎片\n产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配\n\n\n3.4 连续内存分配：压缩式与交换式碎片整理无论使用那种算法，都可能产生碎片，希望想有一些办法使得碎片减少甚至消失\n压缩式碎片整理\n重置程序以合并空洞\n要求所有程序是动态可充值的\n议题\n何时重置？\n开销\n\n\n\n\n通过拷贝完成（重定位）\n在运行的时候挪操作，地址会不对\n\n应在程序停止时进行\n\n开销很大，甚至可能影响整个系统的正常执行\n\n\n交换式碎片整理\n运行程序需要更多的内存\n抢占等待的程序&amp;回收他们的内存(把暂时不用的内容挪到磁盘里)\n议题：哪些程序应该被抢占以及什么时候执行\n\n\n操作系统内核特征\n\n并发：计算机系统中同时存在多个运行的程序，需要OS管理和调度\n共享：宏观上“同时访问”，微观上互斥共享\n虚拟：利用多到程序设计技术，让每个用户都觉得有一个计算机专门为他服务\n异步：程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，只要运行环境相同，OS需要保证程序运行的结果也要相同\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第四章 非连续内存分配","url":"/2021/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter4%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第四章 非连续内存分配\n为什么需要非连续内存分配\n\n连续内存分配的缺点\n\n分配给一个程序的物理内存是连续的\n内存利用率低\n有外碎片，内碎片的问题\n\n非连续内存分配的优点\n\n一个程序的物理地址是非连续的\n更好的内存利用和管理\n允许共享代码与数据（共享库等）\n支持动态加载和动态链接\n\n非连续分配缺点\n\n如何建立虚拟地址和物理地址之间的转换\n软件方案\n硬件方案（分段，分页）\n\n\n\n4.1 分段\n程序的分段地址空间，分段寻址方案\n\n计算机程序由各种段组成\n\n分段：更好的分离和共享\n\n\n\n左边连续的虚拟地址，右边不连续的物理地址，采用映射机制进行两边的关联\n\n分段寻址方案\n\n\n一个段：一个内存“块”\n\n\n程序访问内存需要：\n\n\n一个2维的二元组（s，addr）\ns—段号\naddr—段内偏移\n\n\n\n\n操作系统建立段表\n分页\n划分物理内存至固定大小的帧\n\n大小是2的幂，e.g.，512,4096,8192\n\n\n划分逻辑地址空间至相同大小的页\n\n大小同物理地址\n\n\n建立方案 转换逻辑地址为物理地址（pages to frames）\n\n页表\nMMU/TLB（加速地址的转换）\n\n\n\n帧（Frame）\n物理内存被分割为大小相等的帧\n\n一个内存物理地址是一个二元组（f，o）\n\nf—帧号（F位，共有2F个帧）\no—帧内偏移（S位，每帧有2S字节）\n物理地址=2S * f + o\n\n\n16-bit地址空间, 9-bit(512 byte) 大小的页帧\n\n物理地址=（3，6）\n物理地址=1542\n\n\n\n\n页（Page）\n一个程序的逻辑地址空间被划分为大小相等的页\n\n页内偏移的大小 = 帧内偏移的大小\n页号大小 &lt;&gt; 帧号大小\n\n\n一个逻辑地址是一个二元组(p, o) \n\np—页号（P位，2P个页）\no—页内偏移（S位，每页有2S字节）\n逻辑地址=2S * P + o\n\n\n\n页寻址机制\n\n操作系统建立页表\n\n逻辑地址空间应当大于物理内存空间\n页映射到帧\n页是连续的虚拟内存\n帧是非连续的物理内存(有助于减少碎片的产生)\n不是所有的页都有对应的帧\n\n4.3 页表-概述、TLB页表概述页表结构\n\n每一个运行的程序都有一个页表\n属于程序运行状态, 会动态变化\nPTBR : 页表基址寄存器\n\n\n\n地址转换\n\n分页机制的性能问题\n问题：访问一个内存单元需要2次内存访问\n\n一次用于获取页表项\n一次用于访问数据\n\n页表可能非常大\n\n64位机器如果每页1024字节, 那么一个页表的大小会是多少？(264 / 210 = 254 存放不下)\n每一个运行的程序都需要有一个页表\n\n如何处理\n\n缓存\n间接访问\n\nTranslation Look-aside Buffer（TLB）（解决速度上问题）CPU的MMU里面的一个缓冲，CPU中的快表\n缓存近期访问的页帧转换表项\n\nTLB使用associative memory（关联内存）实现, 具备快速访问性能\n如果TLB命中, 物理页号可以很快被获取\n如果TLB未命中, 对应的表项被更新到TLB中\n常用的表项放在TLB里面\nTLB的miss不会很大\n写程序时，写出的程序尽量具有访问的局部性，把平时的访问集中在一个区域里，有效较少TLB的缺失\nx86的CPU由硬件实现, 其他的可能是由操作系统实现\n\n4.4 页表-二级，多级页表二级页表（解决空间上问题）\n\n将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.\n一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号\n节约了一定的空间, 在一级页表中如果resident bit = 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留多级页表\n\n\n通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”\n\n4.5 页表-反向页表大地址空间问题\n\n有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表\n不是让页表与逻辑地址空间的大小相对应, 而是让页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间 \n\n基于页寄存器（page registers）的方案每一个帧和一个寄存器关联, 寄存器内容包括 :\n\nresident bit : 此帧是否被占用\noccupier : 对应的页号 p\nprotection bits : 保护位\n\n实例\n\n物理内存大小是 : 4096 * 4096 = 4K * 4KB = 16 MB\n页面大小是 : 4096 bytes = 4 KB\n页帧数 : 4096 = 4 K\n页寄存器使用的空间(假设8 bytes / register) : 8 * 4096 = 32 Kbytes\n页寄存器带来的额外开销 : 32K / 16M = 0.2%\n虚拟内存大小 : 任意\n\n优势\n\n转换表的大小相对于物理内存来说很小\n转换表的大小跟逻辑地址空间的大小无关\n\n劣势\n\n需要的信息对调了, 即根据帧号可以找到页号\n如何转换回来? (如何根据页号找到帧号)\n在需要在反向页表中搜索想要的页号\n\n基于关联内存(associative memory)的方案硬件逻辑复杂，容量不能做太大，还需要放到CPU里面\n\n如果帧数较少, 页寄存器可以被放置在关联内存中\n\n在关联内存中查找逻辑页号\n\n成功 : 帧号被提取\n失败 : 页错误异常 (page fault)\n\n\n限制因素：\n\n大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)\n\n\n\n基于哈希(hash)的方案哈希表，哈希函数 : h(PID, p) 从 PID 标号获得页号\n在反向页表中通过哈希算法来搜索一个页对应的帧号\n\n对页号做哈希计算, 为了在帧表中获取对应的帧号\n页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数\n为了查找页 i , 执行下列操作 :\n计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器\n检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败\n\n\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"二叉树搜索树","url":"/2021/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"二叉搜索树概述二叉树结构可以认为是二维的列表(列表在维度上的扩充)\n二叉搜索树在形式上继承了二叉树(列表结构的特点)，同时也巧妙的借鉴了有序向量的特点和优势(一种质的提高)\n循关键码访问\n数据项之间，依照各自的关键码彼此区分\n条件：关键码之间支持大小比较与想等比对\n数据集合中的数据项，统一地表示和实现为词条entry形式\n\n词条emplate &lt;typename K, typename V&gt; struct Entry &#123; //词条模板类   K key; V value; //关键码、数值   Entry ( K k = K(), V v = V() ) : key ( k ), value ( v ) &#123;&#125;; //默认构造函数   Entry ( Entry&lt;K, V&gt; const&amp; e ) : key ( e.key ), value ( e.value ) &#123;&#125;; //基于克隆的构造函数   bool operator&lt; ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key &lt;  e.key; &#125;  //比较器：小于   bool operator&gt; ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key &gt;  e.key; &#125;  //比较器：大于   bool operator== ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key == e.key; &#125; //判等器：等于   bool operator!= ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key != e.key; &#125; //判等器：不等于&#125;; //得益于比较器和判等器，从此往后，不必严格区分词条及其对应的关键码\n\n有序性\n局部性的特征\n\nBST(二叉搜索树)：节点词条关键码\n顺序性：任一节点均不小于/不大于其左/右后代\n只含单个节点或即便只含单分支，都可以称作BST\n单调性BST的中序遍历序列，必然单调非降\n这一性质，也是BST的充要条件\n\n所有节点的垂直投影所构成的序列即是中序序列\n在微观上处处满足顺序性，在宏观上整体满足单调性\n接口template &lt;typename T&gt; class BST : public BinTree&lt;T&gt; &#123; //由BinTree派生BST模板类protected:   BinNodePosi&lt;T&gt; _hot; //“命中”节点的父亲   BinNodePosi&lt;T&gt; connect34 ( //按照“3 + 4”结构，联接3个节点及四棵子树      BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;,      BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt; );   BinNodePosi&lt;T&gt; rotateAt ( BinNodePosi&lt;T&gt; x ); //对x及其父亲、祖父做统一旋转调整public: //基本接口：以virtual修饰，强制要求所有派生类（BST变种）根据各自的规则对其重写   virtual BinNodePosi&lt;T&gt; &amp; search ( const T&amp; e ); //查找   virtual BinNodePosi&lt;T&gt; insert ( const T&amp; e ); //插入   virtual bool remove ( const T&amp; e ); //删除   /*DSA*/   /*DSA*/void stretchToLPath() &#123; stretchByZag ( _root ); &#125; //借助zag旋转，转化为左向单链   /*DSA*/void stretchToRPath() &#123; stretchByZig ( _root ); &#125; //借助zig旋转，转化为右向单链   /*DSA*/void stretch();&#125;;\n\n查找\n减而治之：从根节点出发，逐步地缩小查找范围，直到发现目标(成功)，或查找范围缩小至空树(失败)\n对照中序遍历序列可见，整个过程可视作是在仿效有序向量的二分查找\ntemplate &lt;typename T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search(const T &amp; e)&#123;return searchIn( _root,e,_hot = NULL);&#125; //从根节点启动查找static BinNodePosi(T) &amp; searchIn(    BinNodePosi(T) &amp; v,//当前(子)树根    const T &amp; e, //目标关键码    BinNodePosi(T) &amp; hot) //记忆热点&#123;    if (!v || (e == v-&gt;data)) return v; //足以确定失败，成功，或者    hot = v; //先记下当前(非空)节点，然后再...    return searchIn(((e &lt; v-&gt;data) ? v-&gt;lChild : v-&gt;rChild),e,hot);&#125; //运行时间正比于返回节点v的深度，不超过树高O(h)\n\n\n插入\ntemplate &lt;typename T&gt; BinNodePosi&lt;T&gt; BST&lt;T&gt;::insert ( const T&amp; e ) &#123; //将关键码e插入BST树中BinNodePosi&lt;T&gt; &amp; x = search ( e );   if ( x ) return x; //确认目标不存在（留意对_hot的设置）    x = new BinNode&lt;T&gt; ( e, _hot ); //创建新节点x：以e为关键码，以_hot为父\t_size++; //更新全树规模\tupdateHeightAbove ( x ); //更新x及其历代祖先的高度   return x; //新插入的节点，必为叶子&#125; //无论e是否存在于原树中，返回时总有x-&gt;data == e\n\n删除template &lt;typename T&gt; bool BST&lt;T&gt;::remove ( const T&amp; e ) &#123; //从BST树中删除关键码e   BinNodePosi&lt;T&gt; &amp; x = search ( e ); if ( !x ) return false; //确认目标存在（留意_hot的设置）   removeAt ( x, _hot ); _size--; //实施删除   updateHeightAbove ( _hot ); //更新_hot及其历代祖先的高度   return true;&#125; //删除成功与否，由返回值指示\n\ntemplate &lt;typename T&gt;static BinNodePosi&lt;T&gt; removeAt ( BinNodePosi&lt;T&gt; &amp; x, BinNodePosi&lt;T&gt; &amp; hot ) &#123;   BinNodePosi&lt;T&gt; w = x; //实际被摘除的节点，初值同x   BinNodePosi&lt;T&gt; succ = NULL; //实际被删除节点的接替者   if ( !HasLChild ( *x ) ) //若*x的左子树为空，则可      succ = x = x-&gt;rc; //直接将*x替换为其右子树   else if ( !HasRChild ( *x ) ) //若右子树为空，则可      succ = x = x-&gt;lc; //对称地处理——注意：此时succ != NULL   else &#123; //若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要      w = w-&gt;succ(); //（在右子树中）找到*x的直接后继*w      swap ( x-&gt;data, w-&gt;data ); //交换*x和*w的数据元素      BinNodePosi&lt;T&gt; u = w-&gt;parent;      ( ( u == x ) ? u-&gt;rc : u-&gt;lc ) = succ = w-&gt;rc; //隔离节点*w   &#125;   hot = w-&gt;parent; //记录实际被删除节点的父亲   if ( succ ) succ-&gt;parent = hot; //并将被删除节点的接替者与hot相联   release ( w-&gt;data ); release ( w ); return succ; //释放被摘除节点，返回接替者&#125; //release()负责释放复杂结构，与算法无直接关系，具体实现详见代码包\n\n平衡极短退化：当BST中所有节点的度数都不超过1，实际上已经退化成一条单链，此时整棵树的高度与整棵树的节点个数成线性正比关系(h=n-1)，这种情况下，最坏和平均意义都需要O(n)的时间\n平均高度\n随机生成的统一口径：当关键码总数为n时，可能的排列为n!棵，平均高度为logn，会出现冗余\n随机组成：将所有n个关键码视作n个互异的积木，所有BST的平均高度值为根号n\n中位数或是越接近与中位数的关键码，越是更早的插入，这类BST的高度会更低\n理想+适度什么样的树高度相对会更低\n\n节点数目固定时，兄弟子树高度越接近(平衡)，全树也将倾向于更低\n\n由n个节点组成的二叉树，高度不低于[ log2n]，恰为log2n时，称作理想平衡\n\n这样一种树在实际应用中是可遇不可求的，即便BST在某一时刻能够达到，在接下来的动态操作中，这样的高度也难以持续，因此所谓的理想平衡在实际意义中是不具任何意义的\n\n\n理想平衡出现概率极低，维护成本过高，故须适当地放松标准\n\n退一步海阔天空：高度渐进地不超过O(logn)，即称作适度平衡\n\n适度平衡BST，称作平衡二叉搜索树(BBST)\n\n\n歧义=等价\n相互等价的BST：两组BST的中序遍历序列完全一样，而拓扑却不尽相同\n\n上下可变：联接关系不尽相同，承袭关系可能颠倒，如19和16可以交换\n左右不乱：中序遍历序列完全一致，全局单调非降\n\n等价交换\n遵循两大准则\n\n局部性：执行的每一次等价变换，都应该局限在某一常数规模的局部(v和c)\n在将一棵刚刚失衡的BBST重新恢复于BST的过程中，累计需要执行的操作次数不要过多，至多不超过O(logn)\n\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"二叉树","url":"/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"二叉树树无论是向量还是列表都无法做到兼顾静态和动态的高效\n半线性结构：树型结构不是狭义的线性结构，却带有线性的特征\n\n树是按照层次关系来组织数据项的方式\n\n有根树：r树根（父亲），subtree子树，ri之间互称兄弟（sibling），d = degree（r)为r的度，e树的边数，n顶点总数\n\n故在衡量相关复杂度时，可以n作为参照\n若指定Ti作为T的第i棵子树，ri作为r的第i个孩子，则T称作有序树(ordered tree)\n路径+环路\n连通+无环\n一旦指定了根，其他的节点都将获得一个确定的指标，通过指标，同一类顶点所具有的指标都是相等的，也称为等价类\n深度+层次\n根节点是所有节点的公共祖先，深度为0\n没有后代的节点称作叶子（leaf）\n所有叶子深度中的最大者，称作树的高度\n一个节点都没有的树称作空树，高度为-1\ndepth(v) + height(v) &lt;= height(T)\n树的表示\n性能：\n\n长子+兄弟每个节点均设两个引用\n纵：firstChild（）\n横：nextSibling（）\n\n二叉树节点度数不超过2的树称作二叉树（binary tree）\n同一节点的孩子和子树，均以左、右区分\n在有根性和有序性能够保证的前提下，二叉树足以描述所有的树\n\n深度为k的节点，至多为2^k个\n\n含n个节点，高度为h的二叉树中\nh &lt; n &lt; 2^h+1\n\nn = h + 1时，退化为一条单链\n\nn = 2^h+1 - 1时，即所谓满二叉树（full binary tree）\n\n\n真二叉树每个节点的度数都是偶数\n假想添加：\n\n用长子兄弟法将多叉树转化为二叉树\n\n即可以用二叉树来表示任何一棵有根有序树\n正因如此，二叉树虽是树的特例，却可直接研究二叉树\n实现BinNode类\n每个节点通过引用指向其他节点，每个节点所占据的一个空间为一个位置\n#define BinNodePosi(T) BinNode&lt;T&gt;* //节点位置template&lt;typename T&gt; struct BinNode&#123;    BinNodePosi(T) parent,lChild,rChild; //父亲，孩子    T data; int height; int size(); //高度，子树规模    BinNodePosi(T) insertAsLc(T const &amp;); //作为左孩子插入新节点    BinNodePosi(T) insertAsRc(T const &amp;); //作为右孩子插入新节点    BinNodePosi(T) succ(); //(中序遍历意义下)当前节点的直接后继    template &lt;typename VST&gt; void travLevel( VST &amp; ); //子树层次遍历    template &lt;typename VST&gt; void travPre( VST &amp; ); //子树先序遍历    template &lt;typename VST&gt; void travIn( VST &amp; ); //子树中序遍历    template &lt;typename VST&gt; void travPost( VST &amp; ); //子树后序遍历&#125;\n\n接口实现\n传入参数e进行封装，并且将它作为当前节点的左/右孩子，接入所属树中\ntemplate&lt;typename T&gt; BinNodePosi(T)::insertAsLc(T const &amp; e)&#123; return l Child = new BinNode(e,this); &#125; //O(1)\n\nsize(后代总数，即以其为根的子树的规模)\ntemplate&lt;typename T&gt;int BinNode&lt;T&gt;::size()&#123;    int s = 1; //计入本身    if(lChild) s += lChild-&gt;size(); //递归计入左子树规模    if(rChild) s += rChild-&gt;size(); //递归计入右子树规模    return s;&#125; //O(n=size)\n\nBinTree模板类template&lt;typename T&gt; class BinTree&#123;protected:    int _size; //规模    BinNodePosi(T) _root; //根节点    virtual int updateHeight( BinNodePosi(T) x); //更新节点x的速度    void updateHeightAbove(BinNodePosi(T) x); //更新x即祖先的速度public:    int size() const &#123; return _size; &#125; //规模    bool empty() const &#123; return !_root; &#125; //判空    BinNodePosi(T) root() const &#123; return _root; &#125; //树根    /* ...子树接入、删除和分离接口...*/    /* ...遍历接口... */&#125;\n\n高度更新根节点高度为0，空树高度为-1\n一个节点的高度恰好等于左右孩子中的更大者+1\n定义一个新的等价意义上的高度，使得算法更为简便：\n#define stature(p) ( (p) ? (p)-&gt;height : -1)\n\ntemplate&lt;typename T&gt; //更新节点x高度，具体规则因树不同而异int BinTree&lt;T&gt;::updateHeight( BinNodePosi(T) x)&#123;    return x-&gt;height = 1 + max( stature( x-&gt;lChild ),stature( x-&gt;rChild ) );&#125; //此处采用常规二叉树规则，O(1)\n\n如果x的父节点存在，那么x的高度变化，则会连锁到父节点，祖父节点…，因此更新节点从x出发，向上逐层追溯它的历代祖先直到抵达根节点\ntemplate&lt;typename T&gt; //更新v及其历代祖先的高度void BinTree&lt;T&gt;::updateHeightAbove( BinNodePosi(T) x )&#123;    while(x) //可优化：一旦高度未变，即可终止    &#123; updateHeight(x); x = x-&gt;parent; &#125;&#125; //O( n = depth(x) )\n\n节点插入在一棵二叉树中，将某个新生成的节点，作为树中某一原本没有右孩子的节点的右孩子接入\n\ntemplate&lt;typename T&gt; BinNodePosi(T)BinTree&lt;T&gt;::insertAsRc( BinNodePosi(T) X,T const &amp; e )&#123;    _size++;    x-&gt;insertAsRc(e); //x祖先的高度可能增加，其余节点必要不变    updateHeightAbove(x);    return x-&gt;rChild;&#125;\n\n先序遍历遍历：按照某种次序访问树中各节点，每个节点被访问恰好一次\n先序：V-&gt;L-&gt;R        中序：L-&gt;V-&gt;R        后序：L-&gt;R-&gt;V\n先序遍历顺序：自上而下访问左侧链上的节点，再自下而上访问它们的右子树\ntemplate&lt;typename T,typename VST&gt;void traverse(BinNodePosi(T) x,VST &amp; visit)&#123; //递归实现    if(!x) return; //递归基的处理    visit( x-&gt;data );     traverse( x-&gt;lChild,visit );    traverse( x-&gt;rChild,visit );&#125; //T(n) = O(1) + T(a) + T(n-a-1) = O(n)\n\n这种算法只具有渐进的意义，在实际过程中，因为递归程序的实现机制，只能采用通用的方法，运行栈中每个递归实例都具有一帧，但是因为它们必须具有通用格式，所以并不能做到足够的小。因此，作为树算法的重要基石，遍历算法非常有必要从递归改写为迭代\n迭代实现(1)template&lt;typename T,typename VST&gt;void travPre_I1( BinNodePosi(T) x,VST &amp; visit)&#123;    Stack&lt;BinNodePosi(T)&gt; S; //辅助栈    if(x) S.push(x); //根节点入栈    while( !S.empty() )&#123; //在栈变空之前反复循环        x = S.pop();        visit( x-&gt;data ); //弹出并访问当前节点        if( HasRChild(*x) ) S.push(x-&gt;rChild); //右孩子先入后出        if( HasLchild(*x) ) S.push(x-&gt;lChild); //左孩子后入先出    &#125;&#125;\n\n所有的遍历算法都是先访问左孩子再访问右孩子，所以依据栈的特性，右孩子先入后出（后遍历）\n\n对于任何一根子树，我们都将起始于树根的总是沿着左侧孩子分支不断下行的这条链，称作当前这棵子树的左侧链\n\n首先自顶而下的依次访问左侧链上的沿途节点，再倒过来，自底而上地依次遍历各个层次上的右子树\n迭代实现(2)template&lt;typename T,typename VST&gt; //分摊(1)\t static void visitAlongLeftBranch(BinNodePosi(T) x,VST &amp; visit,Stack&lt;BinNodePosi&gt; &amp; s)&#123;    while(x)&#123;        visit( x-&gt;data ); //反复访问当前节点        S.push( x-&gt;rChild ); //右孩子入栈        x = x-&gt;lChild; //沿左侧链下行    &#125;&#125;\n\ntemplate&lt;typename T,typename VST&gt;void travPre_I2( BinNodePosi(T) x,VST &amp; visit )&#123;    Stack&lt;BinNodePosi(T)&gt;S; //辅助栈    while(true)&#123; //以右子树为单位，逐批访问节点        visitAlongLeftBranch( x,visit,S); //访问子树x的左侧链，右子树入栈缓冲        if( S.empty() ) break; //栈空即退出        x = S.pop(); //弹出下一子树的根    &#125;&#125;\n\n\n中序遍历思路递归：\ntemplate&lt;typename T,typename VST&gt;void traverse( BinNodePosi(T) x,VST &amp; visit )&#123;    if( !x ) return;    traverse( x-&gt;lChild,visit );    visit( x-&gt;data );    traverse( x-&gt;rChild,visit );&#125; //T(n) = T(a) + O(1) + T(n-a-1) = O(n)\n\n\n从根节点开始一直沿着左侧分支逐层向下直到末端\n因此整个中序遍历分解为在不同尺度下的一系列的对左侧分支的逐步处理\n\n\n从根出发沿左分支下行，直到最深的节点——它就是全局首先被访问者\n自上而下谦让，再自下而上访问\n\n实现template&lt;typename T&gt;static void goAlingLeftBranch( BinNodePosi(T) x,Stack&lt;BinNodePosi(T)&gt; &amp; S )&#123; while(x) &#123; S.push(x); x = x-&gt;lChild; &#125;&#125; //反复地入栈，沿左分支深入template&lt;typename T,typename v&gt; void travIn_I1( BinNodePosi(T) x,V&amp; visit )&#123;    Stack&lt;BinNodePosi(T)&gt; S; //辅助栈    while(true)&#123;        goAlongLeftBranch(x, S); //从当前节点出发，逐批入栈        if( S.empty() ) break; //直至所有节点处理完毕        x = S.pop(); //x的左子树或为空，或已遍历（等效于空），故可以        visit( x-&gt;data ); //立即访问之        x = x-&gt;rChild; //再转向其右子树(可能为空，需留意处理手法)    &#125;&#125;\n\n\n所有左侧链的长度集中在一起也就是O(n)\n每一个节点的入栈操作对应的是左侧链上的一步，因此左侧链的长度就是push的操作次数\n后序遍历递归：\ntemplate&lt;typename T,typename VST&gt;void traverse( BinNodePosi&lt;T&gt; x,VST &amp; visit )&#123;    if( !x ) return;    traverse( x-&gt;lc,visit );    traverse( x-&gt;rc,visit );    visit( x-&gt;data );&#125;\n\n\n\n从根出发下行，尽可能沿左分支，实不得已，才沿右分支\n最后一个节点，必是叶子，而且是按中序遍历次序最靠左者，也是递归版中visit()首次执行处\n\ntemplate&lt;typename T&gt;static void gotoleftmostleaf( Stack&lt;BinNodePosi&lt;T&gt;&gt; &amp; S)&#123;    while( BinNOdePosi&lt;T&gt; x = S.top() ) //自顶而下反复检查栈顶节点        if( HasLChild(*x) )&#123; //尽可能向左，在此之前            if( HasRChild(*x) ) //若有右孩子，则                S.push( x-&gt;rc ); //优先入栈            S.push( x-&gt;lc ); //然后转向左孩子        &#125;else //实不得已            S.push( x-&gt;rc ); //才转向右孩子    S.pop(); //返回之前，弹出栈顶的空节点&#125;\n\ntemplate&lt;typename T,typename VST&gt;void travPost_I( BinNodePosi&lt;T&gt; x,VST &amp; visit )&#123;    Stack&lt;BinNodePosi&lt;T&gt;&gt; S; //辅助栈    if(&#125;\n\n层次遍历在此前的三种遍历中，都是后代先于祖先访问，即逆序，为此，都会使用到栈\n而在层次遍历中，所有节点都将按照深度次序由高至低访问\ntemplate&lt;typename T&gt;template&lt;typename T&gt;void BinNode&lt;T&gt;::travLevel( VST &amp; visit)    Queue&lt;BinNodePosi(T) Q; //引入辅助队列\tQ.enqueue( this ); //根节点入队\twhile( !Q.empty() )&#123; //在队列再次清空之前，反复迭代        BinNodePosi(T) x = Q.dequeue(); //在取出队首节点        visit( x-&gt;data );         if( HasLChild(*x) ) Q.enqueue( x-&gt;lChild ); //左孩子入队        if( HasRChile(*x) ) Q.enqueue( x-&gt;rChild ); //右孩子入队    &#125;\n\n\nHuffman树无前缀冲突编码各自的叶子不会待在另一叶子的通路上\n\n编码成本相差一个bit，影响的是带宽，费用，成本等等\n\n之所以要平衡，是为了杜绝深度差够大，至少是2的瑕疵，一旦有这种瑕疵，就可以通过交换进行优化\n带权编码长度因为频度的不同\n\n根据频率高/低的(超)字符，应尽可能放在高/低处\n故此，通过适当的交换，同样可以缩短wald(T)\n\n编码算法贪婪策略：频率低的字符优先引入，位置亦更低\n为每个字符创建一棵单节点的树，组成森林F\n按照出现频率，对所有树排列\nwhile( F中的树不止一棵 )    取频率最小的两棵树：T1和T2    将它们合并成一棵新树T，并令：    \tlchild(T) = T1且rChild(T) = T2    \tw(root(T)) = w(root(t1)) + w(root(T2))\n\n构造编码书\n每次取最小两个数合并(贪心)，并慢慢成长\n \n编码表：遍历，先中后序都可以，因为都是深度优先\n解码：从根开始，走到叶子，打印字符，再重置到根循环\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"向量","url":"/2021/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F/","content":"向量抽象数据类型=数据模型+定义在该模型上的一组操作\n数据结构 =基于某种特定语言，实现ADT的一整套算法\n向量ADT向量是数组的抽象与泛化，由一组元素按线性次序封装而成\n各元素与[0，n）内的秩（rank）一一对应（循秩访问）\n元素的类型不限于基本类型\n操作、管理维护更加简化、统一安全\n可更为便捷地参与复杂数据结构的定制与实现\n\n构造与析构http://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/vector/vector.h.htm\nusing Rank = int; //秩#define DEFAULT_CAPACITY  3 //默认的初始容量（实际应用中可设置为更大）template &lt;typename T&gt; class Vector &#123; //向量模板类protected:Rank _size; Rank _capacity;  T* _elem; //规模、容量、数据区void copyFrom ( T const* A, Rank lo, Rank hi ); //复制数组区间A[lo, hi)void expand(); //空间不足时扩容void shrink(); //装填因子过小时压缩bool bubble ( Rank lo, Rank hi ); //扫描交换void bubbleSort ( Rank lo, Rank hi ); //起泡排序算法Rank maxItem ( Rank lo, Rank hi ); //选取最大元素void selectionSort ( Rank lo, Rank hi ); //选择排序算法void merge ( Rank lo, Rank mi, Rank hi ); //归并算法void mergeSort ( Rank lo, Rank hi ); //归并排序算法void heapSort ( Rank lo, Rank hi ); //堆排序（稍后结合完全堆讲解）Rank partition ( Rank lo, Rank hi ); //轴点构造算法void quickSort ( Rank lo, Rank hi ); //快速排序算法void shellSort ( Rank lo, Rank hi ); //希尔排序算法public:// 构造函数Vector ( int c = DEFAULT_CAPACITY, Rank s = 0, T v = 0 ) //容量为c、规模为s、所有元素初始为v&#123; _elem = new T[_capacity = c]; for ( _size = 0; _size &lt; s; _elem[_size++] = v ); &#125; //s&lt;=cVector ( T const* A, Rank n ) &#123; copyFrom ( A, 0, n ); &#125; //数组整体复制Vector ( T const* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; //区间Vector ( Vector&lt;T&gt; const&amp; V ) &#123; copyFrom ( V._elem, 0, V._size ); &#125; //向量整体复制Vector ( Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; //区间// 析构函数~Vector() &#123; delete [] _elem; &#125; //释放内部空间// 只读访问接口Rank size() const &#123; return _size; &#125; //规模bool empty() const &#123; return !_size; &#125; //判空Rank find ( T const&amp; e ) const &#123; return find ( e, 0, _size ); &#125; //无序向量整体查找Rank find ( T const&amp; e, Rank lo, Rank hi ) const; //无序向量区间查找Rank search ( T const&amp; e ) const //有序向量整体查找&#123; return ( 0 &gt;= _size ) ? -1 : search ( e, 0, _size ); &#125;Rank search ( T const&amp; e, Rank lo, Rank hi ) const; //有序向量区间查找// 可写访问接口T&amp; operator[] ( Rank r ); //重载下标操作符，可以类似于数组形式引用各元素const T&amp; operator[] ( Rank r ) const; //仅限于做右值的重载版本Vector&lt;T&gt; &amp; operator= ( Vector&lt;T&gt; const&amp; ); //重载赋值操作符，以便直接克隆向量T remove ( Rank r ); //删除秩为r的元素int remove ( Rank lo, Rank hi ); //删除秩在区间[lo, hi)之内的元素Rank insert ( Rank r, T const&amp; e ); //插入元素Rank insert ( T const&amp; e ) &#123; return insert ( _size, e ); &#125; //默认作为末元素插入void sort ( Rank lo, Rank hi ); //对[lo, hi)排序void sort() &#123; sort ( 0, _size ); &#125; //整体排序void unsort ( Rank lo, Rank hi ); //对[lo, hi)置乱void unsort() &#123; unsort ( 0, _size ); &#125; //整体置乱Rank deduplicate(); //无序去重Rank uniquify(); //有序去重// 遍历void traverse ( void (* ) ( T&amp; ) ); //遍历（使用函数指针，只读或局部性修改）template &lt;typename VST&gt; void traverse ( VST&amp; ); //遍历（使用函数对象，可全局性修改）&#125;; //Vector\n\n原理：\n\n向量的复制\ntemplate&lt;typename T&gt; //T为基本类型，或已重载赋值操作符&#x27;=&#x27;void vector&lt;T&gt;::copyFrom(T* const A,Rank lo,Rank hi)&#123;    _elem = new T[_capacity = 2*(hi-lo)]; //分配空间,预留出足够的空间，在接下去足够长的时间内，不必因为有必要的扩容而打断计算过程    _size = 0; //规模清零    while(lo&lt;hi) //A[lo,hi)内的元素逐一        _elem[size++] = A[lo++]; // 复制至_elem[0,hi-lo)&#125;\n\n\n可扩充向量若采用静态空间管理策略，容量_capacity固定，则有明显的不足\n\n上溢（overflow）：_elem[]不足以存放所有元素\n尽管此时系统仍有足够的空间\n\n下溢（underflow）：_elem[]中的元素寥寥无几\n装填因子（load factor）size/capacity &lt;&lt; 50% \n\n\n更糟糕的是，一般的应用环境中难以准确预测空间的需求量\n可否使得向量可随实际需求动态调整容量，并同事保证高效率？\n动态空间管理在即将发生上溢时，适当的扩大内部数组的容量\n\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::expand()&#123;\t//向量空间不足时扩容    if(_size&lt;_capacity)return; //尚未满员，不必扩容    _capacity = max(_capacity,DEFAULT_CAPACITY); //不低于最小容量    T* oldElem = _elem;    _elem = new T[_capacity &lt;&lt;= 1]; //容量加倍    for(int i = 0;i &lt; _size; i++) //复制原向量内容        _elem[i] = oldElem[i]; //T为基本类型，或已重载赋值操作符&#x27;=&#x27;    delete[]oldElem; //释放原空间&#125;\n\n得益于向量的封装，尽管扩容之后的数据区的物理地址有所改变，却不致出现野指针\n递增式扩容T* oldElem = _elem; _elem = new T[_capacity += INCREMENT];//追加固定大小的容量\n\n最坏情况：在初始容量0的空向量中，连续插入n=m*I &gt;&gt; 2个元素…\n每一次的扩容与复制都会使得时间成本过多\n加倍式扩容T* oldElem = _elem; _elem = new T[_capacity &lt;&lt;= 1];//容量加倍\n\n在最坏去情况下，在初始容量为1的满向量中，连续插入n=2^m &gt;&gt; 2个元素\n各次扩容过程中复制原向量的时间成本依次为\n1,2,4,8，。。。，2^m = n  //几何级数\n总体耗时=O(n)，每次扩容的分摊成本为O(1)\n\n分摊复杂度平均复杂度或期望复杂度( average/expected complexity )\n\n根据数据结构各种操作出现概率的分布，将对应的成本加权平均\n\n各种可能的操作，作为独立事件分别考查\n\n割裂了操作之间的相关性和连贯性\n\n往往不能准确地评判数据结构和算法的真实性能\n\n\n分摊复杂度( amortized complexity )\n\n对数据结构连续地实施足够多次操作,所需总体成本分摊至单次操作\n从实际可行的角度,对一系列操作做整体的考量\n更加忠实地刻画了可能出现的操作序列\n可以更为精准地评判数据结构和算法的真实性能\n\n无序向量循秩访问从便捷性出发，实现和数组元素访问方式一样的：A[r]\n因此，重载下标操作符“[]”\ntemplate&lt;typename T&gt; //0 &lt;= r &lt; _sizeT &amp; vector&lt;T&gt;::operator[](Rank r) const &#123; return _elem[r]; &#125;\n\n右值：T x = v[r] + U[s] * W[t];\n左值：v[r] = (T)(2*X+3); //因为是引用的方式，所以可以为左值\n插入因为所有的向量元素都是紧邻排序的，所以为了能够插入新的元素，就必须将新元素的后缀元素整体右移\ntemplate&lt;typename T&gt; //e作为秩为r元素插入，0&lt;=r&lt;=sizeRank vector&lt;T&gt;::insert(Rank r,T const &amp; e)&#123;//O(n-r)    expand(); //若有必要，扩容    for(int i = _size;i &gt; r;i--) //自后向前，如果次序颠倒，则有可能出现数据被覆盖的危险        _elem[i] = _elem[i-1]; //后继元素顺次后移一个单元    _elem[r] = e; _size++; //置入新元素，更新容量    return r; //返回秩&#125;\n\n\n删除删除后，后缀统一左移，自前向后的前移操作，若顺序颠倒，可能出现危险\ntemplate&lt;typename T&gt; //删除区间[lo,hi),0&lt;=lo&lt;=hi&lt;=sizeint vector&lt;T&gt;::remove(Rank lo,Rank hi)&#123;//O(n-hi)    if(lo==hi) return 0; //出于效率考虑，单独处理退化情况    while(hi&lt;_size)        _elem[lo++] = _elem[hi++]; //[hi,_size)顺次前移hi-lo位    _size = lo; shrink(); //更新规模，若有必要缩容    return hi-lo;&#125;\n\n\n单元素删除可以视作区间删除操作的特例：[r] = [r,r+1)\n template&lt;typename T&gt; //删除向量中秩为r的元素，0&lt;=r&lt;sizeT vector&lt;T&gt;::remove(Rank r)&#123; //O(n-r)    T e = _elem[r]; //备份被删除的元素    remove(r,r+1); //调用区间删除算法    return e; //返回被删除元素&#125;\n\n查找template&lt;typename T&gt; //0&lt;=lo&lt;hi&lt;=_sizeRank vector&lt;T&gt;::find(T const &amp; e,Rank lo,Rank hi)const&#123;//O(hi-lo)=O(n),在命中多个元素时可返回秩最大者   while((lo &lt; hi--)&amp;&amp;(e != _elem[hi])); //逆向查找    return hi; //hi&lt;lo意味着失败；否则hi即命中元素的秩&#125;\n\n输入敏感算法：最好O(1)，最差O(n)\n去重/唯一化应用实例：网络搜索的局部结果经过去重操作，汇总为最终报告\ntemplate &lt;typename T&gt; //删除重复元素，返回被删除元素数目int Vector&lt;T&gt;::deduplicate() &#123; //繁琐版+错误版   int oldSize = _size; //记录原规模   Rank i = 1; //从_elem[1]开始   while (i &lt; _size) //自前向后逐一考查各元素_elem[i]      if (find(_elem[i], 0, i) &lt; 0) //在前缀中寻找与之雷同者（至多一个）         i++; //若无雷同则继续考查其后继      else         remove(i); //否则删除当前元素（至多一个？）   return oldSize - _size; //被删除元素总数&#125;\n\n正确性：\n不变性：在当前元素 v[i] 的前缀 v[0,i] 中，各元素彼此互异\n单调性：随着反复的while迭代\n\n当前元素前缀的长度单调非降，且迟早增至_size \n当前元素后缀的长度单调下降，且迟早减至0\n\n故算法必然终止，且至多迭代O(n)轮\n\n复杂度：\n每轮迭代中 find() 和 remove() 累计耗费线性时间，故总体为O(n^2)\n遍历遍历向量，统一对各元素分别实施visit操作\n利用函数指针实例，只读或局部性修改\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::traverse(void (*visit)(T&amp;)) //函数指针&#123;    for (int i = 0;i &lt; _size;i++)        visit(_elem[i]);&#125;\n\n利用函数对象机制，可全局性修改\ntemplate&lt;typename T&gt; template&lt;typename VST&gt;void vector&lt;T&gt;::traverse(VST&amp; visit) //函数对象&#123;    for (int i = 0;i &lt; _size;i++)        visit(_elem[i]);&#125;\n\n有序向量如何甄别一个向量是否有序\n有序/无序序列中，任意/总有一对相邻元素顺序/逆序\n因此，相邻逆序对的数目，可用以度量向量的逆序程度\ntemplate&lt;typename T&gt; //返回逆序相邻元素对的总数int vector&lt;T&gt;::disordered()const&#123;    int n = 0; //计数器    for(int i = 1;i &lt; _size;i++) //逐一检查各队相邻元素        n += (_elem[i - 1] &gt; _elem[i]); //逆序则计数    return n; //向量有序当且仅当 n = 0&#125; //若只判断是否有序，则首次遇到逆序对之后，即可立即终止\n\n唯一化低效版观察：在有序向量中，重复的元素必要相互紧邻构成一个区间，每一个区间只需保留单个元素即可\ntemplate&lt;typename T&gt;int vector&lt;T&gt;::uniquify()&#123;    int oldSize = _size;    int i = 0; //从首元素开始    while(i &lt; _size-1) //从前向后，逐一比对各对相邻元素，若雷同，则删除后者；否则，转至后一元素        (_elem[i] == _elem[i+1])?remove(i+1):i++;    return oldSize - _size; //向量规模变化量，即删除元素总数&#125; //注意：其中_size的减少，由remove()隐式地完成\n\n运行时间主要取决于while循环，次数共计： _size-1 = n-1\n最坏情况下：每次都需调用remove()，耗时O(n-1)~O(1)；累计O(n^2) \n\n高效版如果能够将每一个区间作为一个整体，成批的删除雷同元素，则有可能实现一步到位式移动\ntemplate&lt;typename T&gt;int vector&lt;T&gt;::uniquify()&#123;    Rank i = 0,j = 0; //各对互异“相邻”元素的秩    while(++j &lt; _size) //逐一扫描，直至末元素        //跳过雷同；发现不同元素时，向前移至紧邻于前者右侧        if(_elem[i] != _elem[j])            _elem[++i] = _elem[j];    _size = ++i;     shrink(); //直接删除尾部多余元素    return j - i; //向量规模变化量，即被删除元素总数&#125; //注意：通过remove(lo,hi)批量删除，依然不能达到高效率\n\n共计n-1次迭代，每次常数时间，累计O(n)时间\n\n二分查找（A)语义约定至少应该便于有序向量自身的维护：v.insert ( 1 + v.search(e) , e )\n即便失败，也应给出新元素适当的插入位置\n若允许重复元素，则每一组也需按其插入的次序排列\n\n约定：在有序向量区间v[lo , hi) 中，确定不大于e的最后一个元素秩\n若-无穷 &lt; e &lt; v[lo]，则返回lo - 1（左侧哨兵）\n若 v[hi-1] &lt; e &lt; +无穷，则返回 hi-1（末元素=右侧哨兵左邻）\n原理\n二分（折半）策略：轴点mi总是取作中点——于是\n每经过至多两次比较，或者能够命中，或者将问题规模缩减一半\n实现template&lt;typename T&gt; //在有序向量区间[lo,hi)内查找元素estatic Rank binSearch(T* A,T const&amp; e,Rank lo,Rank hi)&#123;    while(lo &lt; hi)    &#123;\tRank mi = (lo + hi)&gt;&gt;1; //以中点为轴点     \tif(e &lt; A[mi]) hi = mi; //目标处于e的左侧，深入前半段[lo,mi)继续查找    \telse if(A[mi] &lt; e) lo = mi + 1; //目标\t处于e的右侧，深入后半段(mi,hi)     \telse return mi; //在mi处命中    &#125;    return -1; //查找失败&#125;\n\n\n\nFib查找\n二分查找版本A的效率仍有改进余地，因为不难发现转向左、右分支前的关键吗比较次数不等，而递归深度却相同\n若能通过递归深度的不均衡，来转向成本的不均衡进行补偿，平均查找长度应能进一步缩短\n\n\ntemplate&lt;typename T&gt; //0 &lt;= lo &lt;=hi &lt;= _sizestatic Rank fibsearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    Fib fib(hi-lo);    while(lo &lt; hi)    &#123;        while(hi - lo &lt; fib.get())            fib.prev(); //至多迭代几次？        //通过向前顺序查找，确定形如fib(k) - 1的轴点(分摊O(1))        Rank mi = lo + fib.get() - 1; //按黄金比例切分        if(e &lt; A[mi]) hi = mi; //深入前半段[lo,mi)继续查找        else if (A[mi] &lt; e)lo = mi + 1; //深入后半段(mi,hi)        else return mi; //在mi处命中    &#125;    return -1; //查找失败&#125;\n\n二分查找(B)每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个\n\n\n以上二分查找及Fibnacci查找算法\n均为严格地兑现search（）接口的语义约定：返回不大于e的最后一个元素\n\n只有兑现这一约定，才可有效支持相关算法，比如：v.insert（1+v.search（e），e）\n\n只有多个命中元素时，必须返回最靠后（秩最大）者\n失败时，应返回小于e的最大者（含哨兵[lo-1]）\n\n\n\ntemplate&lt;typename T&gt;static Rank binSearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    while(1 &lt; hi - lo)    &#123;//有效查找区间的宽度缩短至1时，算法才会终止        Rank mi = (lo + hi) &gt;&gt; 1; //以中点为轴点，经比较后确定深入        （e &lt; A[mi]) ? hi = mi : lo = mi; //[lo,mi)或[mi,hi)    &#125; //出口时hi = lo + 1,查找区间仅含一个元素A[lo]    return (e == A[lo]) ? lo : -1; //返回命中元素的秩或者-1&#125; //相较于版本A，最好（坏）情况下更坏（好）；各种情况下的SL更加接近，整体性能更趋稳定\n\n\n二分查找（C）template&lt;typename T&gt;static Rank binSearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    while(hi &lt; lo)    &#123;//不变性：A[0,lo) &lt;= e &lt; A[hi,n]        Rank mi = (lo + hi) &gt;&gt; 1; //以中点为轴点，经比较后确定深入        （e &lt; A[mi]) ? hi = mi : lo = mi + 1; //[lo,mi)或（mi,hi)    &#125; //出口时,A[lo = hi]为大于e的最小元素    return --lo; //故lo - 1即不大于e的元素的最大秩&#125;\n\n与版本B的差异\n\n待查找区间宽度缩短至0而非1时，算法才结束\n转入右侧子向量时，左边界取作mi+1而非mi\n无论成功与否，返回的秩严格符合接口的语义约定\n\n\n插值排序假设已知有序向量中各元素随机分布的规律，比如均匀且独立的随机分布\n那么[lo，hi）内各元素应大致按照线性趋势增长\n因此通过猜测轴点mi，可以极大提高收敛速度\n\n最坏情况：可能退化为平凡的顺序查找  O（hi - lo） = O（n）\n平均情况：每经一次比较，n缩至根号n\n\n\n易受小扰动的干扰和“蒙骗”\n\n须引入乘法、除法运算\n\n实际可行的方法\n首先通过插值查找，将查找范围缩小到一定的范围，然后再进行二分查找\n\n\n大规模：插值查找\n中规模：折半查找\n小规模：顺序查找\n起泡排序向量若有序排列，计算效率将大大提升\n如何实现向量的有序化？（排序算法）\n统一接口 sort（Rank lo，Rank hi）\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while(!bubble(lo,hi--)); &#125; //逐趟做扫描交换，直至全序\n\n不变性：每经过对bubble的调用，都会有一个新的元素就位（减而治之），有序的部分逐渐拓展，无序的部分逐渐缩减\n\n改进：绿色的部分未必都是无序的，有可能存在一部分或者所有绿色都是有序的\n如何尽早判定这种情况？\n每一趟扫描交换，都记录下是否存在逆序元素，若存在，当且仅当做过交换\n反例\n实质需要排序的元素集中在一个宽度仅为根号n的区间中\n \n多余出来的消耗就是在后缀中已就位元素的扫描交换\n记录在上一趟扫描交换中所进行的最后一趟交换，就可以知道上一趟有多长的后缀没有进行扫描交换，如果这样，只需将右侧标志hi指向新的位置\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while(lo &lt; (hi = bubble(lo,hi))); &#125; //逐趟做扫描交换，直至全序template&lt;typname T&gt;Rank vector&lt;T&gt;::bubble(Rank lo,Rank hi)&#123;    Rank last = lo; //最右侧的逆序对初始化为[lo - 1,lo]    while(++lo &lt; hi) //自左向右，逐一检查各队相邻元素        if(_elem[lo - 1] &gt; _elem[lo])        &#123;//若逆序，则更新最右侧逆序对位置记录，并交换         \tlast = lo;            swap(_elem[lo - 1],_elem[lo]);        &#125;    return last; //返回最右侧的逆序对位置&#125; \t\n\n归并排序\n序列一分为二，子序列递归排序，合并有序子序列\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::mergeSort(Rank lo,Rank hi)&#123;    if(hi - lo &lt; 2) return; //单元素区间自然有序    int mi = (lo + hi) &gt;&gt; 1; //以中点为界    mergeSort(lo,mi); //对前半段排序    mergeSort(mi,hi); //对后半段排序    merge(lo,mi,hi); //归并&#125;\n\n二路归并\n\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::merge(Rank lo,Rank mi,Rank hi)&#123;    T*A = _elem + lo; //合并后的向量A[0,hi - lo) = _elem[lo,hi)    int 1b = mi - lo;    T*B = new T[1b]; //前子向量B[0,1b) = _elem[lo,mi)    for(Rank i = 0;i &lt; 1b;B[i] = A[i++]); //复制前子向量B    int 1c = hi - mi;    T*C = _elem + mi; //后子向量C[0,1c) = _elem[mi,hi)    for(Rank i = 0,j = 0, k = 0;(j &lt; 1b) || (k &lt; 1c);)    &#123;//B[j]和C[k]中小者转至A的末尾        if((j &lt; 1b) &amp;&amp; (1c &lt;=k || (B[j] &lt;= C[k])))             A[i++] = B[j++]; //C[k]已无或不小        if((k &lt; 1c) &amp;&amp; (1b &lt;= j || (C[k] &lt; B[j])))            A[i++] = C[j++]; //B[j]已无或更大    &#125; //该循环实现紧凑；但就效率而言，不如拆分处理    delete[] B; &#125;\n\n\n\n\n一般B提前耗尽，就可终止算法\n复杂度\n算法的运行时间主要消耗与for循环，共有两个控制变量\n\n初始：j = 0，k = 0\n最终：j = lb，k = lc\n亦即：j + k = lb + lc = hi - lo = n\n\n每经过一次迭代，j和k中至少有一个会加一（j+k也必至少加一）\n故知：merge()总体迭代不过O(n)次，累计只需线性时间\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"图","url":"/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/","content":"图概述邻接+关联关系G = (V;E) 顶点;边\n邻接：顶点与顶点之间的关系\n关联：顶点以及与它相关的某条边的关系\n序列和树是图的一种特例\n\n\n在图中，任何两个节点之间都允许存在邻接关系，此课不讨论自环边\n无向图/有向图总度数(D)等于边数(e)的两倍。\nD=2e\n图G的顶点数n和边数e的关系\n\n若G是无向图，则0≤e≤n(n-1)/2。\n恰有n(n-1)/2条边的无向图称无向完全图(Undireet-ed Complete Graph)。\n\n若G是有向图，则0≤e≤n(n-1)。\n恰有n(n-1)条边的有向图称为有向完全图(Directed Complete Graph)。\n\n\nu，v分别称作边(u，v)的尾(tail)，头(head)\n混合图：既有有向边，又有无向边\n\n路径+环路简单路径simple path：如果在一条通路中不含重复的节点\n环路：路径的起点终点相同，也有简单与不简单之分\n有向无环图(DAG)：一个有向图中不包含任何环路\n欧拉环路：所有的有向边都可以构成一个环路\n哈密尔顿环路：经过每一个点一次而且恰好一次    \n邻接矩阵Graph模板类\n\n邻接矩阵+关联矩阵描述顶点之间相互邻接关系的一种形式\n\n\n无向图具有冗余性\n带权图：各边记录的权重记录于对应的单元 \n顶点和边vertex\ntypedef enum &#123;UNDISCOVERED,DISCOVERED,VISITED&#125; VStatus;template&lt;typename Tv&gt;struct Vertex &#123; //顶点对象(并未严格封装)    Tv data;int inDegree,outDegree; //数据、出入度数    VStatus status; //(如上三种)状态    int dTime,fTime; //时间标签    int parent; //在遍历树中的父节点    int priorty; //在遍历树种的优先级(最短通路、极短跨边等)    Vertex(Tv const &amp; d): //构造新顶点    data(d),inDegree(0),outDegree(0),status(UNDISCOVERED),    dTime(-1),fTime(-1),parent(-1),priority(INT_MAX)&#123;&#125;&#125;;\n\nEdge\ntypedef    enum&#123;UNDETERMINED,TREE,CROSS,FORWARD,BACKWARD&#125;\tEStatus;template&lt;typename T&gt;struct Edge&#123; //边对象(并未严格封装)    T data; //数据    int weight; //权重    EStatus status; //类型    Edge(Te const &amp; d,int w)://构造新边    \tdata(d),weight(w),status(UNDETERMINED)&#123;&#125;&#125;；\n\n邻接矩阵GraphMatrix\n用邻接矩阵实现含n个顶点e条边的图，空间复杂度;O(n^2)\n删除边(i, j)的时间复杂度:O(1)\n遍历顶点v的所有邻居的时间复杂度:O(n)\n访问顶点v中存储的数据的时间复杂度:O(1)\ntemplate&lt;typename Tv,typename Te&gt;class GraphMatrix:public Graph&lt;Tv,Te&gt;&#123;private:    vector&lt;Vertex&lt;Tv&gt;&gt; V; //顶点集    Vector&lt;Vector&lt;Edge&lt;Te&gt;*&gt;&gt; E; //二维向量，边集 E[i][j]public:    /*操作接口：顶点相关，边相关，。。。*/    GraphMatrix() &#123;n = e = 0;&#125; //构造    ~GraphMatrix()&#123; //析构        for (int j = 0;j &lt; n;j++)            for(int k = 0;k &lt; n;k++)                delete E[j][k]; //清除所有动态申请的边记录    &#125;&#125;\n\n\n顶点静态操作Tv &amp; vertex(int i) &#123;return V[i].data;&#125; //数据int inDegree(int i) &#123;return V[i].inDegree;&#125; //入度int outDegree(int i) &#123;return V[i].outDegree;&#125; //出度Vstatus &amp; status(int i) &#123;return V[i].status;&#125; //状态int &amp; dTime(int i) &#123;return V[i].dTime;&#125;int &amp; fTime(int i) &#123;return V[i].fTime;&#125;int &amp; parent(int i) &#123;return V[i].parant;&#125; //在遍历树中的父亲int &amp; priority(int i) &#123;return V[i].priority;&#125; //优先级数\n\n对于任意顶点i，如何枚举其所有的邻接顶点neighbor？\ni在邻接矩阵中对应的那一行，或0或1\nint nextNbr(int i,int j)&#123; //若已枚举至邻居j，则转向下一邻居    while((-1 &lt; j) &amp;&amp; !exist(i,--j)); //逆向顺序查找，O(n)    return j;&#125;int firstNbr(int i)&#123;    return nextNbr(i,n);&#125; //首个连接，通过假想哨兵n\n\n边操作bool exists(int i,int j) &#123;//判断(i,j)是否存在    return (0 &lt;= i) &amp;&amp; (i &lt; n) &amp;&amp; (0 &lt;= j) &amp;&amp; (j &lt; n) &amp;&amp; E[i][j] != NULL; //短路求值&#125; //以下假定exists(i,j)...Te &amp; edge(int i,int j) //边(i,j)的数据&#123; return E[i][j]-&gt;data; &#125; //O(1)Estatus &amp; status(int i,int j) //边(i,j)的状态&#123; return E[i][j]-&gt;status; &#125; //O(1)Estatus &amp; Weight(int i,int j) //边(i,j)的权重&#123; return E[i][j]-&gt;Weight; &#125; //O(1)\n\n如何在一幅图中插入一条边\n假设顶点i和顶点j之间连接一条有向边，只需要将待插入的边的信息封装为一个具体的边记录，然后将新的边记录的地址存入邻接矩阵对应的那个单元，反过来这个单元也将指向记录\nvoid insert(Te const&amp; edge,int w,int i,int j)&#123; //插入(i,j,w)    if (exists(i,j)) return; //忽略已有的边    E[i][j] = new Edge&lt;Te&gt;(edge,w); //创建新边    e++; //更新边计数    v[i].outDegree++; //更新关联顶点i的出度    v[j].inDegree++; //更新关联顶点j的入度&#125;\n\n边删除\n将对应的边记录释放，然后邻接矩阵中的引用指向空\nTe remove(int i,int j)&#123; //删除顶点i和j之间的联边(exists(i,j))    Te eBak = edge(i,j); //备份边(i,j)的信息    delete E[i][j]; E[i][j] = NULL; //删除边(i,j)    e--; //更新边计数    V[i].outDegree--; //更新关联顶点i的出度    V[j].inDegree--; //更新关联顶点j的入度    return eBak; //返回被删除边的信息&#125;\n\n顶点动态操作\nint insert(Tv const &amp; vertex) &#123; //插入顶点，返回编号    for (int j = 0;j &lt; n;j++) E[j].insert(NULL); n++; //第一步：插入新一列    E.insert(vector&lt;Edge&lt;Te&gt;*&gt;(n,n,NULL)); //第二三步：长度为新n的行向量   \treturn v.insert(Vertex&lt;Tv&gt;(vertex)); //\t第四步：创建顶点记录，存入顶点向量&#125;\n\n\n综合评价优点：\n\n直观，易于理解和实现\n适用范围广\n判断两点之间是否存在联边O(1)\n获取顶点的度数：O(1)，添加、删除边后更新度数：O(1)\n扩展性：\n得益于vector良好的空间控制策略\n空间溢出等情况可“透明地”予以处理\n\n\n\n缺点：\n\nO(n^2)空间，与边数无关！\n真会有这么多条边？\n平面图：不相联的边不能相交，可嵌于平面的图\n欧拉公式出发，对于平面图而言，边的总是不可能超过顶点的总数。&lt;&lt;n^2 ,此时空间利用率约等于 1/n\n\n广度优先搜索支撑树\n以S为起点，将所有顶点划分为若干个等价类，同一等价类内部，各顶点的边不会被采纳，只有连接于相邻等价类之间的边才会被采纳(未必)\n所有被保留并且采纳的边，足以把所有的点连起来，也不至于造成环路(极大无环图)\n等价类到起点S的距离是逐次单调变化，等同于树的层次遍历\n实现Graph::BFS()\ntemplate&lt;typename Tv,typename Te&gt; //顶点类型，边类型void Graph&lt;Tv,Te&gt;::BFS(int v,int &amp; clock)&#123;    Queue&lt;int&gt; Q; status(v) = DISCOVERED; Q.enqueue(v); //初始化    while (!Q.empty())&#123;        int v = Q.dequeue();        dTime(v) = ++clock; //取出队首顶点v，并        for (int u = firstNbr(v); -1 &lt; u;u = nextNbr(v,u)) //考察v的每一邻居u            /*视u的状态，分别处理...*/            status(v) = VISITED; //至此，顶点访问完毕    &#125;&#125;\n\nwhile (!Q.empty())&#123;       int v = Q.dequeue();       dTime(v) = ++clock; //取出队首顶点v，并       for (int u = firstNbr(v); -1 &lt; u;u = nextNbr(v,u)) //考察v的每一邻居u           if (UNDISCOVERED == status(u))&#123;               status(u) = DISCOVERED; Q.enqueue(u); //发现该顶点               status(v,u) = TREE; parent(u) = v; //引入树边           &#125; else //若u已被发现（正在队列中），或者甚至已访问完毕（已出队列）               status(v,u) = CROSS; //将(v,u)归类于跨边           status(v) = VISITED; //至此，顶点访问完毕   &#125;\n\n实例\n\n\n\n当不再有新的tree edge生成，所有节点都已转成visited状态，剩下的tree edge生成一棵遍历支撑树\n多连通在含有多个连用域时，从多个起点s出发未必能够抵达其他连通域，如何使得BFS搜索足以覆盖整幅图，而不是某个连通域\ntemplate&lt;typename Tv,typename Te&gt; //顶点类型、边类型void Graph&lt;Tv,Te&gt;::bfs(int s)&#123; //s为起始顶点    reset(); int clock = 0; int v = s; //初始化O(n+e)    do //逐一检查所有顶点，一旦遇到尚未发现的顶点        if (UNDISCOVERED == status(v)) //累计O(n)            BFS(v,clock); //即从该顶点出发启动一次BFS    while (s != (v = (++v % n)));    //按序号访问，故不漏不重&#125;\n\n并非对每个顶点都启动搜索，此方法可保证对于每个连通域只有一个顶点可以作为起点引起它所属的那个连通域被完全遍历，每个连通域只启动一次BFS，搜索时间累计全图的一次遍历\n复杂度外部while循环因为每个顶点都会仅一次入队，所以dequeue操作也将执行O(n)次\n内部for(循环)是对顶点v所对应的行向量进行线性扫描n个单元\n在对整个行向量的访问过程中，所有的元素都有极高的概率处于高速缓存中\n\n连续、规则、紧凑的组织形式利于高速缓冲机制发挥作用\n存储级别之间巨大的速度差异，在实际应用中往往更为举足轻重\n\n\n最短路径树结构中，相对于树根节点，都对应于一条唯一的通路，路径的长度称为顶点v的深度，每一个等价类的深度指标都是相等的，树的层次遍历则是按照这一指标将所有顶点枚举出来\nBFS所给出的顶点序列，也是按照非降次序单调排列的。\n在最终生成的BFS树中，每个顶点与s之间的那条通路恰好就是这两个顶点之间的最短通路\n深度优先搜索深度优先搜索算法策略更为简明，过程更为复杂，功能更为强大\nDFS(s) \n​    访问顶点s\n​    若s尚有未被访问的邻居，则任取其一u，递归执行DFS(u)\n​    否则，返回\n\n框架template &lt;typename Tv,typename Te&gt; //顶点类型、边类型void Graph&lt;Tv,Te&gt;::DFS(int v,int &amp; clock)&#123;    dTime(v) = ++clock; status(v) = DISCOVERED; //发现当前顶点v    for (int u = firstNbr(v);-1 &lt; u;u = nextNbr(v,u)) //枚举v的每一邻居u        /*...视u的状态，分别处理...*/        /*...与BFS不同，含有递归...*/        status(v) = VISITED; fTime(v) = ++clock; //\t至此，当前顶点v方告访问完毕&#125;\n\n细节for (int u = firstNbr(v);-1 &lt; u;u = nextNbr(v,u)) //枚举v的每一邻居u    switch (status(u))&#123;        case UNDISCOVERED:            status(v,u) = TREE; parent(u) = v; DFS(u,clock); break; //递归        case DISCOVERED: //u已被发现但尚未访问完毕，应属被后代指向的祖先            status(v,u) = BACKWARD; break;        default: //U已放我完毕，则视承袭关系分为前向边或跨边            status(v,u) = dTime(v) &lt; dTime(u) ? FORWARD : CROSS; break;    &#125;\n\n无向图\n\n有向图\n\n一旦发现了backward边，则出现了一条回路\na的可达区都扫描完毕，第一轮循环结束\n\n粗边构成两颗遍历树\n嵌套引理顶点的活动期：active[u] = (dTime[u] , fTime[u])\n没有血缘关系的节点，活跃期彼此不搭\n\n拓扑排序零入度任给有向图G(不一定是DAG)，尝试将所有顶点排成一个线性序列，使其次序须与原图相容(每一顶点都不会通过边指向前驱顶点)\n\n提出不需要前驱的点，逐渐递归\n\n零出度\n\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"列表","url":"/2021/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%97%E8%A1%A8/","content":"列表接口与实现根据是否修改数据结构，所有操作大致分为两类方式\n\n静态：仅读取，数据结构的内容及组成一般不变：get、search\n动态：需写入，数据结构的局部或整体将改变：insert、remove\n\n与操作方式相对应地，数据元素的存储与组织方式也分为两种\n\n静态：\n\n数据空间整体创建或销毁\n数据元素的物理存储次序与其逻辑次序严格一致\n可支持高效的静态操作\n比如向量，元素的物理地址与其逻辑次序线性对应\n\n\n动态：\n\n为各数据元素动态地分配和回收的物理空间\n逻辑上相邻的元素记录彼此的物理地址，在逻辑上形成一个整体\n可支持高效的动态操作\n\n\n\n从向量到列表列表（list）是采用动态存储策略的典型结构，其中的元素称作节点（node）\n各节点通过指针或引用彼此联接，在逻辑上构成一个线性序列\n相邻节点彼此互称前驱或后驱\n没有前后驱的唯一节点称作首（first/front）/末（last/rear）节点\n从秩到位置向量支持循秩访问的方式（这种方式效率高）\n然而在列表中，这种循秩访问的成本过高，已不合时宜\n因此，应该用循位置访问的方式，即利用节点之间的相互引用，找到特定的节点 \n\nADT接口\n\n列表节点类：\n#define Posi(T) ListNode&lt;T&gt;* //列表节点位置template&lt;typename T&gt;struct ListNode&#123; //列表节点模板类（以双向链表形式实现）    T data; //数值    Posi(T) pred; //前驱    Posi(T) succ; //后继    ListNode()&#123;&#125; //针对header和trailer的构造    ListNode(T e,Posi(T)p = NULL,Posi(T) s = NULL)        :data(e),pred(p),succ(s)&#123;&#125; //默认构造器    Posi(T) insertAsPred(T const&amp; e); //前插入    Posi(T) insertAsSucc(T const&amp; e); //后插入 &#125;;\n\n\n头、首、末、尾节点的秩可分别理解尾-1，0，n-1，n\n\n template&lt;typename T&gt; void List&lt;T&gt;::init()&#123;//初始化，创建列表对象时统一调用    header = new ListNode&lt;T&gt;; //创建头哨兵节点    trailer = new ListNode&lt;T&gt;; //创建尾哨兵节点    header-&gt;succ = trailer; header-&gt;pred = NULL; //互联    trailer-&gt;pred = header; trailer-&gt;succ = NULL; //互联    _size = 0; //记录规模&#125;\n\n无序列表插入template&lt;typename T&gt;Posi(T) List&lt;T&gt;::insertBefore(Posi(T)p,T const&amp; e)&#123; _size++; return p-&gt;insertAsPred(e); &#125;//e当做p的前驱插入\n\ntemplate&lt;typename T&gt; //前插入算法（后插入算法完全对称）Posi(T)ListNde&lt;T&gt;::insertAsPred(T const&amp; e)&#123;    Posi(T) x = new ListNode(e,pred,this); //创建（耗时一百倍）    pred-&gt;succ = x;    pred = x;    return x; //建立连接，返回新节点的位置&#125;\n\n即便当前节点是首节点，前驱依然是存在的（哨兵）\n\n基于复制的构造\ntemplate&lt;typename T&gt; //基本接口void List&lt;T&gt;::copyNodes(Posi(T) p,int n)&#123;    init(); //创建头、尾哨兵节点并做初始化    while(n--) //将起自p的n项依次作为末节点插入    &#123; insertAslast(p-&gt;data); p = p-&gt;succ; &#125;&#125;\n\n所谓insertAsLast其实就是insertBefore(trailer)\n删除与析构删除：\ntemplate&lt;typename T&gt; //删除合法位置p处节点，返回其数值T List&lt;T&gt;::remove(Pose(T) P)&#123; //O(1)    T e = p-&gt;data; //备份待删除节点数值（设类型T可直接赋值）    p-&gt;pred-&gt;succ = p-&gt;succ;    p-&gt;succ-&gt;pred = p-&gt;pred;    delete p;    _size--;    return e; //返回备份数值&#125;\n\n\n析构：\ntemplate&lt;typename T&gt; List&lt;T&gt;::~List()//列表析构&#123; clear(); delete header; delete trailer; &#125; //清空列表，释放头、尾\n\ntemplate&lt;typename T&gt; int List&lt;T&gt;::clear()&#123; //清空列表\tint oldSize = _size;    while(0 &lt; _size) //反复删除首节点，直至列表变空        remove(header-&gt;succ);    return oldSize;&#125; //O(n),线性正比于列表规模\n\n查找在节点p（可能是trailer）的n个（真）前驱中，找到等于e的最后者\ntemplate&lt;typename T&gt; //从外部调用时，0&lt;=n&lt;=rank(p)&lt;_sizePosi(T) List&lt;T&gt;::find(T const &amp;e,int n,Pose(T) p) const&#123; //顺序查找，O(n)    while(0 &lt; n--) //从右向左，逐个将p的前驱与e比对        if(e == (p = p-&gt;pred)-&gt;data)            return p; //直至命中或范围越界    return NULL; //若越出左边界，意味着查找失败&#125; \n\n如果目标节点有多个，那么会停止于最靠后的节点\n\n去重template&lt;typename T&gt; int List&lt;T&gt;::deduplicate()&#123; //剔除无序列表中重复的节点    if(_size &lt; 2) return 0; //平凡列表自然无重复    int oldSize = _size; //记录原规模    Pose(T) p = first(); rank r = 1; //p从首节点起    while(trailer != (p = p-&gt;succ))    &#123; //依次直到末节点        Posi(T) q = find(p-&gt;data,r,p); //在p的r个（真）前驱中，查找与之雷同者        q ? remove(q) : r++; //若的确存在，则删除；否则秩递增    &#125; //assert：循环过程中的任意时刻，p的所有前驱互不相同    return oldSize - _size; //列表规模变化量，即被删除元素总数&#125;\t\t\n\n有序列表唯一化\ntemplate&lt;typename T&gt; int List&lt;T&gt;::uniquify()&#123; //成批剔除重复元素    if(_size &lt; 2) return 0;    int oldSize = size;     ListNodePosi(T) p = first();    ListNodePosi(T) q; //p为各区段起点，q为其后继    while(trailer != (q = p-&gt;succ)) //反复考察紧邻的节点对（p，q）        if(p-&gt;data != q-&gt;data) p = q; //若互异，则转向下一区段    \telse remove(q);    return oldSize - _size; //被删除元素总数&#125; //只需遍历整个列表一趟，O(n)\n\n查找template&lt;typename T&gt; //在有序列表内节点p的n个（真）前驱中，找到不大于e的最后者Posi(T) List&lt;T&gt;::search(T const &amp;e,int n,posi(T) p) const&#123;    while(0 &lt;= n--) //对于p的最近的n个前驱，从右向左        if(((p = p-&gt;pred)-&gt;data) &lt;= e) break; //逐个比较   return p; //直至命中、数值越界或范围越界后，返回查找终止的位置&#125; //最好O(1)，最坏O(n);等概率时平均O(n),正比于区间宽度\n\nvector访问方式依据 rank 秩（RAM模型）\nList访问方式依据 Posi （TM模型）\n选择排序改进思路：相较于起泡排序的短距离小步慢跑式的挪动最大元素，为何不一次性完成这项工作\n\n//对列表中起始于位置p的连续n个元素做排序，valid（p） &amp;&amp; rank（p） + n &lt;= sizetemplate&lt;typname T&gt;void List&lt;T&gt;::selectionsort(Posi(T) p,int n)&#123;    Posi(T) head = p-&gt;pred;    Posi(T) tail = p; //待排序区间（head，tail）    for(int i = 0;i &lt; n;i++)         tail = tail -&gt; succ; //head/tail可能是头/尾哨兵    while(1 &lt; n)&#123;//反复从（非平凡的）待排序区间内找出最大者，并移至有序区间前端        insertBefore(tail,remove(selectMax(head-&gt;succ,n)));        tail = tail-&gt;pred;        n--; //待排序区间、有序区间的范围，均同步更新    &#125;&#125;\n\n\nselectMax（）\ntemplate&lt;typename T&gt; //从起始于位置p的n个元素中选出最大者，1 &lt; nPosi(T) List&lt;T&gt;::selectMax(Posi(T) P,int n)&#123; //O(n)    Posi(T) max = p; //最大者暂定为p    for(Posi(T) cur = p;1 &lt; n;n--) //后续节点逐一与max比较        if( !lt((cur = cur-&gt;succ)-&gt;data,max-&gt;data)) //若&gt;=max,则更新最大元素位置记录            max = cur;    return max;&#125;\n\n使用 &gt;= 可以对重复元素进行处理\n插入排序\n前缀部分总是有序直到整段有序\n//对列表中起始于位置p的连续n个元素做插入排序，valid(p) &amp;&amp; rank(p) + n &lt;= sizetemplate&lt;typename T&gt;void List&lt;T&gt;::insertionSort(Posi(T) p,int n)&#123;    for(int r = 0;r &lt; n;r++)&#123;        insertAfter(search(p-&gt;data,r,p),p-&gt;data); //查找+插入        p = p-&gt;succ;        remove(p-&gt;pred); //转向下一节点    &#125; //n次迭代，每次O(r+1)&#125; //仅使用O(1)辅助空间，属于就地算法\n\n\n最好情况：完全（或几乎）有序\n每次迭代，只需1次比较，0次交换，累计O(n)时间\n最坏情况：完全（或几乎）逆序\n第k次迭代，需O(k)次比较，1次交换，累计O(n^2)时间\n逆序对（inversion）某两个元素一左一右，左侧更大，右侧更小，则称为逆序对\n任何两个元素都可能构成逆序，所以长度为n的序列而言，逆序对的总数有可能多达O(n^2)，而将每一个逆序对都记到后面的账上，则对任何一个节点p，所对应的逆序对的总和则是整个序列逆序对的总数。\n\n p所对应的inversion有多少个，p就需要经过多少次比较抵达最终的插入位置，i（p）即是查找长度\n最好情况即是所有元素顺序输入，逐次递增，不含任何逆序对，所有，O（I+n），I为0\n相反，完全逆序输入情况，复杂度为n^2，其中任何一对都为逆序对。\n敏感输入(input-sensitive)：算法复杂度不光取决于问题的规模，而更多取决于输入本身所具有的特性，也就是无序程度。\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"图应用","url":"/2021/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E5%BA%94%E7%94%A8/","content":"图应用双连通分量判定准则\n\n给定无向图，如何确定BCC？\n从任一顶点出发，构造DFS树，根据DFS留下的标记，甄别是否是关节点\n\nDFS之后得到的那个叶子不会是关键点，因为删除节点后，连通量不会增加。因此，所有叶子可排除在外\n根：根在DFS中是随机的，只要不是只有1度，那必然是关节点。\n内部节点：\n根据回边是否指向比v高的祖先，指向，则v不是；若刚好指向v，则v是。\n\n\n\n\n算法#define hca(x) (fTime) //利用此处闲置的fTimetemplate&lt;typename Tv,typename Te&gt;void Graph&lt;Tv,Te&gt;::BCC(int v,int &amp; clock,stack&lt;int&gt; &amp; S)&#123;    hca(v) = dTime(v) = ++clock; status(v) = DISCOVERED;S.push(v);    for (int u = firstNbr(v);-1 &lt; u;u = nextNbr(v,u))        switch(status(u))            case UNDISCOVERED:    \t\t\tparent(u) = v; type(v,u) = TREE; //拓展树边    \t\t\tBCC(u,clock,S); //从u开始遍历，返回后...    \t\t\tif(hca(u) &lt; dTime(v)) //若u经后向边指向v的真祖先                    hca(v) = min(hca(v),hca(u)); //则v亦必如此    \t\t\telse //否则，则v为关节点(u即是一个BCC，且其中顶点此时正集中于栈S的顶部)                    while(u != S.pop());//弹出当前BCC中(除v外)的所有节点    \t\t\tbreak;            case DISCOVERED:    \t\t\ttype(v,u) = BACKWARD;    \t\t\tif(u != parent(v))                    hca(v) = min(hca(v),dTime(u));//更新hca[v],越小越高    \t\t\tbreak;    \t\tdefault: //VISITED(digraphs only)    \t\ttype(v,u) = dTime(v) &lt; dTime(u) ? FORWRD : CROSS;    \tbreak;&#125;\n\n实例\n\n\n\n优先级搜索早期向量和列表的访问次序是根据其结构本身，线性的次序，是显示可预测的。\nPFS：用某种数据结构把元素组织起来，并给各个元素分配一个优先级数，每一次做一个选择，对象就是优先级的拥有者，取出访问，循环至结束\nADT：\n\n\nDijkstra算法最短路径算法：O(1)\n\n一张网，拉离桌面，随着每一个点被拉离桌面，就能知道他们的次序，精确的记下拉离桌面的时间，则知道了最短距离\n每个点的优先级都是根据离开了桌面的前人来更新的\n拒绝负权边\n\n\nPrim算法最小支撑树\n\n\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"栈与队列","url":"/2021/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","content":"栈与队列last in first out\n\n栈既然属于序列的特例，故可直接基于向量或列表派生\ntemplate&lt;typename T&gt; class Stack:public vector&lt;T&gt;&#123; //由向量派生public: //size()、empty()以及其他开放接口均可直接沿用    void push(T const &amp; e)&#123; insert(size(),e);&#125; //入栈    T pop()&#123; return remove(size() - 1);&#125; //出栈    T &amp; top()&#123; return (*this)[size() - 1];&#125; //取顶&#125;; //以向量首/末端为栈底/顶——颠倒过来呢？每一次操作都会涉及到向量中的所有元素\n\n进制转换在计算过程中，没得到一个数位就通过push压入栈中\n\nvoid convert(stack&lt;char&gt; &amp; s,int64 n,int base)&#123;    static char digit[] = //新进制下的数位符号，可视base取值范围适当扩充    &#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;    while(n &gt; 0)    &#123; //由低到高，逐一计算出新进制下的各数位        s.push(digit[n % base]); //余数（对应的数位）入栈        n /= base; //更新为其对base的除商    &#125;&#125;\n\nmain()&#123;    stack&lt;char&gt; S;    convert(s,n,base); //用栈记录转换得到的各数位    while( !S.empty())         printf( &quot;%c&quot;,S.pop()); //逆序输出&#125;\n\n括号匹配\n\n平凡：无括号的表达式是匹配的\n\n\nbool paren(const char exp[],int lo,int hi)&#123; //exp[lo,hi)    stack&lt;char&gt; S; //使用栈记录已发现但尚未匹配的左括号    for(int i = 0;i &lt; hi;i++) //逐一检查当前字符        if(&#x27;(&#x27; == exp[i]) S.push(exp[i]);//遇左括号：则进栈    \telse if( !S.empty()) S.pop(); //遇右括号；若栈非空，则弹出左括号    \telse return false; //否则（遇有括号时栈已空），必不匹配    return S.empty(); //最终，栈空当且仅当匹配&#125;\n\n\n之所以不采用计数器方式是，无法用于多种括号并存情况，栈只需约定“括号”的通用格式，而不必事先固定括号的类型与数目\n栈混洗\n通过中转栈S，将A的元素转入B中\nS.push(A.pop())B.push(S.pop())\n\n\n\n甄别\n\n对于任何1&lt;=j&lt;k&lt;=n，[…,k…,i,…,j,…&gt; 必非栈混洗\nO（n）算法：直接借助栈A、B和S，模拟混洗过程\n​                        每次S.pop()之前，检测S是否已空；或需弹出的元素在S中，却非顶元素\n\n合法的栈混洗序列与合法的括号匹配表达式之间存在着一一对应的关系，n个元素的栈混洗有多少种，n对括号所能构成的合法表达式也就有多少种\n中缀表达式求值典型应用场合\n逆序输出：输出次序与处理过程颠倒；递归深度和输出长度不易预知\n递归嵌套：具有相似性的问题可递归描述，但分支位置和嵌套深度不固定\n延迟缓冲：线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀\n栈式计算：基于栈结构的特定计算模式\n\n在面对比较长的表达式时，很难定位当前可以计算的运算符，如果以线性扫描的次序处理表达式，计算的次序未必与扫描的次序完全一致\n可以利用栈结构，所有扫描过的部分保存为栈\n\n然而有一些栈顶的表达式并不自然，所以需要把运算符和运算数分别对待\nfloat evaluate(char* S,char* &amp; RPN)&#123;//中缀表达式求值    stack&lt;float&gt; opnd; stack&lt;char&gt; optr; //运算数栈，运算符栈    optr.push(&#x27;\\0&#x27;);    while(!optr.empty())    &#123; //逐个处理各字符，直至运算符栈空        if(isdigit(*S)) //若当前字符为操作数，则读入（可能多位的）操作数            readNumber(S,opne);        else //若当前字符为运算符，则视其与栈顶运算符之间优先级的高低            switch(orderBetween(optr.top(),*S))            &#123;/*分别处理*/&#125;    &#125;    return opnd.pop(); //弹出最后的计算结果&#125;\n\n不同优先级处理方法\nswitch(orderBetween(optr.top(),*S))&#123;    case &#x27;&lt;&#x27;: //栈顶运算符优先级更低        optr.push(*S);        S++;        break; //计算推迟，当前运算符进栈    case &#x27;=&#x27;: //优先级相等(当前运算符为右括号，或尾部哨兵&#x27;\\0&#x27;)        optr.pop();        S++;        break; //脱括号并接收下一个字符    case &#x27;&gt;&#x27;:        &#123; //栈顶运算符优先级更高，实施相应的计算，结果入栈            char op = optr.pop(); //栈顶运算符出栈，执行对应的运算            if(&#x27;!&#x27; == op) opnd.push(calc(op,opne.pop()); //一元运算符            else               &#123;                float pOpnd2 = opnd.pop(),pOpnd1 = opnd.pop(); //二元运算符                opnd.push(calcu(pOpnd1,op,pOpnd2)); //实施计算，结果入栈               &#125;                break;              &#125;        &#125;\n\n当前栈顶左括号，当前字符右括号，表明右括号之前的子表达式已都执行完毕，所以左括号弹出，字符指向下一个，末尾\\0同理\n逆波兰表达式（RPN）\n将表达式优先级转化为运算符在RPN表达式序列中出现的次序，谁先出现谁就优先计算\n手工转换\n转换后运算符的次序有可能颠倒改变，然而运算数却是不变的\n\n队列First in first out\n只能在队尾插入（查询）：enqueue（） + rear（）\n只能在队头插入（查询）：dequeue（） + front（）\n队列属于序列的特例，则可直接基于向量或列表派生\ntemplate&lt;typename T&gt; class Queue:public List&lt;T&gt;&#123;public:    void enqueue(T const &amp; e)&#123; insertAsLast(e);&#125; //尾部入队    T dequeue() &#123; return remove(first()); &#125; //首部出队    T &amp; front() &#123; return first()-&gt;data; &#125; //队首&#125;；\n\n如此实现的队列接口，均只需O(1)时间\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"绪论","url":"/2021/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/","content":"绪论计算计算是：\n\n研究对象：研究计算过程中所蕴含本质的内在规律，总结挖掘出其中的一般性的方法以及典型的技巧\n研究目的：实现高效，低耗的计算\n\n算法：即在特定计算模型下，旨在解决特定问题的指令序列\n程序！=算法\n有穷性：\n对于任何输入，经有穷次基本操作，都可以得到输出 \n好算法=正确+健壮+可读+效率（速度快，空间少）\n图灵机\n进行复位是为了在软件开发过程中相互合作的准则，即规范\nRAM模型\n一个算法好不好并不取决于CPU主频运行的快慢， 而取决于它本身需要执行多少次CPU的计算\n\n\n执行过程可以记录为一张表\n表的行数既是所执行基本指令的总条数\n能够客观度量算法的执行时间\n\n图灵机、RAM等模型为度量算法性能提供了准确的尺度\n渐进复杂度在考察DSA时应该更多看中它的长远（处理更大问题时的潜力如何），也不必过多的纠结于它的细微不足，应该更多的看到它的主要方面，主流\n大O记号从悲观的角度做分析\n\n长远，当n足够大；主流，忽略所有常系数与低次项这些非主流的因素，使得主流信息可以突出\n复杂度分析算法分析的两个主要任务=正确性（不变形x单调性）+复杂度\n复杂度分析的主要方法\n\n迭代：级数求和\n递归：递归跟踪+递归方程\n猜测+验证\n\n级数\n\n循环\n从渐进的阶次而言，二者是完全相等的，都是平方的量级\n起泡排序\n问题：该算法必然会结束？至多需迭代多少趟？\n不变形：经k轮扫描交换后，最大的k个元素必然就位\n单调性：经k轮扫描后交换后，问题规模缩减至n-k\n正确性：经至多n趟扫描后，算法必然会终止，且能给出正确的答案\n\n封底估算除了大O计算这种定性的定界方法，在很多时候需要准确的定量估算\n迭代与递归减而治之\n空间复杂度考量除了输入本身所占的空间之外，所需要的另加用于计算所必须的空间总量\n\n为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡，另一规模缩减\n递归跟踪：直观形象，仅适用于简明的递归模式\n\n递推方程：间接抽象，更适用于复杂的递归模式\n\n\n分而治之为求解一个大规模的问题，可以将其划分为若干子（通常两个）问题，规模大体相当\n\n\n动态规划fib的封底估算\n\nfib递归跟踪\n\nfib迭代\n\n解决方法（记忆）：将已计算过实例的结果制表备查\n解决方法（动态规划）：颠倒计算方法，由自顶而下递归，为自底而上迭代 \n\n公共子序列\n减而治之：将相同的末字符切掉，分成一个平凡的问题和一个小于1的相同规模问题\n\n分而治之：若末尾字符不相同，则大胆切除\n\n单调性：无论如何，每经过一次对比，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩短一个单位\n最好情况（不出现第2种情况）下，只需O（n+m）时间\n但问题在于，（在第2种情况）原问题将分解为两个子问题，更糟糕的是，它们在随后进一步导出的子问题，可能雷同\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"第五章 虚拟内存","url":"/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","content":"第五章 虚拟内存5.1 起因程序规模的增长远大于存储器容量发展的速度，让更多的程序跑在有限的内存里面\n使用硬盘/磁盘使更多的程序在有限的内存中运行\n理想的存储器：\n更大，更快，更便宜的非易失性存储器\n实际中的存储器：\n\n5.2 覆盖技术目标：是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用\n原理：\n\n把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行\n必要部分(常用功能)的代码和数据常驻内存\n可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存\n不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区\n\n\n\n\n\n缺点：\n由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度\n覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省\n\n\n\n5.3 交换技术如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中\n目标：\n\n多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源\n\n方法：\n\n可将暂时不能运行的程序送到外存, 从而获得空闲内存空间\n操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间\n\n交换技术实现中的几个问题：\n\n交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出\n交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取\n程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法\n\n覆盖与交换的比较\n\n覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构\n交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部\n\n5.4 虚存技术在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :\n\n覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担\n交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销\n\n目标：\n\n像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉\n像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换\n以更小的页粒度为单位装入更多更大的程序\n\n程序的局部性原理\n\n程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域\n时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内\n空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内\n\n\n\n程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果\n实例：\n页面大小为4k, 分配给每个进程的物理页面是1. 在一个进程中, 定义了如下的二维数组 int A[1024][1024]. 该数组按行存放在内存, 每一行放在一个页面中.考虑一下程序的编写方法对缺页率的影响?程序编写方法1 : (发生了1024*1024次缺页中断)for(j = 0; j &lt; 1024; j++)\t\tfor(i = 0; i &lt; 1024; i++)\t\t\t\tA[i][j] = 0;程序编写方法2 : (发生了1024次缺页中断)for(i = 0; i &lt; 1024; i++)\t\tfor(j = 0; j &lt; 1024; j++)\t\t\t\tA[i][j] = 0;\n\n基本概念\n可以在页式或段式内存管理的基础上实现\n\n在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行\n在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序\n另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段\n\n基本特征\n\n大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB\n部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的\n不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性\n\n页式内存管理页表 : 完成逻辑页到物理页帧的映射\n根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址\n虚拟页式内存管理\n\n大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能\n\n基本思路\n\n当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.\n在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行\n\n\n页表表项\n\n驻留位 : 表示该页是在内存中还是在外存\n保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等\n修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存\n访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法\n\n\n缺页中断处理过程\n\n如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步\n采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存\n对q所对应的页表项修改, 把驻留位置为0\n将需要访问的页p装入到物理页面f当中\n修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f\n重新运行被中断是指令\n\n\n\n在何处保存未被映射的页？\n\n能够简单地识别在二级存储器中的页\n交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面\n\n后备存储 backing store（二级存储）\n一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置\n代码段 : 映射到可执行二进制文件\n动态加载的共享库程序段 : 映射到动态调用的库文件\n其他段 : 可能被映射到交换文件(swap file)\n\n虚拟内存性能为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)\nEAT = 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率\n","categories":["操作系统"],"tags":["内存分配"]}]