[{"title":"Hello World","url":"/2022/01/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"text","url":"/2022/02/05/text/","content":"测试测试测试\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第三章 物理内存分配","url":"/2022/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter3%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第三章 物理内存分配3.1 计算机体系结构及内存分层体系计算机体系结构计算机组成原理\nCPU，内存，总线，I/O\n内存体系结构OS内存管理目标\n抽象（逻辑地址空间）：应用程序不需要考虑底层细节\n保护（独立地址空间）：内存中可以运行多个应用程序，多个程序可能访问别的程序的地址空间或者破坏其他程序\n共享（访问相同内存）：进程之间安全有效可靠的数据传递\n虚拟化（更多的地址空间）：当内存不够时，把最需要的数据放在内存中，暂时不需要访问的数据可以临时的放到硬盘上\n\nOS内存管理方法\n程序重定位\n分段\n分页\n虚拟内存\n按需分页虚拟内存\n\n实现高度依赖于硬件\n\nMMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求\n\n3.2 地址空间与地址生成地址空间物理地址空间——硬件支持的地址空间（起始0，MAX_sys）\n逻辑地址空间——一个运行的程序所拥有的的内存范围（0，MAX_prog）\n逻辑地址的生成\n\n物理地址的生成\n\n\n地址安全检查\n\n3.3 连续内存分配内存碎片内存碎片问题指的是空闲的内存无法被利用\n\n外部碎片：分配单元之间的未使用内存\n内部碎片 :  分配给应用程序的单元内的未使用内存\n\n分区的动态分配\n第一匹配分配：在内存中找到第一个比需求大的空闲块, 分配给应用程序\n\n\n\n\n分配方式\n第一匹配分配\n最优适配分配\n最差适配分配\n\n\n\n实现需求\n1. 按地址排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配最大的分区3. 重分配需要检查是否可以合并相邻空闲分区\n\n\n优势\n简单 / 易于产生更大空闲块\n比较简单 / 大部分分配是小尺寸时有效\n分配很快 / 大部分分配是中尺寸时高效\n\n\n劣势\n产生外部碎片 / 不确定性\n产生外部碎片 / 重分配慢 / 易产生很多没用的微小碎片\n产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配\n\n\n3.4 连续内存分配：压缩式与交换式碎片整理无论使用那种算法，都可能产生碎片，希望想有一些办法使得碎片减少甚至消失\n压缩式碎片整理\n重置程序以合并空洞\n要求所有程序是动态可充值的\n议题\n何时重置？\n开销\n\n\n\n\n通过拷贝完成（重定位）\n在运行的时候挪操作，地址会不对\n\n应在程序停止时进行\n\n开销很大，甚至可能影响整个系统的正常执行\n\n\n交换式碎片整理\n运行程序需要更多的内存\n抢占等待的程序&amp;回收他们的内存(把暂时不用的内容挪到磁盘里)\n议题：哪些程序应该被抢占以及什么时候执行\n\n\n操作系统内核特征\n\n并发：计算机系统中同时存在多个运行的程序，需要OS管理和调度\n共享：宏观上“同时访问”，微观上互斥共享\n虚拟：利用多到程序设计技术，让每个用户都觉得有一个计算机专门为他服务\n异步：程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，只要运行环境相同，OS需要保证程序运行的结果也要相同\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第四章 非连续内存分配","url":"/2022/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter4%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第四章 非连续内存分配\n为什么需要非连续内存分配\n\n连续内存分配的缺点\n\n分配给一个程序的物理内存是连续的\n内存利用率低\n有外碎片，内碎片的问题\n\n非连续内存分配的优点\n\n一个程序的物理地址是非连续的\n更好的内存利用和管理\n允许共享代码与数据（共享库等）\n支持动态加载和动态链接\n\n非连续分配缺点\n\n如何建立虚拟地址和物理地址之间的转换\n软件方案\n硬件方案（分段，分页）\n\n\n\n4.1 分段\n程序的分段地址空间，分段寻址方案\n\n计算机程序由各种段组成\n\n分段：更好的分离和共享\n\n\n\n左边连续的虚拟地址，右边不连续的物理地址，采用映射机制进行两边的关联\n\n分段寻址方案\n\n\n一个段：一个内存“块”\n\n\n程序访问内存需要：\n\n\n一个2维的二元组（s，addr）\ns—段号\naddr—段内偏移\n\n\n\n\n操作系统建立段表\n分页\n划分物理内存至固定大小的帧\n\n大小是2的幂，e.g.，512,4096,8192\n\n\n划分逻辑地址空间至相同大小的页\n\n大小同物理地址\n\n\n建立方案 转换逻辑地址为物理地址（pages to frames）\n\n页表\nMMU/TLB（加速地址的转换）\n\n\n\n帧（Frame）\n物理内存被分割为大小相等的帧\n\n一个内存物理地址是一个二元组（f，o）\n\nf—帧号（F位，共有2F个帧）\no—帧内偏移（S位，每帧有2S字节）\n物理地址=2S * f + o\n\n\n16-bit地址空间, 9-bit(512 byte) 大小的页帧\n\n物理地址=（3，6）\n物理地址=1542\n\n\n\n\n页（Page）\n一个程序的逻辑地址空间被划分为大小相等的页\n\n页内偏移的大小 = 帧内偏移的大小\n页号大小 &lt;&gt; 帧号大小\n\n\n一个逻辑地址是一个二元组(p, o) \n\np—页号（P位，2P个页）\no—页内偏移（S位，每页有2S字节）\n逻辑地址=2S * P + o\n\n\n\n页寻址机制\n\n操作系统建立页表\n\n逻辑地址空间应当大于物理内存空间\n页映射到帧\n页是连续的虚拟内存\n帧是非连续的物理内存(有助于减少碎片的产生)\n不是所有的页都有对应的帧\n\n4.3 页表-概述、TLB页表概述页表结构\n\n每一个运行的程序都有一个页表\n属于程序运行状态, 会动态变化\nPTBR : 页表基址寄存器\n\n\n\n地址转换\n\n分页机制的性能问题\n问题：访问一个内存单元需要2次内存访问\n\n一次用于获取页表项\n一次用于访问数据\n\n页表可能非常大\n\n64位机器如果每页1024字节, 那么一个页表的大小会是多少？(264 / 210 = 254 存放不下)\n每一个运行的程序都需要有一个页表\n\n如何处理\n\n缓存\n间接访问\n\nTranslation Look-aside Buffer（TLB）（解决速度上问题）CPU的MMU里面的一个缓冲，CPU中的快表\n缓存近期访问的页帧转换表项\n\nTLB使用associative memory（关联内存）实现, 具备快速访问性能\n如果TLB命中, 物理页号可以很快被获取\n如果TLB未命中, 对应的表项被更新到TLB中\n常用的表项放在TLB里面\nTLB的miss不会很大\n写程序时，写出的程序尽量具有访问的局部性，把平时的访问集中在一个区域里，有效较少TLB的缺失\nx86的CPU由硬件实现, 其他的可能是由操作系统实现\n\n4.4 页表-二级，多级页表二级页表（解决空间上问题）\n\n将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.\n一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号\n节约了一定的空间, 在一级页表中如果resident bit = 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留多级页表\n\n\n通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”\n\n4.5 页表-反向页表大地址空间问题\n\n有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表\n不是让页表与逻辑地址空间的大小相对应, 而是让页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间 \n\n基于页寄存器（page registers）的方案每一个帧和一个寄存器关联, 寄存器内容包括 :\n\nresident bit : 此帧是否被占用\noccupier : 对应的页号 p\nprotection bits : 保护位\n\n实例\n\n物理内存大小是 : 4096 * 4096 = 4K * 4KB = 16 MB\n页面大小是 : 4096 bytes = 4 KB\n页帧数 : 4096 = 4 K\n页寄存器使用的空间(假设8 bytes / register) : 8 * 4096 = 32 Kbytes\n页寄存器带来的额外开销 : 32K / 16M = 0.2%\n虚拟内存大小 : 任意\n\n优势\n\n转换表的大小相对于物理内存来说很小\n转换表的大小跟逻辑地址空间的大小无关\n\n劣势\n\n需要的信息对调了, 即根据帧号可以找到页号\n如何转换回来? (如何根据页号找到帧号)\n在需要在反向页表中搜索想要的页号\n\n基于关联内存(associative memory)的方案硬件逻辑复杂，容量不能做太大，还需要放到CPU里面\n\n如果帧数较少, 页寄存器可以被放置在关联内存中\n\n在关联内存中查找逻辑页号\n\n成功 : 帧号被提取\n失败 : 页错误异常 (page fault)\n\n\n限制因素：\n\n大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)\n\n\n\n基于哈希(hash)的方案哈希表，哈希函数 : h(PID, p) 从 PID 标号获得页号\n在反向页表中通过哈希算法来搜索一个页对应的帧号\n\n对页号做哈希计算, 为了在帧表中获取对应的帧号\n页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数\n为了查找页 i , 执行下列操作 :\n计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器\n检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败\n\n\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第五章 虚拟内存","url":"/2021/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","content":"第五章 虚拟内存5.1 起因程序规模的增长远大于存储器容量发展的速度，让更多的程序跑在有限的内存里面\n使用硬盘/磁盘使更多的程序在有限的内存中运行\n理想的存储器：\n更大，更快，更便宜的非易失性存储器\n实际中的存储器：\n\n5.2 覆盖技术目标：是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用\n原理：\n\n把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行\n必要部分(常用功能)的代码和数据常驻内存\n可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存\n不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区\n\n\n\n\n\n缺点：\n由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度\n覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省\n\n\n\n5.3 交换技术如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中\n目标：\n\n多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源\n\n方法：\n\n可将暂时不能运行的程序送到外存, 从而获得空闲内存空间\n操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间\n\n交换技术实现中的几个问题：\n\n交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出\n交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取\n程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法\n\n覆盖与交换的比较\n\n覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构\n交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部\n\n5.4 虚存技术在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :\n\n覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担\n交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销\n\n目标：\n\n像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉\n像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换\n以更小的页粒度为单位装入更多更大的程序\n\n程序的局部性原理\n\n程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域\n时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内\n空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内\n\n\n\n程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果\n实例：\n页面大小为4k, 分配给每个进程的物理页面是1. 在一个进程中, 定义了如下的二维数组 int A[1024][1024]. 该数组按行存放在内存, 每一行放在一个页面中.考虑一下程序的编写方法对缺页率的影响?程序编写方法1 : (发生了1024*1024次缺页中断)for(j = 0; j &lt; 1024; j++)\t\tfor(i = 0; i &lt; 1024; i++)\t\t\t\tA[i][j] = 0;程序编写方法2 : (发生了1024次缺页中断)for(i = 0; i &lt; 1024; i++)\t\tfor(j = 0; j &lt; 1024; j++)\t\t\t\tA[i][j] = 0;\n\n基本概念\n可以在页式或段式内存管理的基础上实现\n\n在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行\n在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序\n另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段\n\n基本特征\n\n大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB\n部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的\n不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性\n\n页式内存管理页表 : 完成逻辑页到物理页帧的映射\n根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址\n虚拟页式内存管理\n\n大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能\n\n基本思路\n\n当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.\n在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行\n\n\n页表表项\n\n驻留位 : 表示该页是在内存中还是在外存\n保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等\n修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存\n访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法\n\n\n缺页中断处理过程\n\n如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步\n采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存\n对q所对应的页表项修改, 把驻留位置为0\n将需要访问的页p装入到物理页面f当中\n修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f\n重新运行被中断是指令\n\n\n\n在何处保存未被映射的页？\n\n能够简单地识别在二级存储器中的页\n交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面\n\n后备存储 backing store（二级存储）\n一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置\n代码段 : 映射到可执行二进制文件\n动态加载的共享库程序段 : 映射到动态调用的库文件\n其他段 : 可能被映射到交换文件(swap file)\n\n虚拟内存性能为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)\nEAT = 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"向量","url":"/2021/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F/","content":"向量抽象数据类型=数据模型+定义在该模型上的一组操作\n数据结构 =基于某种特定语言，实现ADT的一整套算法\n向量ADT向量是数组的抽象与泛化，由一组元素按线性次序封装而成\n各元素与[0，n）内的秩（rank）一一对应（循秩访问）\n元素的类型不限于基本类型\n操作、管理维护更加简化、统一安全\n可更为便捷地参与复杂数据结构的定制与实现\n\n构造与析构http://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/vector/vector.h.htm\nusing Rank = int; //秩#define DEFAULT_CAPACITY  3 //默认的初始容量（实际应用中可设置为更大）template &lt;typename T&gt; class Vector &#123; //向量模板类protected:Rank _size; Rank _capacity;  T* _elem; //规模、容量、数据区void copyFrom ( T const* A, Rank lo, Rank hi ); //复制数组区间A[lo, hi)void expand(); //空间不足时扩容void shrink(); //装填因子过小时压缩bool bubble ( Rank lo, Rank hi ); //扫描交换void bubbleSort ( Rank lo, Rank hi ); //起泡排序算法Rank maxItem ( Rank lo, Rank hi ); //选取最大元素void selectionSort ( Rank lo, Rank hi ); //选择排序算法void merge ( Rank lo, Rank mi, Rank hi ); //归并算法void mergeSort ( Rank lo, Rank hi ); //归并排序算法void heapSort ( Rank lo, Rank hi ); //堆排序（稍后结合完全堆讲解）Rank partition ( Rank lo, Rank hi ); //轴点构造算法void quickSort ( Rank lo, Rank hi ); //快速排序算法void shellSort ( Rank lo, Rank hi ); //希尔排序算法public:// 构造函数Vector ( int c = DEFAULT_CAPACITY, Rank s = 0, T v = 0 ) //容量为c、规模为s、所有元素初始为v&#123; _elem = new T[_capacity = c]; for ( _size = 0; _size &lt; s; _elem[_size++] = v ); &#125; //s&lt;=cVector ( T const* A, Rank n ) &#123; copyFrom ( A, 0, n ); &#125; //数组整体复制Vector ( T const* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; //区间Vector ( Vector&lt;T&gt; const&amp; V ) &#123; copyFrom ( V._elem, 0, V._size ); &#125; //向量整体复制Vector ( Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; //区间// 析构函数~Vector() &#123; delete [] _elem; &#125; //释放内部空间// 只读访问接口Rank size() const &#123; return _size; &#125; //规模bool empty() const &#123; return !_size; &#125; //判空Rank find ( T const&amp; e ) const &#123; return find ( e, 0, _size ); &#125; //无序向量整体查找Rank find ( T const&amp; e, Rank lo, Rank hi ) const; //无序向量区间查找Rank search ( T const&amp; e ) const //有序向量整体查找&#123; return ( 0 &gt;= _size ) ? -1 : search ( e, 0, _size ); &#125;Rank search ( T const&amp; e, Rank lo, Rank hi ) const; //有序向量区间查找// 可写访问接口T&amp; operator[] ( Rank r ); //重载下标操作符，可以类似于数组形式引用各元素const T&amp; operator[] ( Rank r ) const; //仅限于做右值的重载版本Vector&lt;T&gt; &amp; operator= ( Vector&lt;T&gt; const&amp; ); //重载赋值操作符，以便直接克隆向量T remove ( Rank r ); //删除秩为r的元素int remove ( Rank lo, Rank hi ); //删除秩在区间[lo, hi)之内的元素Rank insert ( Rank r, T const&amp; e ); //插入元素Rank insert ( T const&amp; e ) &#123; return insert ( _size, e ); &#125; //默认作为末元素插入void sort ( Rank lo, Rank hi ); //对[lo, hi)排序void sort() &#123; sort ( 0, _size ); &#125; //整体排序void unsort ( Rank lo, Rank hi ); //对[lo, hi)置乱void unsort() &#123; unsort ( 0, _size ); &#125; //整体置乱Rank deduplicate(); //无序去重Rank uniquify(); //有序去重// 遍历void traverse ( void (* ) ( T&amp; ) ); //遍历（使用函数指针，只读或局部性修改）template &lt;typename VST&gt; void traverse ( VST&amp; ); //遍历（使用函数对象，可全局性修改）&#125;; //Vector\n\n原理：\n\n向量的复制\ntemplate&lt;typename T&gt; //T为基本类型，或已重载赋值操作符&#x27;=&#x27;void vector&lt;T&gt;::copyFrom(T* const A,Rank lo,Rank hi)&#123;    _elem = new T[_capacity = 2*(hi-lo)]; //分配空间,预留出足够的空间，在接下去足够长的时间内，不必因为有必要的扩容而打断计算过程    _size = 0; //规模清零    while(lo&lt;hi) //A[lo,hi)内的元素逐一        _elem[size++] = A[lo++]; // 复制至_elem[0,hi-lo)&#125;\n\n\n可扩充向量若采用静态空间管理策略，容量_capacity固定，则有明显的不足\n\n上溢（overflow）：_elem[]不足以存放所有元素\n尽管此时系统仍有足够的空间\n\n下溢（underflow）：_elem[]中的元素寥寥无几\n装填因子（load factor）size/capacity &lt;&lt; 50% \n\n\n更糟糕的是，一般的应用环境中难以准确预测空间的需求量\n可否使得向量可随实际需求动态调整容量，并同事保证高效率？\n动态空间管理在即将发生上溢时，适当的扩大内部数组的容量\n\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::expand()&#123;\t//向量空间不足时扩容    if(_size&lt;_capacity)return; //尚未满员，不必扩容    _capacity = max(_capacity,DEFAULT_CAPACITY); //不低于最小容量    T* oldElem = _elem;    _elem = new T[_capacity &lt;&lt;= 1]; //容量加倍    for(int i = 0;i &lt; _size; i++) //复制原向量内容        _elem[i] = oldElem[i]; //T为基本类型，或已重载赋值操作符&#x27;=&#x27;    delete[]oldElem; //释放原空间&#125;\n\n得益于向量的封装，尽管扩容之后的数据区的物理地址有所改变，却不致出现野指针\n递增式扩容T* oldElem = _elem; _elem = new T[_capacity += INCREMENT];//追加固定大小的容量\n\n最坏情况：在初始容量0的空向量中，连续插入n=m*I &gt;&gt; 2个元素…\n每一次的扩容与复制都会使得时间成本过多\n加倍式扩容T* oldElem = _elem; _elem = new T[_capacity &lt;&lt;= 1];//容量加倍\n\n在最坏去情况下，在初始容量为1的满向量中，连续插入n=2^m &gt;&gt; 2个元素\n各次扩容过程中复制原向量的时间成本依次为\n1,2,4,8，。。。，2^m = n  //几何级数\n总体耗时=O(n)，每次扩容的分摊成本为O(1)\n\n分摊复杂度平均复杂度或期望复杂度( average/expected complexity )\n\n根据数据结构各种操作出现概率的分布，将对应的成本加权平均\n\n各种可能的操作，作为独立事件分别考查\n\n割裂了操作之间的相关性和连贯性\n\n往往不能准确地评判数据结构和算法的真实性能\n\n\n分摊复杂度( amortized complexity )\n\n对数据结构连续地实施足够多次操作,所需总体成本分摊至单次操作\n从实际可行的角度,对一系列操作做整体的考量\n更加忠实地刻画了可能出现的操作序列\n可以更为精准地评判数据结构和算法的真实性能\n\n无序向量循秩访问从便捷性出发，实现和数组元素访问方式一样的：A[r]\n因此，重载下标操作符“[]”\ntemplate&lt;typename T&gt; //0 &lt;= r &lt; _sizeT &amp; vector&lt;T&gt;::operator[](Rank r) const &#123; return _elem[r]; &#125;\n\n右值：T x = v[r] + U[s] * W[t];\n左值：v[r] = (T)(2*X+3); //因为是引用的方式，所以可以为左值\n插入因为所有的向量元素都是紧邻排序的，所以为了能够插入新的元素，就必须将新元素的后缀元素整体右移\ntemplate&lt;typename T&gt; //e作为秩为r元素插入，0&lt;=r&lt;=sizeRank vector&lt;T&gt;::insert(Rank r,T const &amp; e)&#123;//O(n-r)    expand(); //若有必要，扩容    for(int i = _size;i &gt; r;i--) //自后向前，如果次序颠倒，则有可能出现数据被覆盖的危险        _elem[i] = _elem[i-1]; //后继元素顺次后移一个单元    _elem[r] = e; _size++; //置入新元素，更新容量    return r; //返回秩&#125;\n\n\n删除删除后，后缀统一左移，自前向后的前移操作，若顺序颠倒，可能出现危险\ntemplate&lt;typename T&gt; //删除区间[lo,hi),0&lt;=lo&lt;=hi&lt;=sizeint vector&lt;T&gt;::remove(Rank lo,Rank hi)&#123;//O(n-hi)    if(lo==hi) return 0; //出于效率考虑，单独处理退化情况    while(hi&lt;_size)        _elem[lo++] = _elem[hi++]; //[hi,_size)顺次前移hi-lo位    _size = lo; shrink(); //更新规模，若有必要缩容    return hi-lo;&#125;\n\n\n单元素删除可以视作区间删除操作的特例：[r] = [r,r+1)\n template&lt;typename T&gt; //删除向量中秩为r的元素，0&lt;=r&lt;sizeT vector&lt;T&gt;::remove(Rank r)&#123; //O(n-r)    T e = _elem[r]; //备份被删除的元素    remove(r,r+1); //调用区间删除算法    return e; //返回被删除元素&#125;\n\n查找template&lt;typename T&gt; //0&lt;=lo&lt;hi&lt;=_sizeRank vector&lt;T&gt;::find(T const &amp; e,Rank lo,Rank hi)const&#123;//O(hi-lo)=O(n),在命中多个元素时可返回秩最大者   while((lo &lt; hi--)&amp;&amp;(e != _elem[hi])); //逆向查找    return hi; //hi&lt;lo意味着失败；否则hi即命中元素的秩&#125;\n\n输入敏感算法：最好O(1)，最差O(n)\n去重/唯一化应用实例：网络搜索的局部结果经过去重操作，汇总为最终报告\ntemplate &lt;typename T&gt; //删除重复元素，返回被删除元素数目int Vector&lt;T&gt;::deduplicate() &#123; //繁琐版+错误版   int oldSize = _size; //记录原规模   Rank i = 1; //从_elem[1]开始   while (i &lt; _size) //自前向后逐一考查各元素_elem[i]      if (find(_elem[i], 0, i) &lt; 0) //在前缀中寻找与之雷同者（至多一个）         i++; //若无雷同则继续考查其后继      else         remove(i); //否则删除当前元素（至多一个？）   return oldSize - _size; //被删除元素总数&#125;\n\n正确性：\n不变性：在当前元素 v[i] 的前缀 v[0,i] 中，各元素彼此互异\n单调性：随着反复的while迭代\n\n当前元素前缀的长度单调非降，且迟早增至_size \n当前元素后缀的长度单调下降，且迟早减至0\n\n故算法必然终止，且至多迭代O(n)轮\n\n复杂度：\n每轮迭代中 find() 和 remove() 累计耗费线性时间，故总体为O(n^2)\n遍历遍历向量，统一对各元素分别实施visit操作\n利用函数指针实例，只读或局部性修改\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::traverse(void (*visit)(T&amp;)) //函数指针&#123;    for (int i = 0;i &lt; _size;i++)        visit(_elem[i]);&#125;\n\n利用函数对象机制，可全局性修改\ntemplate&lt;typename T&gt; template&lt;typename VST&gt;void vector&lt;T&gt;::traverse(VST&amp; visit) //函数对象&#123;    for (int i = 0;i &lt; _size;i++)        visit(_elem[i]);&#125;\n\n有序向量如何甄别一个向量是否有序\n有序/无序序列中，任意/总有一对相邻元素顺序/逆序\n因此，相邻逆序对的数目，可用以度量向量的逆序程度\ntemplate&lt;typename T&gt; //返回逆序相邻元素对的总数int vector&lt;T&gt;::disordered()const&#123;    int n = 0; //计数器    for(int i = 1;i &lt; _size;i++) //逐一检查各队相邻元素        n += (_elem[i - 1] &gt; _elem[i]); //逆序则计数    return n; //向量有序当且仅当 n = 0&#125; //若只判断是否有序，则首次遇到逆序对之后，即可立即终止\n\n唯一化低效版观察：在有序向量中，重复的元素必要相互紧邻构成一个区间，每一个区间只需保留单个元素即可\ntemplate&lt;typename T&gt;int vector&lt;T&gt;::uniquify()&#123;    int oldSize = _size;    int i = 0; //从首元素开始    while(i &lt; _size-1) //从前向后，逐一比对各对相邻元素，若雷同，则删除后者；否则，转至后一元素        (_elem[i] == _elem[i+1])?remove(i+1):i++;    return oldSize - _size; //向量规模变化量，即删除元素总数&#125; //注意：其中_size的减少，由remove()隐式地完成\n\n运行时间主要取决于while循环，次数共计： _size-1 = n-1\n最坏情况下：每次都需调用remove()，耗时O(n-1)~O(1)；累计O(n^2) \n\n高效版如果能够将每一个区间作为一个整体，成批的删除雷同元素，则有可能实现一步到位式移动\ntemplate&lt;typename T&gt;int vector&lt;T&gt;::uniquify()&#123;    Rank i = 0,j = 0; //各对互异“相邻”元素的秩    while(++j &lt; _size) //逐一扫描，直至末元素        //跳过雷同；发现不同元素时，向前移至紧邻于前者右侧        if(_elem[i] != _elem[j])            _elem[++i] = _elem[j];    _size = ++i;     shrink(); //直接删除尾部多余元素    return j - i; //向量规模变化量，即被删除元素总数&#125; //注意：通过remove(lo,hi)批量删除，依然不能达到高效率\n\n共计n-1次迭代，每次常数时间，累计O(n)时间\n\n二分查找（A)语义约定至少应该便于有序向量自身的维护：v.insert ( 1 + v.search(e) , e )\n即便失败，也应给出新元素适当的插入位置\n若允许重复元素，则每一组也需按其插入的次序排列\n\n约定：在有序向量区间v[lo , hi) 中，确定不大于e的最后一个元素秩\n若-无穷 &lt; e &lt; v[lo]，则返回lo - 1（左侧哨兵）\n若 v[hi-1] &lt; e &lt; +无穷，则返回 hi-1（末元素=右侧哨兵左邻）\n原理\n二分（折半）策略：轴点mi总是取作中点——于是\n每经过至多两次比较，或者能够命中，或者将问题规模缩减一半\n实现template&lt;typename T&gt; //在有序向量区间[lo,hi)内查找元素estatic Rank binSearch(T* A,T const&amp; e,Rank lo,Rank hi)&#123;    while(lo &lt; hi)    &#123;\tRank mi = (lo + hi)&gt;&gt;1; //以中点为轴点     \tif(e &lt; A[mi]) hi = mi; //目标处于e的左侧，深入前半段[lo,mi)继续查找    \telse if(A[mi] &lt; e) lo = mi + 1; //目标\t处于e的右侧，深入后半段(mi,hi)     \telse return mi; //在mi处命中    &#125;    return -1; //查找失败&#125;\n\n\n\nFib查找\n二分查找版本A的效率仍有改进余地，因为不难发现转向左、右分支前的关键吗比较次数不等，而递归深度却相同\n若能通过递归深度的不均衡，来转向成本的不均衡进行补偿，平均查找长度应能进一步缩短\n\n\ntemplate&lt;typename T&gt; //0 &lt;= lo &lt;=hi &lt;= _sizestatic Rank fibsearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    Fib fib(hi-lo);    while(lo &lt; hi)    &#123;        while(hi - lo &lt; fib.get())            fib.prev(); //至多迭代几次？        //通过向前顺序查找，确定形如fib(k) - 1的轴点(分摊O(1))        Rank mi = lo + fib.get() - 1; //按黄金比例切分        if(e &lt; A[mi]) hi = mi; //深入前半段[lo,mi)继续查找        else if (A[mi] &lt; e)lo = mi + 1; //深入后半段(mi,hi)        else return mi; //在mi处命中    &#125;    return -1; //查找失败&#125;\n\n二分查找(B)每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个\n\n\n以上二分查找及Fibnacci查找算法\n均为严格地兑现search（）接口的语义约定：返回不大于e的最后一个元素\n\n只有兑现这一约定，才可有效支持相关算法，比如：v.insert（1+v.search（e），e）\n\n只有多个命中元素时，必须返回最靠后（秩最大）者\n失败时，应返回小于e的最大者（含哨兵[lo-1]）\n\n\n\ntemplate&lt;typename T&gt;static Rank binSearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    while(1 &lt; hi - lo)    &#123;//有效查找区间的宽度缩短至1时，算法才会终止        Rank mi = (lo + hi) &gt;&gt; 1; //以中点为轴点，经比较后确定深入        （e &lt; A[mi]) ? hi = mi : lo = mi; //[lo,mi)或[mi,hi)    &#125; //出口时hi = lo + 1,查找区间仅含一个元素A[lo]    return (e == A[lo]) ? lo : -1; //返回命中元素的秩或者-1&#125; //相较于版本A，最好（坏）情况下更坏（好）；各种情况下的SL更加接近，整体性能更趋稳定\n\n\n二分查找（C）template&lt;typename T&gt;static Rank binSearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    while(hi &lt; lo)    &#123;//不变性：A[0,lo) &lt;= e &lt; A[hi,n]        Rank mi = (lo + hi) &gt;&gt; 1; //以中点为轴点，经比较后确定深入        （e &lt; A[mi]) ? hi = mi : lo = mi + 1; //[lo,mi)或（mi,hi)    &#125; //出口时,A[lo = hi]为大于e的最小元素    return --lo; //故lo - 1即不大于e的元素的最大秩&#125;\n\n与版本B的差异\n\n待查找区间宽度缩短至0而非1时，算法才结束\n转入右侧子向量时，左边界取作mi+1而非mi\n无论成功与否，返回的秩严格符合接口的语义约定\n\n\n插值排序假设已知有序向量中各元素随机分布的规律，比如均匀且独立的随机分布\n那么[lo，hi）内各元素应大致按照线性趋势增长\n因此通过猜测轴点mi，可以极大提高收敛速度\n\n最坏情况：可能退化为平凡的顺序查找  O（hi - lo） = O（n）\n平均情况：每经一次比较，n缩至根号n\n\n\n易受小扰动的干扰和“蒙骗”\n\n须引入乘法、除法运算\n\n实际可行的方法\n首先通过插值查找，将查找范围缩小到一定的范围，然后再进行二分查找\n\n\n大规模：插值查找\n中规模：折半查找\n小规模：顺序查找\n起泡排序向量若有序排列，计算效率将大大提升\n如何实现向量的有序化？（排序算法）\n统一接口 sort（Rank lo，Rank hi）\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while(!bubble(lo,hi--)); &#125; //逐趟做扫描交换，直至全序\n\n不变性：每经过对bubble的调用，都会有一个新的元素就位（减而治之），有序的部分逐渐拓展，无序的部分逐渐缩减\n\n改进：绿色的部分未必都是无序的，有可能存在一部分或者所有绿色都是有序的\n如何尽早判定这种情况？\n每一趟扫描交换，都记录下是否存在逆序元素，若存在，当且仅当做过交换\n反例\n实质需要排序的元素集中在一个宽度仅为根号n的区间中\n \n多余出来的消耗就是在后缀中已就位元素的扫描交换\n记录在上一趟扫描交换中所进行的最后一趟交换，就可以知道上一趟有多长的后缀没有进行扫描交换，如果这样，只需将右侧标志hi指向新的位置\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while(lo &lt; (hi = bubble(lo,hi))); &#125; //逐趟做扫描交换，直至全序template&lt;typname T&gt;Rank vector&lt;T&gt;::bubble(Rank lo,Rank hi)&#123;    Rank last = lo; //最右侧的逆序对初始化为[lo - 1,lo]    while(++lo &lt; hi) //自左向右，逐一检查各队相邻元素        if(_elem[lo - 1] &gt; _elem[lo])        &#123;//若逆序，则更新最右侧逆序对位置记录，并交换         \tlast = lo;            swap(_elem[lo - 1],_elem[lo]);        &#125;    return last; //返回最右侧的逆序对位置&#125; \t\n\n归并排序\n序列一分为二，子序列递归排序，合并有序子序列\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::mergeSort(Rank lo,Rank hi)&#123;    if(hi - lo &lt; 2) return; //单元素区间自然有序    int mi = (lo + hi) &gt;&gt; 1; //以中点为界    mergeSort(lo,mi); //对前半段排序    mergeSort(mi,hi); //对后半段排序    merge(lo,mi,hi); //归并&#125;\n\n二路归并\n\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::merge(Rank lo,Rank mi,Rank hi)&#123;    T*A = _elem + lo; //合并后的向量A[0,hi - lo) = _elem[lo,hi)    int 1b = mi - lo;    T*B = new T[1b]; //前子向量B[0,1b) = _elem[lo,mi)    for(Rank i = 0;i &lt; 1b;B[i] = A[i++]); //复制前子向量B    int 1c = hi - mi;    T*C = _elem + mi; //后子向量C[0,1c) = _elem[mi,hi)    for(Rank i = 0,j = 0, k = 0;(j &lt; 1b) || (k &lt; 1c);)    &#123;//B[j]和C[k]中小者转至A的末尾        if((j &lt; 1b) &amp;&amp; (1c &lt;=k || (B[j] &lt;= C[k])))             A[i++] = B[j++]; //C[k]已无或不小        if((k &lt; 1c) &amp;&amp; (1b &lt;= j || (C[k] &lt; B[j])))            A[i++] = C[j++]; //B[j]已无或更大    &#125; //该循环实现紧凑；但就效率而言，不如拆分处理    delete[] B; &#125;\n\n\n\n\n一般B提前耗尽，就可终止算法\n复杂度\n算法的运行时间主要消耗与for循环，共有两个控制变量\n\n初始：j = 0，k = 0\n最终：j = lb，k = lc\n亦即：j + k = lb + lc = hi - lo = n\n\n每经过一次迭代，j和k中至少有一个会加一（j+k也必至少加一）\n故知：merge()总体迭代不过O(n)次，累计只需线性时间\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"绪论","url":"/2021/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/","content":"绪论计算计算是：\n\n研究对象：研究计算过程中所蕴含本质的内在规律，总结挖掘出其中的一般性的方法以及典型的技巧\n研究目的：实现高效，低耗的计算\n\n算法：即在特定计算模型下，旨在解决特定问题的指令序列\n程序！=算法\n有穷性：\n对于任何输入，经有穷次基本操作，都可以得到输出 \n好算法=正确+健壮+可读+效率（速度快，空间少）\n图灵机\n进行复位是为了在软件开发过程中相互合作的准则，即规范\nRAM模型\n一个算法好不好并不取决于CPU主频运行的快慢， 而取决于它本身需要执行多少次CPU的计算\n\n\n执行过程可以记录为一张表\n表的行数既是所执行基本指令的总条数\n能够客观度量算法的执行时间\n\n图灵机、RAM等模型为度量算法性能提供了准确的尺度\n渐进复杂度在考察DSA时应该更多看中它的长远（处理更大问题时的潜力如何），也不必过多的纠结于它的细微不足，应该更多的看到它的主要方面，主流\n大O记号从悲观的角度做分析\n\n长远，当n足够大；主流，忽略所有常系数与低次项这些非主流的因素，使得主流信息可以突出\n复杂度分析算法分析的两个主要任务=正确性（不变形x单调性）+复杂度\n复杂度分析的主要方法\n\n迭代：级数求和\n递归：递归跟踪+递归方程\n猜测+验证\n\n级数\n\n循环\n从渐进的阶次而言，二者是完全相等的，都是平方的量级\n起泡排序\n问题：该算法必然会结束？至多需迭代多少趟？\n不变形：经k轮扫描交换后，最大的k个元素必然就位\n单调性：经k轮扫描后交换后，问题规模缩减至n-k\n正确性：经至多n趟扫描后，算法必然会终止，且能给出正确的答案\n\n封底估算除了大O计算这种定性的定界方法，在很多时候需要准确的定量估算\n迭代与递归减而治之\n空间复杂度考量除了输入本身所占的空间之外，所需要的另加用于计算所必须的空间总量\n\n为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡，另一规模缩减\n递归跟踪：直观形象，仅适用于简明的递归模式\n\n递推方程：间接抽象，更适用于复杂的递归模式\n\n\n分而治之为求解一个大规模的问题，可以将其划分为若干子（通常两个）问题，规模大体相当\n\n\n动态规划fib的封底估算\n\nfib递归跟踪\n\nfib迭代\n\n解决方法（记忆）：将已计算过实例的结果制表备查\n解决方法（动态规划）：颠倒计算方法，由自顶而下递归，为自底而上迭代 \n\n公共子序列\n减而治之：将相同的末字符切掉，分成一个平凡的问题和一个小于1的相同规模问题\n\n分而治之：若末尾字符不相同，则大胆切除\n\n单调性：无论如何，每经过一次对比，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩短一个单位\n最好情况（不出现第2种情况）下，只需O（n+m）时间\n但问题在于，（在第2种情况）原问题将分解为两个子问题，更糟糕的是，它们在随后进一步导出的子问题，可能雷同\n","categories":["数据结构"],"tags":["数据结构与算法"]}]