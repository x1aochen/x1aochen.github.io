[{"title":"text","url":"/2022/02/05/text/","content":"测试测试测试\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"Hello World","url":"/2022/01/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"第三章 物理内存分配","url":"/2021/11/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter3%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第三章 物理内存分配3.1 计算机体系结构及内存分层体系计算机体系结构计算机组成原理\nCPU，内存，总线，I/O\n内存体系结构OS内存管理目标\n抽象（逻辑地址空间）：应用程序不需要考虑底层细节\n保护（独立地址空间）：内存中可以运行多个应用程序，多个程序可能访问别的程序的地址空间或者破坏其他程序\n共享（访问相同内存）：进程之间安全有效可靠的数据传递\n虚拟化（更多的地址空间）：当内存不够时，把最需要的数据放在内存中，暂时不需要访问的数据可以临时的放到硬盘上\n\nOS内存管理方法\n程序重定位\n分段\n分页\n虚拟内存\n按需分页虚拟内存\n\n实现高度依赖于硬件\n\nMMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求\n\n3.2 地址空间与地址生成地址空间物理地址空间——硬件支持的地址空间（起始0，MAX_sys）\n逻辑地址空间——一个运行的程序所拥有的的内存范围（0，MAX_prog）\n逻辑地址的生成\n\n物理地址的生成\n\n\n地址安全检查\n\n3.3 连续内存分配内存碎片内存碎片问题指的是空闲的内存无法被利用\n\n外部碎片：分配单元之间的未使用内存\n内部碎片 :  分配给应用程序的单元内的未使用内存\n\n分区的动态分配\n第一匹配分配：在内存中找到第一个比需求大的空闲块, 分配给应用程序\n\n\n\n\n分配方式\n第一匹配分配\n最优适配分配\n最差适配分配\n\n\n\n实现需求\n1. 按地址排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配最大的分区3. 重分配需要检查是否可以合并相邻空闲分区\n\n\n优势\n简单 / 易于产生更大空闲块\n比较简单 / 大部分分配是小尺寸时有效\n分配很快 / 大部分分配是中尺寸时高效\n\n\n劣势\n产生外部碎片 / 不确定性\n产生外部碎片 / 重分配慢 / 易产生很多没用的微小碎片\n产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配\n\n\n3.4 连续内存分配：压缩式与交换式碎片整理无论使用那种算法，都可能产生碎片，希望想有一些办法使得碎片减少甚至消失\n压缩式碎片整理\n重置程序以合并空洞\n要求所有程序是动态可充值的\n议题\n何时重置？\n开销\n\n\n\n\n通过拷贝完成（重定位）\n在运行的时候挪操作，地址会不对\n\n应在程序停止时进行\n\n开销很大，甚至可能影响整个系统的正常执行\n\n\n交换式碎片整理\n运行程序需要更多的内存\n抢占等待的程序&amp;回收他们的内存(把暂时不用的内容挪到磁盘里)\n议题：哪些程序应该被抢占以及什么时候执行\n\n\n操作系统内核特征\n\n并发：计算机系统中同时存在多个运行的程序，需要OS管理和调度\n共享：宏观上“同时访问”，微观上互斥共享\n虚拟：利用多到程序设计技术，让每个用户都觉得有一个计算机专门为他服务\n异步：程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，只要运行环境相同，OS需要保证程序运行的结果也要相同\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"栈与队列","url":"/2021/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","content":"栈与队列last in first out\n\n栈既然属于序列的特例，故可直接基于向量或列表派生\ntemplate&lt;typename T&gt; class Stack:public vector&lt;T&gt;&#123; //由向量派生public: //size()、empty()以及其他开放接口均可直接沿用    void push(T const &amp; e)&#123; insert(size(),e);&#125; //入栈    T pop()&#123; return remove(size() - 1);&#125; //出栈    T &amp; top()&#123; return (*this)[size() - 1];&#125; //取顶&#125;; //以向量首/末端为栈底/顶——颠倒过来呢？每一次操作都会涉及到向量中的所有元素\n\n进制转换在计算过程中，没得到一个数位就通过push压入栈中\n\nvoid convert(stack&lt;char&gt; &amp; s,int64 n,int base)&#123;    static char digit[] = //新进制下的数位符号，可视base取值范围适当扩充    &#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;    while(n &gt; 0)    &#123; //由低到高，逐一计算出新进制下的各数位        s.push(digit[n % base]); //余数（对应的数位）入栈        n /= base; //更新为其对base的除商    &#125;&#125;\n\nmain()&#123;    stack&lt;char&gt; S;    convert(s,n,base); //用栈记录转换得到的各数位    while( !S.empty())         printf( &quot;%c&quot;,S.pop()); //逆序输出&#125;\n\n括号匹配\n\n平凡：无括号的表达式是匹配的\n\n\nbool paren(const char exp[],int lo,int hi)&#123; //exp[lo,hi)    stack&lt;char&gt; S; //使用栈记录已发现但尚未匹配的左括号    for(int i = 0;i &lt; hi;i++) //逐一检查当前字符        if(&#x27;(&#x27; == exp[i]) S.push(exp[i]);//遇左括号：则进栈    \telse if( !S.empty()) S.pop(); //遇右括号；若栈非空，则弹出左括号    \telse return false; //否则（遇有括号时栈已空），必不匹配    return S.empty(); //最终，栈空当且仅当匹配&#125;\n\n\n之所以不采用计数器方式是，无法用于多种括号并存情况，栈只需约定“括号”的通用格式，而不必事先固定括号的类型与数目\n栈混洗\n通过中转栈S，将A的元素转入B中\nS.push(A.pop())B.push(S.pop())\n\n\n\n甄别\n\n对于任何1&lt;=j&lt;k&lt;=n，[…,k…,i,…,j,…&gt; 必非栈混洗\nO（n）算法：直接借助栈A、B和S，模拟混洗过程\n​                        每次S.pop()之前，检测S是否已空；或需弹出的元素在S中，却非顶元素\n\n合法的栈混洗序列与合法的括号匹配表达式之间存在着一一对应的关系，n个元素的栈混洗有多少种，n对括号所能构成的合法表达式也就有多少种\n中缀表达式求值典型应用场合\n逆序输出：输出次序与处理过程颠倒；递归深度和输出长度不易预知\n递归嵌套：具有相似性的问题可递归描述，但分支位置和嵌套深度不固定\n延迟缓冲：线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀\n栈式计算：基于栈结构的特定计算模式\n\n在面对比较长的表达式时，很难定位当前可以计算的运算符，如果以线性扫描的次序处理表达式，计算的次序未必与扫描的次序完全一致\n可以利用栈结构，所有扫描过的部分保存为栈\n\n然而有一些栈顶的表达式并不自然，所以需要把运算符和运算数分别对待\nfloat evaluate(char* S,char* &amp; RPN)&#123;//中缀表达式求值    stack&lt;float&gt; opnd; stack&lt;char&gt; optr; //运算数栈，运算符栈    optr.push(&#x27;\\0&#x27;);    while(!optr.empty())    &#123; //逐个处理各字符，直至运算符栈空        if(isdigit(*S)) //若当前字符为操作数，则读入（可能多位的）操作数            readNumber(S,opne);        else //若当前字符为运算符，则视其与栈顶运算符之间优先级的高低            switch(orderBetween(optr.top(),*S))            &#123;/*分别处理*/&#125;    &#125;    return opnd.pop(); //弹出最后的计算结果&#125;\n\n不同优先级处理方法\nswitch(orderBetween(optr.top(),*S))&#123;    case &#x27;&lt;&#x27;: //栈顶运算符优先级更低        optr.push(*S);        S++;        break; //计算推迟，当前运算符进栈    case &#x27;=&#x27;: //优先级相等(当前运算符为右括号，或尾部哨兵&#x27;\\0&#x27;)        optr.pop();        S++;        break; //脱括号并接收下一个字符    case &#x27;&gt;&#x27;:        &#123; //栈顶运算符优先级更高，实施相应的计算，结果入栈            char op = optr.pop(); //栈顶运算符出栈，执行对应的运算            if(&#x27;!&#x27; == op) opnd.push(calc(op,opne.pop()); //一元运算符            else               &#123;                float pOpnd2 = opnd.pop(),pOpnd1 = opnd.pop(); //二元运算符                opnd.push(calcu(pOpnd1,op,pOpnd2)); //实施计算，结果入栈               &#125;                break;              &#125;        &#125;\n\n当前栈顶左括号，当前字符右括号，表明右括号之前的子表达式已都执行完毕，所以左括号弹出，字符指向下一个，末尾\\0同理\n逆波兰表达式（RPN）\n将表达式优先级转化为运算符在RPN表达式序列中出现的次序，谁先出现谁就优先计算\n手工转换\n转换后运算符的次序有可能颠倒改变，然而运算数却是不变的\n\n队列First in first out\n只能在队尾插入（查询）：enqueue（） + rear（）\n只能在队头插入（查询）：dequeue（） + front（）\n队列属于序列的特例，则可直接基于向量或列表派生\ntemplate&lt;typename T&gt; class Queue:public List&lt;T&gt;&#123;public:    void enqueue(T const &amp; e)&#123; insertAsLast(e);&#125; //尾部入队    T dequeue() &#123; return remove(first()); &#125; //首部出队    T &amp; front() &#123; return first()-&gt;data; &#125; //队首&#125;；\n\n如此实现的队列接口，均只需O(1)时间\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"列表","url":"/2021/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%97%E8%A1%A8/","content":"列表接口与实现根据是否修改数据结构，所有操作大致分为两类方式\n\n静态：仅读取，数据结构的内容及组成一般不变：get、search\n动态：需写入，数据结构的局部或整体将改变：insert、remove\n\n与操作方式相对应地，数据元素的存储与组织方式也分为两种\n\n静态：\n\n数据空间整体创建或销毁\n数据元素的物理存储次序与其逻辑次序严格一致\n可支持高效的静态操作\n比如向量，元素的物理地址与其逻辑次序线性对应\n\n\n动态：\n\n为各数据元素动态地分配和回收的物理空间\n逻辑上相邻的元素记录彼此的物理地址，在逻辑上形成一个整体\n可支持高效的动态操作\n\n\n\n从向量到列表列表（list）是采用动态存储策略的典型结构，其中的元素称作节点（node）\n各节点通过指针或引用彼此联接，在逻辑上构成一个线性序列\n相邻节点彼此互称前驱或后驱\n没有前后驱的唯一节点称作首（first/front）/末（last/rear）节点\n从秩到位置向量支持循秩访问的方式（这种方式效率高）\n然而在列表中，这种循秩访问的成本过高，已不合时宜\n因此，应该用循位置访问的方式，即利用节点之间的相互引用，找到特定的节点 \n\nADT接口\n\n列表节点类：\n#define Posi(T) ListNode&lt;T&gt;* //列表节点位置template&lt;typename T&gt;struct ListNode&#123; //列表节点模板类（以双向链表形式实现）    T data; //数值    Posi(T) pred; //前驱    Posi(T) succ; //后继    ListNode()&#123;&#125; //针对header和trailer的构造    ListNode(T e,Posi(T)p = NULL,Posi(T) s = NULL)        :data(e),pred(p),succ(s)&#123;&#125; //默认构造器    Posi(T) insertAsPred(T const&amp; e); //前插入    Posi(T) insertAsSucc(T const&amp; e); //后插入 &#125;;\n\n\n头、首、末、尾节点的秩可分别理解尾-1，0，n-1，n\n\n template&lt;typename T&gt; void List&lt;T&gt;::init()&#123;//初始化，创建列表对象时统一调用    header = new ListNode&lt;T&gt;; //创建头哨兵节点    trailer = new ListNode&lt;T&gt;; //创建尾哨兵节点    header-&gt;succ = trailer; header-&gt;pred = NULL; //互联    trailer-&gt;pred = header; trailer-&gt;succ = NULL; //互联    _size = 0; //记录规模&#125;\n\n无序列表插入template&lt;typename T&gt;Posi(T) List&lt;T&gt;::insertBefore(Posi(T)p,T const&amp; e)&#123; _size++; return p-&gt;insertAsPred(e); &#125;//e当做p的前驱插入\n\ntemplate&lt;typename T&gt; //前插入算法（后插入算法完全对称）Posi(T)ListNde&lt;T&gt;::insertAsPred(T const&amp; e)&#123;    Posi(T) x = new ListNode(e,pred,this); //创建（耗时一百倍）    pred-&gt;succ = x;    pred = x;    return x; //建立连接，返回新节点的位置&#125;\n\n即便当前节点是首节点，前驱依然是存在的（哨兵）\n\n基于复制的构造\ntemplate&lt;typename T&gt; //基本接口void List&lt;T&gt;::copyNodes(Posi(T) p,int n)&#123;    init(); //创建头、尾哨兵节点并做初始化    while(n--) //将起自p的n项依次作为末节点插入    &#123; insertAslast(p-&gt;data); p = p-&gt;succ; &#125;&#125;\n\n所谓insertAsLast其实就是insertBefore(trailer)\n删除与析构删除：\ntemplate&lt;typename T&gt; //删除合法位置p处节点，返回其数值T List&lt;T&gt;::remove(Pose(T) P)&#123; //O(1)    T e = p-&gt;data; //备份待删除节点数值（设类型T可直接赋值）    p-&gt;pred-&gt;succ = p-&gt;succ;    p-&gt;succ-&gt;pred = p-&gt;pred;    delete p;    _size--;    return e; //返回备份数值&#125;\n\n\n析构：\ntemplate&lt;typename T&gt; List&lt;T&gt;::~List()//列表析构&#123; clear(); delete header; delete trailer; &#125; //清空列表，释放头、尾\n\ntemplate&lt;typename T&gt; int List&lt;T&gt;::clear()&#123; //清空列表\tint oldSize = _size;    while(0 &lt; _size) //反复删除首节点，直至列表变空        remove(header-&gt;succ);    return oldSize;&#125; //O(n),线性正比于列表规模\n\n查找在节点p（可能是trailer）的n个（真）前驱中，找到等于e的最后者\ntemplate&lt;typename T&gt; //从外部调用时，0&lt;=n&lt;=rank(p)&lt;_sizePosi(T) List&lt;T&gt;::find(T const &amp;e,int n,Pose(T) p) const&#123; //顺序查找，O(n)    while(0 &lt; n--) //从右向左，逐个将p的前驱与e比对        if(e == (p = p-&gt;pred)-&gt;data)            return p; //直至命中或范围越界    return NULL; //若越出左边界，意味着查找失败&#125; \n\n如果目标节点有多个，那么会停止于最靠后的节点\n\n去重template&lt;typename T&gt; int List&lt;T&gt;::deduplicate()&#123; //剔除无序列表中重复的节点    if(_size &lt; 2) return 0; //平凡列表自然无重复    int oldSize = _size; //记录原规模    Pose(T) p = first(); rank r = 1; //p从首节点起    while(trailer != (p = p-&gt;succ))    &#123; //依次直到末节点        Posi(T) q = find(p-&gt;data,r,p); //在p的r个（真）前驱中，查找与之雷同者        q ? remove(q) : r++; //若的确存在，则删除；否则秩递增    &#125; //assert：循环过程中的任意时刻，p的所有前驱互不相同    return oldSize - _size; //列表规模变化量，即被删除元素总数&#125;\t\t\n\n有序列表唯一化\ntemplate&lt;typename T&gt; int List&lt;T&gt;::uniquify()&#123; //成批剔除重复元素    if(_size &lt; 2) return 0;    int oldSize = size;     ListNodePosi(T) p = first();    ListNodePosi(T) q; //p为各区段起点，q为其后继    while(trailer != (q = p-&gt;succ)) //反复考察紧邻的节点对（p，q）        if(p-&gt;data != q-&gt;data) p = q; //若互异，则转向下一区段    \telse remove(q);    return oldSize - _size; //被删除元素总数&#125; //只需遍历整个列表一趟，O(n)\n\n查找template&lt;typename T&gt; //在有序列表内节点p的n个（真）前驱中，找到不大于e的最后者Posi(T) List&lt;T&gt;::search(T const &amp;e,int n,posi(T) p) const&#123;    while(0 &lt;= n--) //对于p的最近的n个前驱，从右向左        if(((p = p-&gt;pred)-&gt;data) &lt;= e) break; //逐个比较   return p; //直至命中、数值越界或范围越界后，返回查找终止的位置&#125; //最好O(1)，最坏O(n);等概率时平均O(n),正比于区间宽度\n\nvector访问方式依据 rank 秩（RAM模型）\nList访问方式依据 Posi （TM模型）\n选择排序改进思路：相较于起泡排序的短距离小步慢跑式的挪动最大元素，为何不一次性完成这项工作\n\n//对列表中起始于位置p的连续n个元素做排序，valid（p） &amp;&amp; rank（p） + n &lt;= sizetemplate&lt;typname T&gt;void List&lt;T&gt;::selectionsort(Posi(T) p,int n)&#123;    Posi(T) head = p-&gt;pred;    Posi(T) tail = p; //待排序区间（head，tail）    for(int i = 0;i &lt; n;i++)         tail = tail -&gt; succ; //head/tail可能是头/尾哨兵    while(1 &lt; n)&#123;//反复从（非平凡的）待排序区间内找出最大者，并移至有序区间前端        insertBefore(tail,remove(selectMax(head-&gt;succ,n)));        tail = tail-&gt;pred;        n--; //待排序区间、有序区间的范围，均同步更新    &#125;&#125;\n\n\nselectMax（）\ntemplate&lt;typename T&gt; //从起始于位置p的n个元素中选出最大者，1 &lt; nPosi(T) List&lt;T&gt;::selectMax(Posi(T) P,int n)&#123; //O(n)    Posi(T) max = p; //最大者暂定为p    for(Posi(T) cur = p;1 &lt; n;n--) //后续节点逐一与max比较        if( !lt((cur = cur-&gt;succ)-&gt;data,max-&gt;data)) //若&gt;=max,则更新最大元素位置记录            max = cur;    return max;&#125;\n\n使用 &gt;= 可以对重复元素进行处理\n插入排序\n前缀部分总是有序直到整段有序\n//对列表中起始于位置p的连续n个元素做插入排序，valid(p) &amp;&amp; rank(p) + n &lt;= sizetemplate&lt;typename T&gt;void List&lt;T&gt;::insertionSort(Posi(T) p,int n)&#123;    for(int r = 0;r &lt; n;r++)&#123;        insertAfter(search(p-&gt;data,r,p),p-&gt;data); //查找+插入        p = p-&gt;succ;        remove(p-&gt;pred); //转向下一节点    &#125; //n次迭代，每次O(r+1)&#125; //仅使用O(1)辅助空间，属于就地算法\n\n\n最好情况：完全（或几乎）有序\n每次迭代，只需1次比较，0次交换，累计O(n)时间\n最坏情况：完全（或几乎）逆序\n第k次迭代，需O(k)次比较，1次交换，累计O(n^2)时间\n逆序对（inversion）某两个元素一左一右，左侧更大，右侧更小，则称为逆序对\n任何两个元素都可能构成逆序，所以长度为n的序列而言，逆序对的总数有可能多达O(n^2)，而将每一个逆序对都记到后面的账上，则对任何一个节点p，所对应的逆序对的总和则是整个序列逆序对的总数。\n\n p所对应的inversion有多少个，p就需要经过多少次比较抵达最终的插入位置，i（p）即是查找长度\n最好情况即是所有元素顺序输入，逐次递增，不含任何逆序对，所有，O（I+n），I为0\n相反，完全逆序输入情况，复杂度为n^2，其中任何一对都为逆序对。\n敏感输入(input-sensitive)：算法复杂度不光取决于问题的规模，而更多取决于输入本身所具有的特性，也就是无序程度。\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"向量","url":"/2021/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F/","content":"向量抽象数据类型=数据模型+定义在该模型上的一组操作\n数据结构 =基于某种特定语言，实现ADT的一整套算法\n向量ADT向量是数组的抽象与泛化，由一组元素按线性次序封装而成\n各元素与[0，n）内的秩（rank）一一对应（循秩访问）\n元素的类型不限于基本类型\n操作、管理维护更加简化、统一安全\n可更为便捷地参与复杂数据结构的定制与实现\n\n构造与析构http://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/vector/vector.h.htm\nusing Rank = int; //秩#define DEFAULT_CAPACITY  3 //默认的初始容量（实际应用中可设置为更大）template &lt;typename T&gt; class Vector &#123; //向量模板类protected:Rank _size; Rank _capacity;  T* _elem; //规模、容量、数据区void copyFrom ( T const* A, Rank lo, Rank hi ); //复制数组区间A[lo, hi)void expand(); //空间不足时扩容void shrink(); //装填因子过小时压缩bool bubble ( Rank lo, Rank hi ); //扫描交换void bubbleSort ( Rank lo, Rank hi ); //起泡排序算法Rank maxItem ( Rank lo, Rank hi ); //选取最大元素void selectionSort ( Rank lo, Rank hi ); //选择排序算法void merge ( Rank lo, Rank mi, Rank hi ); //归并算法void mergeSort ( Rank lo, Rank hi ); //归并排序算法void heapSort ( Rank lo, Rank hi ); //堆排序（稍后结合完全堆讲解）Rank partition ( Rank lo, Rank hi ); //轴点构造算法void quickSort ( Rank lo, Rank hi ); //快速排序算法void shellSort ( Rank lo, Rank hi ); //希尔排序算法public:// 构造函数Vector ( int c = DEFAULT_CAPACITY, Rank s = 0, T v = 0 ) //容量为c、规模为s、所有元素初始为v&#123; _elem = new T[_capacity = c]; for ( _size = 0; _size &lt; s; _elem[_size++] = v ); &#125; //s&lt;=cVector ( T const* A, Rank n ) &#123; copyFrom ( A, 0, n ); &#125; //数组整体复制Vector ( T const* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; //区间Vector ( Vector&lt;T&gt; const&amp; V ) &#123; copyFrom ( V._elem, 0, V._size ); &#125; //向量整体复制Vector ( Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; //区间// 析构函数~Vector() &#123; delete [] _elem; &#125; //释放内部空间// 只读访问接口Rank size() const &#123; return _size; &#125; //规模bool empty() const &#123; return !_size; &#125; //判空Rank find ( T const&amp; e ) const &#123; return find ( e, 0, _size ); &#125; //无序向量整体查找Rank find ( T const&amp; e, Rank lo, Rank hi ) const; //无序向量区间查找Rank search ( T const&amp; e ) const //有序向量整体查找&#123; return ( 0 &gt;= _size ) ? -1 : search ( e, 0, _size ); &#125;Rank search ( T const&amp; e, Rank lo, Rank hi ) const; //有序向量区间查找// 可写访问接口T&amp; operator[] ( Rank r ); //重载下标操作符，可以类似于数组形式引用各元素const T&amp; operator[] ( Rank r ) const; //仅限于做右值的重载版本Vector&lt;T&gt; &amp; operator= ( Vector&lt;T&gt; const&amp; ); //重载赋值操作符，以便直接克隆向量T remove ( Rank r ); //删除秩为r的元素int remove ( Rank lo, Rank hi ); //删除秩在区间[lo, hi)之内的元素Rank insert ( Rank r, T const&amp; e ); //插入元素Rank insert ( T const&amp; e ) &#123; return insert ( _size, e ); &#125; //默认作为末元素插入void sort ( Rank lo, Rank hi ); //对[lo, hi)排序void sort() &#123; sort ( 0, _size ); &#125; //整体排序void unsort ( Rank lo, Rank hi ); //对[lo, hi)置乱void unsort() &#123; unsort ( 0, _size ); &#125; //整体置乱Rank deduplicate(); //无序去重Rank uniquify(); //有序去重// 遍历void traverse ( void (* ) ( T&amp; ) ); //遍历（使用函数指针，只读或局部性修改）template &lt;typename VST&gt; void traverse ( VST&amp; ); //遍历（使用函数对象，可全局性修改）&#125;; //Vector\n\n原理：\n\n向量的复制\ntemplate&lt;typename T&gt; //T为基本类型，或已重载赋值操作符&#x27;=&#x27;void vector&lt;T&gt;::copyFrom(T* const A,Rank lo,Rank hi)&#123;    _elem = new T[_capacity = 2*(hi-lo)]; //分配空间,预留出足够的空间，在接下去足够长的时间内，不必因为有必要的扩容而打断计算过程    _size = 0; //规模清零    while(lo&lt;hi) //A[lo,hi)内的元素逐一        _elem[size++] = A[lo++]; // 复制至_elem[0,hi-lo)&#125;\n\n\n可扩充向量若采用静态空间管理策略，容量_capacity固定，则有明显的不足\n\n上溢（overflow）：_elem[]不足以存放所有元素\n尽管此时系统仍有足够的空间\n\n下溢（underflow）：_elem[]中的元素寥寥无几\n装填因子（load factor）size/capacity &lt;&lt; 50% \n\n\n更糟糕的是，一般的应用环境中难以准确预测空间的需求量\n可否使得向量可随实际需求动态调整容量，并同事保证高效率？\n动态空间管理在即将发生上溢时，适当的扩大内部数组的容量\n\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::expand()&#123;\t//向量空间不足时扩容    if(_size&lt;_capacity)return; //尚未满员，不必扩容    _capacity = max(_capacity,DEFAULT_CAPACITY); //不低于最小容量    T* oldElem = _elem;    _elem = new T[_capacity &lt;&lt;= 1]; //容量加倍    for(int i = 0;i &lt; _size; i++) //复制原向量内容        _elem[i] = oldElem[i]; //T为基本类型，或已重载赋值操作符&#x27;=&#x27;    delete[]oldElem; //释放原空间&#125;\n\n得益于向量的封装，尽管扩容之后的数据区的物理地址有所改变，却不致出现野指针\n递增式扩容T* oldElem = _elem; _elem = new T[_capacity += INCREMENT];//追加固定大小的容量\n\n最坏情况：在初始容量0的空向量中，连续插入n=m*I &gt;&gt; 2个元素…\n每一次的扩容与复制都会使得时间成本过多\n加倍式扩容T* oldElem = _elem; _elem = new T[_capacity &lt;&lt;= 1];//容量加倍\n\n在最坏去情况下，在初始容量为1的满向量中，连续插入n=2^m &gt;&gt; 2个元素\n各次扩容过程中复制原向量的时间成本依次为\n1,2,4,8，。。。，2^m = n  //几何级数\n总体耗时=O(n)，每次扩容的分摊成本为O(1)\n\n分摊复杂度平均复杂度或期望复杂度( average/expected complexity )\n\n根据数据结构各种操作出现概率的分布，将对应的成本加权平均\n\n各种可能的操作，作为独立事件分别考查\n\n割裂了操作之间的相关性和连贯性\n\n往往不能准确地评判数据结构和算法的真实性能\n\n\n分摊复杂度( amortized complexity )\n\n对数据结构连续地实施足够多次操作,所需总体成本分摊至单次操作\n从实际可行的角度,对一系列操作做整体的考量\n更加忠实地刻画了可能出现的操作序列\n可以更为精准地评判数据结构和算法的真实性能\n\n无序向量循秩访问从便捷性出发，实现和数组元素访问方式一样的：A[r]\n因此，重载下标操作符“[]”\ntemplate&lt;typename T&gt; //0 &lt;= r &lt; _sizeT &amp; vector&lt;T&gt;::operator[](Rank r) const &#123; return _elem[r]; &#125;\n\n右值：T x = v[r] + U[s] * W[t];\n左值：v[r] = (T)(2*X+3); //因为是引用的方式，所以可以为左值\n插入因为所有的向量元素都是紧邻排序的，所以为了能够插入新的元素，就必须将新元素的后缀元素整体右移\ntemplate&lt;typename T&gt; //e作为秩为r元素插入，0&lt;=r&lt;=sizeRank vector&lt;T&gt;::insert(Rank r,T const &amp; e)&#123;//O(n-r)    expand(); //若有必要，扩容    for(int i = _size;i &gt; r;i--) //自后向前，如果次序颠倒，则有可能出现数据被覆盖的危险        _elem[i] = _elem[i-1]; //后继元素顺次后移一个单元    _elem[r] = e; _size++; //置入新元素，更新容量    return r; //返回秩&#125;\n\n\n删除删除后，后缀统一左移，自前向后的前移操作，若顺序颠倒，可能出现危险\ntemplate&lt;typename T&gt; //删除区间[lo,hi),0&lt;=lo&lt;=hi&lt;=sizeint vector&lt;T&gt;::remove(Rank lo,Rank hi)&#123;//O(n-hi)    if(lo==hi) return 0; //出于效率考虑，单独处理退化情况    while(hi&lt;_size)        _elem[lo++] = _elem[hi++]; //[hi,_size)顺次前移hi-lo位    _size = lo; shrink(); //更新规模，若有必要缩容    return hi-lo;&#125;\n\n\n单元素删除可以视作区间删除操作的特例：[r] = [r,r+1)\n template&lt;typename T&gt; //删除向量中秩为r的元素，0&lt;=r&lt;sizeT vector&lt;T&gt;::remove(Rank r)&#123; //O(n-r)    T e = _elem[r]; //备份被删除的元素    remove(r,r+1); //调用区间删除算法    return e; //返回被删除元素&#125;\n\n查找template&lt;typename T&gt; //0&lt;=lo&lt;hi&lt;=_sizeRank vector&lt;T&gt;::find(T const &amp; e,Rank lo,Rank hi)const&#123;//O(hi-lo)=O(n),在命中多个元素时可返回秩最大者   while((lo &lt; hi--)&amp;&amp;(e != _elem[hi])); //逆向查找    return hi; //hi&lt;lo意味着失败；否则hi即命中元素的秩&#125;\n\n输入敏感算法：最好O(1)，最差O(n)\n去重/唯一化应用实例：网络搜索的局部结果经过去重操作，汇总为最终报告\ntemplate &lt;typename T&gt; //删除重复元素，返回被删除元素数目int Vector&lt;T&gt;::deduplicate() &#123; //繁琐版+错误版   int oldSize = _size; //记录原规模   Rank i = 1; //从_elem[1]开始   while (i &lt; _size) //自前向后逐一考查各元素_elem[i]      if (find(_elem[i], 0, i) &lt; 0) //在前缀中寻找与之雷同者（至多一个）         i++; //若无雷同则继续考查其后继      else         remove(i); //否则删除当前元素（至多一个？）   return oldSize - _size; //被删除元素总数&#125;\n\n正确性：\n不变性：在当前元素 v[i] 的前缀 v[0,i] 中，各元素彼此互异\n单调性：随着反复的while迭代\n\n当前元素前缀的长度单调非降，且迟早增至_size \n当前元素后缀的长度单调下降，且迟早减至0\n\n故算法必然终止，且至多迭代O(n)轮\n\n复杂度：\n每轮迭代中 find() 和 remove() 累计耗费线性时间，故总体为O(n^2)\n遍历遍历向量，统一对各元素分别实施visit操作\n利用函数指针实例，只读或局部性修改\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::traverse(void (*visit)(T&amp;)) //函数指针&#123;    for (int i = 0;i &lt; _size;i++)        visit(_elem[i]);&#125;\n\n利用函数对象机制，可全局性修改\ntemplate&lt;typename T&gt; template&lt;typename VST&gt;void vector&lt;T&gt;::traverse(VST&amp; visit) //函数对象&#123;    for (int i = 0;i &lt; _size;i++)        visit(_elem[i]);&#125;\n\n有序向量如何甄别一个向量是否有序\n有序/无序序列中，任意/总有一对相邻元素顺序/逆序\n因此，相邻逆序对的数目，可用以度量向量的逆序程度\ntemplate&lt;typename T&gt; //返回逆序相邻元素对的总数int vector&lt;T&gt;::disordered()const&#123;    int n = 0; //计数器    for(int i = 1;i &lt; _size;i++) //逐一检查各队相邻元素        n += (_elem[i - 1] &gt; _elem[i]); //逆序则计数    return n; //向量有序当且仅当 n = 0&#125; //若只判断是否有序，则首次遇到逆序对之后，即可立即终止\n\n唯一化低效版观察：在有序向量中，重复的元素必要相互紧邻构成一个区间，每一个区间只需保留单个元素即可\ntemplate&lt;typename T&gt;int vector&lt;T&gt;::uniquify()&#123;    int oldSize = _size;    int i = 0; //从首元素开始    while(i &lt; _size-1) //从前向后，逐一比对各对相邻元素，若雷同，则删除后者；否则，转至后一元素        (_elem[i] == _elem[i+1])?remove(i+1):i++;    return oldSize - _size; //向量规模变化量，即删除元素总数&#125; //注意：其中_size的减少，由remove()隐式地完成\n\n运行时间主要取决于while循环，次数共计： _size-1 = n-1\n最坏情况下：每次都需调用remove()，耗时O(n-1)~O(1)；累计O(n^2) \n\n高效版如果能够将每一个区间作为一个整体，成批的删除雷同元素，则有可能实现一步到位式移动\ntemplate&lt;typename T&gt;int vector&lt;T&gt;::uniquify()&#123;    Rank i = 0,j = 0; //各对互异“相邻”元素的秩    while(++j &lt; _size) //逐一扫描，直至末元素        //跳过雷同；发现不同元素时，向前移至紧邻于前者右侧        if(_elem[i] != _elem[j])            _elem[++i] = _elem[j];    _size = ++i;     shrink(); //直接删除尾部多余元素    return j - i; //向量规模变化量，即被删除元素总数&#125; //注意：通过remove(lo,hi)批量删除，依然不能达到高效率\n\n共计n-1次迭代，每次常数时间，累计O(n)时间\n\n二分查找（A)语义约定至少应该便于有序向量自身的维护：v.insert ( 1 + v.search(e) , e )\n即便失败，也应给出新元素适当的插入位置\n若允许重复元素，则每一组也需按其插入的次序排列\n\n约定：在有序向量区间v[lo , hi) 中，确定不大于e的最后一个元素秩\n若-无穷 &lt; e &lt; v[lo]，则返回lo - 1（左侧哨兵）\n若 v[hi-1] &lt; e &lt; +无穷，则返回 hi-1（末元素=右侧哨兵左邻）\n原理\n二分（折半）策略：轴点mi总是取作中点——于是\n每经过至多两次比较，或者能够命中，或者将问题规模缩减一半\n实现template&lt;typename T&gt; //在有序向量区间[lo,hi)内查找元素estatic Rank binSearch(T* A,T const&amp; e,Rank lo,Rank hi)&#123;    while(lo &lt; hi)    &#123;\tRank mi = (lo + hi)&gt;&gt;1; //以中点为轴点     \tif(e &lt; A[mi]) hi = mi; //目标处于e的左侧，深入前半段[lo,mi)继续查找    \telse if(A[mi] &lt; e) lo = mi + 1; //目标\t处于e的右侧，深入后半段(mi,hi)     \telse return mi; //在mi处命中    &#125;    return -1; //查找失败&#125;\n\n\n\nFib查找\n二分查找版本A的效率仍有改进余地，因为不难发现转向左、右分支前的关键吗比较次数不等，而递归深度却相同\n若能通过递归深度的不均衡，来转向成本的不均衡进行补偿，平均查找长度应能进一步缩短\n\n\ntemplate&lt;typename T&gt; //0 &lt;= lo &lt;=hi &lt;= _sizestatic Rank fibsearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    Fib fib(hi-lo);    while(lo &lt; hi)    &#123;        while(hi - lo &lt; fib.get())            fib.prev(); //至多迭代几次？        //通过向前顺序查找，确定形如fib(k) - 1的轴点(分摊O(1))        Rank mi = lo + fib.get() - 1; //按黄金比例切分        if(e &lt; A[mi]) hi = mi; //深入前半段[lo,mi)继续查找        else if (A[mi] &lt; e)lo = mi + 1; //深入后半段(mi,hi)        else return mi; //在mi处命中    &#125;    return -1; //查找失败&#125;\n\n二分查找(B)每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个\n\n\n以上二分查找及Fibnacci查找算法\n均为严格地兑现search（）接口的语义约定：返回不大于e的最后一个元素\n\n只有兑现这一约定，才可有效支持相关算法，比如：v.insert（1+v.search（e），e）\n\n只有多个命中元素时，必须返回最靠后（秩最大）者\n失败时，应返回小于e的最大者（含哨兵[lo-1]）\n\n\n\ntemplate&lt;typename T&gt;static Rank binSearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    while(1 &lt; hi - lo)    &#123;//有效查找区间的宽度缩短至1时，算法才会终止        Rank mi = (lo + hi) &gt;&gt; 1; //以中点为轴点，经比较后确定深入        （e &lt; A[mi]) ? hi = mi : lo = mi; //[lo,mi)或[mi,hi)    &#125; //出口时hi = lo + 1,查找区间仅含一个元素A[lo]    return (e == A[lo]) ? lo : -1; //返回命中元素的秩或者-1&#125; //相较于版本A，最好（坏）情况下更坏（好）；各种情况下的SL更加接近，整体性能更趋稳定\n\n\n二分查找（C）template&lt;typename T&gt;static Rank binSearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    while(hi &lt; lo)    &#123;//不变性：A[0,lo) &lt;= e &lt; A[hi,n]        Rank mi = (lo + hi) &gt;&gt; 1; //以中点为轴点，经比较后确定深入        （e &lt; A[mi]) ? hi = mi : lo = mi + 1; //[lo,mi)或（mi,hi)    &#125; //出口时,A[lo = hi]为大于e的最小元素    return --lo; //故lo - 1即不大于e的元素的最大秩&#125;\n\n与版本B的差异\n\n待查找区间宽度缩短至0而非1时，算法才结束\n转入右侧子向量时，左边界取作mi+1而非mi\n无论成功与否，返回的秩严格符合接口的语义约定\n\n\n插值排序假设已知有序向量中各元素随机分布的规律，比如均匀且独立的随机分布\n那么[lo，hi）内各元素应大致按照线性趋势增长\n因此通过猜测轴点mi，可以极大提高收敛速度\n\n最坏情况：可能退化为平凡的顺序查找  O（hi - lo） = O（n）\n平均情况：每经一次比较，n缩至根号n\n\n\n易受小扰动的干扰和“蒙骗”\n\n须引入乘法、除法运算\n\n实际可行的方法\n首先通过插值查找，将查找范围缩小到一定的范围，然后再进行二分查找\n\n\n大规模：插值查找\n中规模：折半查找\n小规模：顺序查找\n起泡排序向量若有序排列，计算效率将大大提升\n如何实现向量的有序化？（排序算法）\n统一接口 sort（Rank lo，Rank hi）\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while(!bubble(lo,hi--)); &#125; //逐趟做扫描交换，直至全序\n\n不变性：每经过对bubble的调用，都会有一个新的元素就位（减而治之），有序的部分逐渐拓展，无序的部分逐渐缩减\n\n改进：绿色的部分未必都是无序的，有可能存在一部分或者所有绿色都是有序的\n如何尽早判定这种情况？\n每一趟扫描交换，都记录下是否存在逆序元素，若存在，当且仅当做过交换\n反例\n实质需要排序的元素集中在一个宽度仅为根号n的区间中\n \n多余出来的消耗就是在后缀中已就位元素的扫描交换\n记录在上一趟扫描交换中所进行的最后一趟交换，就可以知道上一趟有多长的后缀没有进行扫描交换，如果这样，只需将右侧标志hi指向新的位置\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while(lo &lt; (hi = bubble(lo,hi))); &#125; //逐趟做扫描交换，直至全序template&lt;typname T&gt;Rank vector&lt;T&gt;::bubble(Rank lo,Rank hi)&#123;    Rank last = lo; //最右侧的逆序对初始化为[lo - 1,lo]    while(++lo &lt; hi) //自左向右，逐一检查各队相邻元素        if(_elem[lo - 1] &gt; _elem[lo])        &#123;//若逆序，则更新最右侧逆序对位置记录，并交换         \tlast = lo;            swap(_elem[lo - 1],_elem[lo]);        &#125;    return last; //返回最右侧的逆序对位置&#125; \t\n\n归并排序\n序列一分为二，子序列递归排序，合并有序子序列\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::mergeSort(Rank lo,Rank hi)&#123;    if(hi - lo &lt; 2) return; //单元素区间自然有序    int mi = (lo + hi) &gt;&gt; 1; //以中点为界    mergeSort(lo,mi); //对前半段排序    mergeSort(mi,hi); //对后半段排序    merge(lo,mi,hi); //归并&#125;\n\n二路归并\n\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::merge(Rank lo,Rank mi,Rank hi)&#123;    T*A = _elem + lo; //合并后的向量A[0,hi - lo) = _elem[lo,hi)    int 1b = mi - lo;    T*B = new T[1b]; //前子向量B[0,1b) = _elem[lo,mi)    for(Rank i = 0;i &lt; 1b;B[i] = A[i++]); //复制前子向量B    int 1c = hi - mi;    T*C = _elem + mi; //后子向量C[0,1c) = _elem[mi,hi)    for(Rank i = 0,j = 0, k = 0;(j &lt; 1b) || (k &lt; 1c);)    &#123;//B[j]和C[k]中小者转至A的末尾        if((j &lt; 1b) &amp;&amp; (1c &lt;=k || (B[j] &lt;= C[k])))             A[i++] = B[j++]; //C[k]已无或不小        if((k &lt; 1c) &amp;&amp; (1b &lt;= j || (C[k] &lt; B[j])))            A[i++] = C[j++]; //B[j]已无或更大    &#125; //该循环实现紧凑；但就效率而言，不如拆分处理    delete[] B; &#125;\n\n\n\n\n一般B提前耗尽，就可终止算法\n复杂度\n算法的运行时间主要消耗与for循环，共有两个控制变量\n\n初始：j = 0，k = 0\n最终：j = lb，k = lc\n亦即：j + k = lb + lc = hi - lo = n\n\n每经过一次迭代，j和k中至少有一个会加一（j+k也必至少加一）\n故知：merge()总体迭代不过O(n)次，累计只需线性时间\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"绪论","url":"/2021/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/","content":"绪论计算计算是：\n\n研究对象：研究计算过程中所蕴含本质的内在规律，总结挖掘出其中的一般性的方法以及典型的技巧\n研究目的：实现高效，低耗的计算\n\n算法：即在特定计算模型下，旨在解决特定问题的指令序列\n程序！=算法\n有穷性：\n对于任何输入，经有穷次基本操作，都可以得到输出 \n好算法=正确+健壮+可读+效率（速度快，空间少）\n图灵机\n进行复位是为了在软件开发过程中相互合作的准则，即规范\nRAM模型\n一个算法好不好并不取决于CPU主频运行的快慢， 而取决于它本身需要执行多少次CPU的计算\n\n\n执行过程可以记录为一张表\n表的行数既是所执行基本指令的总条数\n能够客观度量算法的执行时间\n\n图灵机、RAM等模型为度量算法性能提供了准确的尺度\n渐进复杂度在考察DSA时应该更多看中它的长远（处理更大问题时的潜力如何），也不必过多的纠结于它的细微不足，应该更多的看到它的主要方面，主流\n大O记号从悲观的角度做分析\n\n长远，当n足够大；主流，忽略所有常系数与低次项这些非主流的因素，使得主流信息可以突出\n复杂度分析算法分析的两个主要任务=正确性（不变形x单调性）+复杂度\n复杂度分析的主要方法\n\n迭代：级数求和\n递归：递归跟踪+递归方程\n猜测+验证\n\n级数\n\n循环\n从渐进的阶次而言，二者是完全相等的，都是平方的量级\n起泡排序\n问题：该算法必然会结束？至多需迭代多少趟？\n不变形：经k轮扫描交换后，最大的k个元素必然就位\n单调性：经k轮扫描后交换后，问题规模缩减至n-k\n正确性：经至多n趟扫描后，算法必然会终止，且能给出正确的答案\n\n封底估算除了大O计算这种定性的定界方法，在很多时候需要准确的定量估算\n迭代与递归减而治之\n空间复杂度考量除了输入本身所占的空间之外，所需要的另加用于计算所必须的空间总量\n\n为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡，另一规模缩减\n递归跟踪：直观形象，仅适用于简明的递归模式\n\n递推方程：间接抽象，更适用于复杂的递归模式\n\n\n分而治之为求解一个大规模的问题，可以将其划分为若干子（通常两个）问题，规模大体相当\n\n\n动态规划fib的封底估算\n\nfib递归跟踪\n\nfib迭代\n\n解决方法（记忆）：将已计算过实例的结果制表备查\n解决方法（动态规划）：颠倒计算方法，由自顶而下递归，为自底而上迭代 \n\n公共子序列\n减而治之：将相同的末字符切掉，分成一个平凡的问题和一个小于1的相同规模问题\n\n分而治之：若末尾字符不相同，则大胆切除\n\n单调性：无论如何，每经过一次对比，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩短一个单位\n最好情况（不出现第2种情况）下，只需O（n+m）时间\n但问题在于，（在第2种情况）原问题将分解为两个子问题，更糟糕的是，它们在随后进一步导出的子问题，可能雷同\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"二叉树","url":"/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"二叉树树无论是向量还是列表都无法做到兼顾静态和动态的高效\n半线性结构：树型结构不是狭义的线性结构，却带有线性的特征\n\n树是按照层次关系来组织数据项的方式\n\n有根树：r树根（父亲），subtree子树，ri之间互称兄弟（sibling），d = degree（r)为r的度，e树的边数，n顶点总数\n\n故在衡量相关复杂度时，可以n作为参照\n若指定Ti作为T的第i棵子树，ri作为r的第i个孩子，则T称作有序树(ordered tree)\n路径+环路\n连通+无环\n一旦指定了根，其他的节点都将获得一个确定的指标，通过指标，同一类顶点所具有的指标都是相等的，也称为等价类\n深度+层次\n根节点是所有节点的公共祖先，深度为0\n没有后代的节点称作叶子（leaf）\n所有叶子深度中的最大者，称作树的高度\n一个节点都没有的树称作空树，高度为-1\ndepth(v) + height(v) &lt;= height(T)\n树的表示\n性能：\n\n长子+兄弟每个节点均设两个引用\n纵：firstChild（）\n横：nextSibling（）\n\n二叉树节点度数不超过2的树称作二叉树（binary tree）\n同一节点的孩子和子树，均以左、右区分\n在有根性和有序性能够保证的前提下，二叉树足以描述所有的树\n\n深度为k的节点，至多为2^k个\n\n含n个节点，高度为h的二叉树中\nh &lt; n &lt; 2^h+1\n\nn = h + 1时，退化为一条单链\n\nn = 2^h+1 - 1时，即所谓满二叉树（full binary tree）\n\n\n真二叉树每个节点的度数都是偶数\n假想添加：\n\n用长子兄弟法将多叉树转化为二叉树\n\n即可以用二叉树来表示任何一棵有根有序树\n正因如此，二叉树虽是树的特例，却可直接研究二叉树\n实现BinNode类\n每个节点通过引用指向其他节点，每个节点所占据的一个空间为一个位置\n#define BinNodePosi(T) BinNode&lt;T&gt;* //节点位置template&lt;typename T&gt; struct BinNode&#123;    BinNodePosi(T) parent,lChild,rChild; //父亲，孩子    T data; int height; int size(); //高度，子树规模    BinNodePosi(T) insertAsLc(T const &amp;); //作为左孩子插入新节点    BinNodePosi(T) insertAsRc(T const &amp;); //作为右孩子插入新节点    BinNodePosi(T) succ(); //(中序遍历意义下)当前节点的直接后继    template &lt;typename VST&gt; void travLevel( VST &amp; ); //子树层次遍历    template &lt;typename VST&gt; void travPre( VST &amp; ); //子树先序遍历    template &lt;typename VST&gt; void travIn( VST &amp; ); //子树中序遍历    template &lt;typename VST&gt; void travPost( VST &amp; ); //子树后序遍历&#125;\n\n接口实现\n传入参数e进行封装，并且将它作为当前节点的左/右孩子，接入所属树中\ntemplate&lt;typename T&gt; BinNodePosi(T)::insertAsLc(T const &amp; e)&#123; return l Child = new BinNode(e,this); &#125; //O(1)\n\nsize(后代总数，即以其为根的子树的规模)\ntemplate&lt;typename T&gt;int BinNode&lt;T&gt;::size()&#123;    int s = 1; //计入本身    if(lChild) s += lChild-&gt;size(); //递归计入左子树规模    if(rChild) s += rChild-&gt;size(); //递归计入右子树规模    return s;&#125; //O(n=size)\n\nBinTree模板类template&lt;typename T&gt; class BinTree&#123;protected:    int _size; //规模    BinNodePosi(T) _root; //根节点    virtual int updateHeight( BinNodePosi(T) x); //更新节点x的速度    void updateHeightAbove(BinNodePosi(T) x); //更新x即祖先的速度public:    int size() const &#123; return _size; &#125; //规模    bool empty() const &#123; return !_root; &#125; //判空    BinNodePosi(T) root() const &#123; return _root; &#125; //树根    /* ...子树接入、删除和分离接口...*/    /* ...遍历接口... */&#125;\n\n高度更新根节点高度为0，空树高度为-1\n一个节点的高度恰好等于左右孩子中的更大者+1\n定义一个新的等价意义上的高度，使得算法更为简便：\n#define stature(p) ( (p) ? (p)-&gt;height : -1)\n\ntemplate&lt;typename T&gt; //更新节点x高度，具体规则因树不同而异int BinTree&lt;T&gt;::updateHeight( BinNodePosi(T) x)&#123;    return x-&gt;height = 1 + max( stature( x-&gt;lChild ),stature( x-&gt;rChild ) );&#125; //此处采用常规二叉树规则，O(1)\n\n如果x的父节点存在，那么x的高度变化，则会连锁到父节点，祖父节点…，因此更新节点从x出发，向上逐层追溯它的历代祖先直到抵达根节点\ntemplate&lt;typename T&gt; //更新v及其历代祖先的高度void BinTree&lt;T&gt;::updateHeightAbove( BinNodePosi(T) x )&#123;    while(x) //可优化：一旦高度未变，即可终止    &#123; updateHeight(x); x = x-&gt;parent; &#125;&#125; //O( n = depth(x) )\n\n节点插入在一棵二叉树中，将某个新生成的节点，作为树中某一原本没有右孩子的节点的右孩子接入\n\ntemplate&lt;typename T&gt; BinNodePosi(T)BinTree&lt;T&gt;::insertAsRc( BinNodePosi(T) X,T const &amp; e )&#123;    _size++;    x-&gt;insertAsRc(e); //x祖先的高度可能增加，其余节点必要不变    updateHeightAbove(x);    return x-&gt;rChild;&#125;\n\n先序遍历遍历：按照某种次序访问树中各节点，每个节点被访问恰好一次\n先序：V-&gt;L-&gt;R        中序：L-&gt;V-&gt;R        后序：L-&gt;R-&gt;V\n先序遍历顺序：自上而下访问左侧链上的节点，再自下而上访问它们的右子树\ntemplate&lt;typename T,typename VST&gt;void traverse(BinNodePosi(T) x,VST &amp; visit)&#123; //递归实现    if(!x) return; //递归基的处理    visit( x-&gt;data );     traverse( x-&gt;lChild,visit );    traverse( x-&gt;rChild,visit );&#125; //T(n) = O(1) + T(a) + T(n-a-1) = O(n)\n\n这种算法只具有渐进的意义，在实际过程中，因为递归程序的实现机制，只能采用通用的方法，运行栈中每个递归实例都具有一帧，但是因为它们必须具有通用格式，所以并不能做到足够的小。因此，作为树算法的重要基石，遍历算法非常有必要从递归改写为迭代\n迭代实现(1)template&lt;typename T,typename VST&gt;void travPre_I1( BinNodePosi(T) x,VST &amp; visit)&#123;    Stack&lt;BinNodePosi(T)&gt; S; //辅助栈    if(x) S.push(x); //根节点入栈    while( !S.empty() )&#123; //在栈变空之前反复循环        x = S.pop();        visit( x-&gt;data ); //弹出并访问当前节点        if( HasRChild(*x) ) S.push(x-&gt;rChild); //右孩子先入后出        if( HasLchild(*x) ) S.push(x-&gt;lChild); //左孩子后入先出    &#125;&#125;\n\n所有的遍历算法都是先访问左孩子再访问右孩子，所以依据栈的特性，右孩子先入后出（后遍历）\n\n对于任何一根子树，我们都将起始于树根的总是沿着左侧孩子分支不断下行的这条链，称作当前这棵子树的左侧链\n\n首先自顶而下的依次访问左侧链上的沿途节点，再倒过来，自底而上地依次遍历各个层次上的右子树\n迭代实现(2)template&lt;typename T,typename VST&gt; //分摊(1)\t static void visitAlongLeftBranch(BinNodePosi(T) x,VST &amp; visit,Stack&lt;BinNodePosi&gt; &amp; s)&#123;    while(x)&#123;        visit( x-&gt;data ); //反复访问当前节点        S.push( x-&gt;rChild ); //右孩子入栈        x = x-&gt;lChild; //沿左侧链下行    &#125;&#125;\n\ntemplate&lt;typename T,typename VST&gt;void travPre_I2( BinNodePosi(T) x,VST &amp; visit )&#123;    Stack&lt;BinNodePosi(T)&gt;S; //辅助栈    while(true)&#123; //以右子树为单位，逐批访问节点        visitAlongLeftBranch( x,visit,S); //访问子树x的左侧链，右子树入栈缓冲        if( S.empty() ) break; //栈空即退出        x = S.pop(); //弹出下一子树的根    &#125;&#125;\n\n\n中序遍历思路递归：\ntemplate&lt;typename T,typename VST&gt;void traverse( BinNodePosi(T) x,VST &amp; visit )&#123;    if( !x ) return;    traverse( x-&gt;lChild,visit );    visit( x-&gt;data );    traverse( x-&gt;rChild,visit );&#125; //T(n) = T(a) + O(1) + T(n-a-1) = O(n)\n\n\n从根节点开始一直沿着左侧分支逐层向下直到末端\n因此整个中序遍历分解为在不同尺度下的一系列的对左侧分支的逐步处理\n\n\n从根出发沿左分支下行，直到最深的节点——它就是全局首先被访问者\n自上而下谦让，再自下而上访问\n\n实现template&lt;typename T&gt;static void goAlingLeftBranch( BinNodePosi(T) x,Stack&lt;BinNodePosi(T)&gt; &amp; S )&#123; while(x) &#123; S.push(x); x = x-&gt;lChild; &#125;&#125; //反复地入栈，沿左分支深入template&lt;typename T,typename v&gt; void travIn_I1( BinNodePosi(T) x,V&amp; visit )&#123;    Stack&lt;BinNodePosi(T)&gt; S; //辅助栈    while(true)&#123;        goAlongLeftBranch(x, S); //从当前节点出发，逐批入栈        if( S.empty() ) break; //直至所有节点处理完毕        x = S.pop(); //x的左子树或为空，或已遍历（等效于空），故可以        visit( x-&gt;data ); //立即访问之        x = x-&gt;rChild; //再转向其右子树(可能为空，需留意处理手法)    &#125;&#125;\n\n\n所有左侧链的长度集中在一起也就是O(n)\n每一个节点的入栈操作对应的是左侧链上的一步，因此左侧链的长度就是push的操作次数\n后序遍历递归：\ntemplate&lt;typename T,typename VST&gt;void traverse( BinNodePosi&lt;T&gt; x,VST &amp; visit )&#123;    if( !x ) return;    traverse( x-&gt;lc,visit );    traverse( x-&gt;rc,visit );    visit( x-&gt;data );&#125;\n\n\n\n从根出发下行，尽可能沿左分支，实不得已，才沿右分支\n最后一个节点，必是叶子，而且是按中序遍历次序最靠左者，也是递归版中visit()首次执行处\n\ntemplate&lt;typename T&gt;static void gotoleftmostleaf( Stack&lt;BinNodePosi&lt;T&gt;&gt; &amp; S)&#123;    while( BinNOdePosi&lt;T&gt; x = S.top() ) //自顶而下反复检查栈顶节点        if( HasLChild(*x) )&#123; //尽可能向左，在此之前            if( HasRChild(*x) ) //若有右孩子，则                S.push( x-&gt;rc ); //优先入栈            S.push( x-&gt;lc ); //然后转向左孩子        &#125;else //实不得已            S.push( x-&gt;rc ); //才转向右孩子    S.pop(); //返回之前，弹出栈顶的空节点&#125;\n\ntemplate&lt;typename T,typename VST&gt;void travPost_I( BinNodePosi&lt;T&gt; x,VST &amp; visit )&#123;    Stack&lt;BinNodePosi&lt;T&gt;&gt; S; //辅助栈    if(&#125;\n\n层次遍历在此前的三种遍历中，都是后代先于祖先访问，即逆序，为此，都会使用到栈\n而在层次遍历中，所有节点都将按照深度次序由高至低访问\ntemplate&lt;typename T&gt;template&lt;typename T&gt;void BinNode&lt;T&gt;::travLevel( VST &amp; visit)    Queue&lt;BinNodePosi(T) Q; //引入辅助队列\tQ.enqueue( this ); //根节点入队\twhile( !Q.empty() )&#123; //在队列再次清空之前，反复迭代        BinNodePosi(T) x = Q.dequeue(); //在取出队首节点        visit( x-&gt;data );         if( HasLChild(*x) ) Q.enqueue( x-&gt;lChild ); //左孩子入队        if( HasRChile(*x) ) Q.enqueue( x-&gt;rChild ); //右孩子入队    &#125;\n\n\nHuffman树无前缀冲突编码各自的叶子不会待在另一叶子的通路上\n\n编码成本相差一个bit，影响的是带宽，费用，成本等等\n\n之所以要平衡，是为了杜绝深度差够大，至少是2的瑕疵，一旦有这种瑕疵，就可以通过交换进行优化\n带权编码长度因为频度的不同\n\n根据频率高/低的(超)字符，应尽可能放在高/低处\n故此，通过适当的交换，同样可以缩短wald(T)\n\n编码算法贪婪策略：频率低的字符优先引入，位置亦更低\n为每个字符创建一棵单节点的树，组成森林F\n按照出现频率，对所有树排列\nwhile( F中的树不止一棵 )    取频率最小的两棵树：T1和T2    将它们合并成一棵新树T，并令：    \tlchild(T) = T1且rChild(T) = T2    \tw(root(T)) = w(root(t1)) + w(root(T2))\n\n构造编码书\n每次取最小两个数合并(贪心)，并慢慢成长\n \n编码表：遍历，先中后序都可以，因为都是深度优先\n解码：从根开始，走到叶子，打印字符，再重置到根循环\n","categories":["数据结构"],"tags":["数据结构与算法"]}]