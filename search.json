[{"title":"Hello World","url":"/2022/01/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"text","url":"/2022/02/05/text/","content":"测试测试测试\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第三章 物理内存分配","url":"/2022/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter3%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第三章 物理内存分配3.1 计算机体系结构及内存分层体系计算机体系结构计算机组成原理\nCPU，内存，总线，I/O\n内存体系结构OS内存管理目标\n抽象（逻辑地址空间）：应用程序不需要考虑底层细节\n保护（独立地址空间）：内存中可以运行多个应用程序，多个程序可能访问别的程序的地址空间或者破坏其他程序\n共享（访问相同内存）：进程之间安全有效可靠的数据传递\n虚拟化（更多的地址空间）：当内存不够时，把最需要的数据放在内存中，暂时不需要访问的数据可以临时的放到硬盘上\n\nOS内存管理方法\n程序重定位\n分段\n分页\n虚拟内存\n按需分页虚拟内存\n\n实现高度依赖于硬件\n\nMMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求\n\n3.2 地址空间与地址生成地址空间物理地址空间——硬件支持的地址空间（起始0，MAX_sys）\n逻辑地址空间——一个运行的程序所拥有的的内存范围（0，MAX_prog）\n逻辑地址的生成\n\n物理地址的生成\n\n\n地址安全检查\n\n3.3 连续内存分配内存碎片内存碎片问题指的是空闲的内存无法被利用\n\n外部碎片：分配单元之间的未使用内存\n内部碎片 :  分配给应用程序的单元内的未使用内存\n\n分区的动态分配\n第一匹配分配：在内存中找到第一个比需求大的空闲块, 分配给应用程序\n\n\n\n\n分配方式\n第一匹配分配\n最优适配分配\n最差适配分配\n\n\n\n实现需求\n1. 按地址排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配最大的分区3. 重分配需要检查是否可以合并相邻空闲分区\n\n\n优势\n简单 / 易于产生更大空闲块\n比较简单 / 大部分分配是小尺寸时有效\n分配很快 / 大部分分配是中尺寸时高效\n\n\n劣势\n产生外部碎片 / 不确定性\n产生外部碎片 / 重分配慢 / 易产生很多没用的微小碎片\n产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配\n\n\n3.4 连续内存分配：压缩式与交换式碎片整理无论使用那种算法，都可能产生碎片，希望想有一些办法使得碎片减少甚至消失\n压缩式碎片整理\n重置程序以合并空洞\n要求所有程序是动态可充值的\n议题\n何时重置？\n开销\n\n\n\n\n通过拷贝完成（重定位）\n在运行的时候挪操作，地址会不对\n\n应在程序停止时进行\n\n开销很大，甚至可能影响整个系统的正常执行\n\n\n交换式碎片整理\n运行程序需要更多的内存\n抢占等待的程序&amp;回收他们的内存(把暂时不用的内容挪到磁盘里)\n议题：哪些程序应该被抢占以及什么时候执行\n\n\n操作系统内核特征\n\n并发：计算机系统中同时存在多个运行的程序，需要OS管理和调度\n共享：宏观上“同时访问”，微观上互斥共享\n虚拟：利用多到程序设计技术，让每个用户都觉得有一个计算机专门为他服务\n异步：程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，只要运行环境相同，OS需要保证程序运行的结果也要相同\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第四章 非连续内存分配","url":"/2022/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter4%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第四章 非连续内存分配\n为什么需要非连续内存分配\n\n连续内存分配的缺点\n\n分配给一个程序的物理内存是连续的\n内存利用率低\n有外碎片，内碎片的问题\n\n非连续内存分配的优点\n\n一个程序的物理地址是非连续的\n更好的内存利用和管理\n允许共享代码与数据（共享库等）\n支持动态加载和动态链接\n\n非连续分配缺点\n\n如何建立虚拟地址和物理地址之间的转换\n软件方案\n硬件方案（分段，分页）\n\n\n\n4.1 分段\n程序的分段地址空间，分段寻址方案\n\n计算机程序由各种段组成\n\n分段：更好的分离和共享\n\n\n\n左边连续的虚拟地址，右边不连续的物理地址，采用映射机制进行两边的关联\n\n分段寻址方案\n\n\n一个段：一个内存“块”\n\n\n程序访问内存需要：\n\n\n一个2维的二元组（s，addr）\ns—段号\naddr—段内偏移\n\n\n\n\n操作系统建立段表\n分页\n划分物理内存至固定大小的帧\n\n大小是2的幂，e.g.，512,4096,8192\n\n\n划分逻辑地址空间至相同大小的页\n\n大小同物理地址\n\n\n建立方案 转换逻辑地址为物理地址（pages to frames）\n\n页表\nMMU/TLB（加速地址的转换）\n\n\n\n帧（Frame）\n物理内存被分割为大小相等的帧\n\n一个内存物理地址是一个二元组（f，o）\n\nf—帧号（F位，共有2F个帧）\no—帧内偏移（S位，每帧有2S字节）\n物理地址=2S * f + o\n\n\n16-bit地址空间, 9-bit(512 byte) 大小的页帧\n\n物理地址=（3，6）\n物理地址=1542\n\n\n\n\n页（Page）\n一个程序的逻辑地址空间被划分为大小相等的页\n\n页内偏移的大小 = 帧内偏移的大小\n页号大小 &lt;&gt; 帧号大小\n\n\n一个逻辑地址是一个二元组(p, o) \n\np—页号（P位，2P个页）\no—页内偏移（S位，每页有2S字节）\n逻辑地址=2S * P + o\n\n\n\n页寻址机制\n\n操作系统建立页表\n\n逻辑地址空间应当大于物理内存空间\n页映射到帧\n页是连续的虚拟内存\n帧是非连续的物理内存(有助于减少碎片的产生)\n不是所有的页都有对应的帧\n\n4.3 页表-概述、TLB页表概述页表结构\n\n每一个运行的程序都有一个页表\n属于程序运行状态, 会动态变化\nPTBR : 页表基址寄存器\n\n\n\n地址转换\n\n分页机制的性能问题\n问题：访问一个内存单元需要2次内存访问\n\n一次用于获取页表项\n一次用于访问数据\n\n页表可能非常大\n\n64位机器如果每页1024字节, 那么一个页表的大小会是多少？(264 / 210 = 254 存放不下)\n每一个运行的程序都需要有一个页表\n\n如何处理\n\n缓存\n间接访问\n\nTranslation Look-aside Buffer（TLB）（解决速度上问题）CPU的MMU里面的一个缓冲，CPU中的快表\n缓存近期访问的页帧转换表项\n\nTLB使用associative memory（关联内存）实现, 具备快速访问性能\n如果TLB命中, 物理页号可以很快被获取\n如果TLB未命中, 对应的表项被更新到TLB中\n常用的表项放在TLB里面\nTLB的miss不会很大\n写程序时，写出的程序尽量具有访问的局部性，把平时的访问集中在一个区域里，有效较少TLB的缺失\nx86的CPU由硬件实现, 其他的可能是由操作系统实现\n\n4.4 页表-二级，多级页表二级页表（解决空间上问题）\n\n将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.\n一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号\n节约了一定的空间, 在一级页表中如果resident bit = 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留多级页表\n\n\n通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”\n\n4.5 页表-反向页表大地址空间问题\n\n有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表\n不是让页表与逻辑地址空间的大小相对应, 而是让页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间 \n\n基于页寄存器（page registers）的方案每一个帧和一个寄存器关联, 寄存器内容包括 :\n\nresident bit : 此帧是否被占用\noccupier : 对应的页号 p\nprotection bits : 保护位\n\n实例\n\n物理内存大小是 : 4096 * 4096 = 4K * 4KB = 16 MB\n页面大小是 : 4096 bytes = 4 KB\n页帧数 : 4096 = 4 K\n页寄存器使用的空间(假设8 bytes / register) : 8 * 4096 = 32 Kbytes\n页寄存器带来的额外开销 : 32K / 16M = 0.2%\n虚拟内存大小 : 任意\n\n优势\n\n转换表的大小相对于物理内存来说很小\n转换表的大小跟逻辑地址空间的大小无关\n\n劣势\n\n需要的信息对调了, 即根据帧号可以找到页号\n如何转换回来? (如何根据页号找到帧号)\n在需要在反向页表中搜索想要的页号\n\n基于关联内存(associative memory)的方案硬件逻辑复杂，容量不能做太大，还需要放到CPU里面\n\n如果帧数较少, 页寄存器可以被放置在关联内存中\n\n在关联内存中查找逻辑页号\n\n成功 : 帧号被提取\n失败 : 页错误异常 (page fault)\n\n\n限制因素：\n\n大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)\n\n\n\n基于哈希(hash)的方案哈希表，哈希函数 : h(PID, p) 从 PID 标号获得页号\n在反向页表中通过哈希算法来搜索一个页对应的帧号\n\n对页号做哈希计算, 为了在帧表中获取对应的帧号\n页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数\n为了查找页 i , 执行下列操作 :\n计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器\n检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败\n\n\n\n","categories":["操作系统"],"tags":["内存分配"]}]