[{"title":"Big Three","url":"/2022/03/07/C++/Big%20Three/","content":"Big Three 三个特殊函数声明：\nclass String&#123;public:    String(const char* cstr = 0);    String(const String&amp; str); //拷贝构造,只做蓝本，\t所以const    String&amp; operator = (const String&amp; str); //拷贝赋值    ~String();    char* get_c_str() const &#123;return m_data;&#125;private:    char* m_data; //放一个指针，动态的分配大小&#125;\n\n\n拷贝构造：构造函数接受的是自己的类型\n\n拷贝赋值：参数类型也是自己这种类型\n\n\n定义：\n\n\nnew char[1] 这种写法也可以不加[]，之所以这样写是为了搭配上面，一个数组\n\n动态分配了一块内存，“hello”，所以析构要delete这块空间，离开作用域（花括号）delete自动调用\n\n\n拷贝构造深拷贝：\n\n当类持有动态分配的内存、指向其他数据的指针等的时候，需要深拷贝，保证拷贝的类里的指针指向自己的空间。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象\n\ninlineString::String(const String&amp; str)&#123;    m_data = new char[strlen(str.m_data)]; //先开辟空间    strcpy(m_data,str.m_data);&#125;\n\n&#123;    String s1(&quot;hello&quot;);    String s2(s1); //以s1为蓝本创建新对象s2 // String s2 = s1;&#125;\n\n浅拷贝：\n\n\n两个指针指向一起非常危险，改了a可能改b\n\n造成内存泄漏\n\n\n拷贝赋值\n\n作用在s2上，s2要做改变，所以s2应该先杀掉自己\n为满足连串赋值，返回类型不能是void\n检查自我赋值：\n提高效率\n正确性：本来指向的是同一个空间，第一个动作杀掉\n\n\n\n\n构造函数调用顺序#include &lt;iostream&gt;using namespace std;class A &#123;    int x;public:     A(int i=0) &#123;         x=i;         cout &lt;&lt; &quot;A-----&quot;&lt;&lt;x&lt;&lt;endl;     &#125;&#125;;class B &#123;    int y;public:    B(int i) &#123;        y=i;        cout &lt;&lt; &quot;B-----&quot;&lt;&lt;y&lt;&lt;endl;    &#125; &#125;; class C &#123;    int z;public:    C(int i) &#123;        z=i;        cout &lt;&lt; &quot;C-----&quot;&lt;&lt;z&lt;&lt;endl;    &#125; &#125;;class D : public B&#123;public:     C c1, c2;\tA a0,a4;    A *a1 = new A(10);     D( ) : a4(4),c2(2),c1(1),B(1) &#123;cout &lt;&lt; &quot;D-----5&quot;&lt;&lt;endl;    &#125;&#125;;int main()&#123;    D d;&#125;/*B-----1C-----1C-----2A-----0A-----4A-----10D-----5*/\n\n\n先构造基类，在根据成员声明顺序构造成员，最后构造自身\n\n派生类给基类传递参数\n#include &lt;iostream&gt;using namespace std;class Point&#123;protected:    int x,y;public:    Point(int a,int b=0) &#123;        x=a;  y=b;        cout&lt;&lt;&quot;constructing point(&quot;&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y&lt;&lt;&quot;)&quot;&lt;&lt;endl;    &#125;&#125;;class Line:public Point&#123;protected:    int len;public:    Line(int a,int b,int l):Point(a,b) &#123;\t//传递参数给基类        len=l;        cout&lt;&lt;&quot;Constructing Line,len ...&quot;&lt;&lt;len&lt;&lt;endl;    &#125;&#125;;int main()&#123;    Line L1(1,2,3);&#125;\n\n\n派生类只能采用   构造函数初始化列表的方式   向基类或成员对象的构造函数传递参数\n\n继承方式public：class Base &#123;private:\tint pri;protected:\tint pro;public:    int pub = 1;public:\tvoid setPri(int i) \t&#123;\t\tpri = i;\t&#125;\tint getPri() &#123; return pri;&#125;&#125;;class Drived : public Base&#123;private:\tint dri;public:\tvoid setDri() \t&#123; \t\tdri = getPri(); //通过基类的公有函数访问私有成员\t&#125;\tint getDri() &#123; return dri;&#125;\tvoid setPro(int i)     &#123;     // Pri = i; //不可直接访问私有成员\t\tpro = i; //类内部可以访问基类保护成员\t&#125;\tint getPro()&#123; return pro; &#125; &#125;;int main ()&#123;\t\tDrived d;\td.setPri(3);\td.setdri();    d.setPro(5);    cout &lt;&lt; d.pub &lt;&lt; endl; //可以直接通过使用者在外部访问公有成员\tcout &lt;&lt; d.getDri() &lt;&lt; endl;\tcout &lt;&lt; d.getPro() &lt;&lt; endl;\tcout &lt;&lt; d.getPri() &lt;&lt; endl;&#125;\n\nprotected：\n 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected    \n\n 基类的public成员在派生类中会变成protected成员\n\n\nclass Base&#123;    int x;protected:    int getx()&#123; return x; &#125;public:    void setx(int n)&#123; x=n; &#125;    void showx()&#123; cout&lt;&lt;x&lt;&lt;endl; &#125;&#125;;class Derived:protected Base&#123;    int y;public:    void sety(int n)&#123; y=n; &#125;    void sety()    &#123;         y=getx(); //访问基类的保护成员    &#125;       void showy()&#123; cout&lt;&lt;y&lt;&lt;endl; &#125;\tvoid setxx()    &#123;\t\tsetx(10);  //类内部访问保护成员\t\tshowx();\t&#125;&#125;;int main()&#123;    Derived obj;    obj.sety(20);\tobj.setxx();    obj.showy();   &#125;\n\nprivate基类全部成员在派生类都变成private成员\n虚继承\n避免多继承产生的二义性\n重点在于其调用顺序，一般很少用\n\nclass A &#123;    int a;public:     A(int x) &#123;        a=x;        cout&lt;&lt;&quot;Virtual Bass A...&quot;&lt;&lt;endl;     &#125;&#125;; class B:virtual public A &#123;public:     B(int i):A(i)&#123; cout&lt;&lt;&quot;Virtual Bass B...&quot;&lt;&lt;endl; &#125;&#125;;class C:virtual public A&#123;    int x;public:    C(int i):A(i)&#123;        cout&lt;&lt;&quot;Constructing C...&quot;&lt;&lt;endl;        x=i;     &#125;&#125;;class ABC:public C, public B &#123;public:     //虚基类由最终派生类初始化     ABC(int i,int j,int k):C(i),B(j),A(i) //这里必须对A进行初始化,然后根据声明顺序,对父类初始化        &#123; cout&lt;&lt;&quot;Constructing ABC...&quot;&lt;&lt;endl; &#125;&#125;; int main()&#123;    ABC obj(1,2,3);    return 0;&#125;/*Virtual Bass A...Constructing C... Virtual Bass B...Constructing ABC...*/\n\n构造顺序class A &#123;    int a;public:    A() &#123; cout &lt;&lt; &quot;Constructing A&quot; &lt;&lt; endl; &#125;&#125;;class B &#123;public:    B() &#123; cout &lt;&lt; &quot;Constructing B&quot; &lt;&lt; endl; &#125;&#125;;class B1 :virtual public B, virtual public A &#123;public:    B1(int i) &#123; cout &lt;&lt; &quot;Constructing B1&quot; &lt;&lt; endl; &#125;&#125;;class B2 :public A, virtual public B &#123; public:    B2(int j) &#123; cout &lt;&lt; &quot;Constructing B2&quot; &lt;&lt; endl; &#125;&#125;;class D : public B1, public B2 &#123;public:    D(int m, int n) : B1(m), B2(n) &#123; cout &lt;&lt; &quot;Constructing D&quot; &lt;&lt; endl; &#125;    A a;&#125;;int main() &#123;    D d(1, 2);    return 0;&#125;/*Constructing BConstructing AConstructing B1Constructing AConstructing B2Constructing AConstructing D*/\n\n\n虚基类由最后一个派生类初始化\n基类带实参，则派生类构造函数必须定义且带参数\n\n虚类指针VS2019下运行\nclass A &#123;public:\tvirtual void func() &#123;&#125;&#125;;//sizeof(B) = 8class B :virtual public A &#123;public:\tvirtual void func() &#123;&#125;&#125;;//sizeof(C) = 4class C : public A &#123;public:\tvoid func() &#123;&#125;&#125;;\n\n总结\n当有多个基类时，将按照它们在继承方式中的声明次序调用，与它们在构造函数初始化列表中的次序无关。当基类A本身又是另一个类B的派生类时，则先调用基类B的构造函数，再调用基类A的构造函数。\n当有多个对象成员时，将按它们在派生类中的声明次序调用，与它们在构造函数初始化列表中的次序无关。\n当构造函数初始化列表中的基类和对象成员的构造函数调用完成之后，才执行派生类构造函数体中的程序代码\n\n","categories":["C++"],"tags":["构造函数"]},{"title":"111","url":"/2022/03/07/C++/ARPG%E9%9D%A2%E8%AF%95Demo/","content":"ARPG面试DemoPLAINTEXT\n\n\n\n","categories":["C++"],"tags":["构造函数"]},{"title":"C++","url":"/2022/03/07/C++/C++/","content":"重载\n重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义不同\n\n当调用一个重载函数或重载运算符时，编译器通过把所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策\n\n编译的时候会对函数进行重命名，保证函数名的唯一性，而重载函数的参数不同，就会被命名为不同的函数名\n\n\n操作符重载class complex &#123;public:\tcomplex(double r = 0, double i = 0) :re(r), im(i)\t&#123;&#125;\tcomplex&amp; operator += (const complex&amp;);\tcomplex&amp; operator ++ ();\tcomplex&amp; operator ++ (int);\tdouble real() const &#123; return re; &#125;\tdouble imag() const &#123; return im; &#125;private:\tdouble re, im;&#125;;inlinecomplex&amp; complex::operator += (const complex&amp; r)&#123;\tthis-&gt;re += r.re;\tthis-&gt;im += r.im;\treturn *this;&#125;//为什么此处返回值可以不用引用，因为返回的是临时对象(temp object)inlinecomplex operator + (const complex&amp; x, const complex&amp; y)&#123;\treturn complex(x.real() + y.real(), x.imag() + y.imag()); //结束即死亡&#125;//参数不同，调用规则则不同inlinecomplex operator + (double x, const complex&amp; y)&#123;\treturn complex(x + y.real(), y.imag());&#125;\n\n\n成员函数都隐藏一个this指针，指向调用者。二元运算符重载为类的成员函数，参数只需一个，调用者本身使用this访问\n\ntypename();类型名加括号的形式：临时对象，没有对象名，一般很少用，标准库用得多，函数结束即死亡，如果使用引用，外界用到的则会出错\n\n一个好的函数，传递者不需要知道接受者以怎样的形式接受\n\n参数的传递尽量考虑引用，因为引用实际是个指针，在传递参数时会更加快\n\n考虑到连串使用，返回类型不能为void\n\n\n//前缀递增，直接返回结果值inlinecomplex&amp; complex::operator ++ ()&#123;\tthis-&gt;re++;\treturn *this;&#125;//后缀递增，返回递增前的值，int只是区分前后缀inlinecomplex&amp; complex::operator ++ (int)&#123;\tcomplex tmp = *this;\t++*this; //调用上面函数\treturn tmp;&#125;\n\n\n递增和递减一般是改变对象的状态，所以一般是重载为成员函数\n指针是内置类型，指针的递增递减是无法重载的\n\n//同上面+=一样，为满足连串使用，返回类型不能为voidostream&amp; operator &lt;&lt; (ostream&amp; os, const complex&amp; x)&#123;\treturn os &lt;&lt; &#x27;(&#x27; &lt;&lt; x.real() &lt;&lt; &#x27;,&#x27; &lt;&lt; x.imag() &lt;&lt; &#x27;)&#x27;;&#125;\n\n\nos就是cout，标准库写好的东西，暂时不管\n不能写成成员函数，因为它不认识新的类型\n每一次往cout放入东西时，它的状态都在改变，所以ostream不能加const\n\n函数重载构造函数重载提供不同的初始化方法\nclass Shape&#123;public:\tShape() //无参构造\t&#123;\t\tcout &lt;&lt; &quot;area:0&quot;;\t&#125;\tShape(int l,int w): length(l),width(w)\t&#123;\t\tcout &lt;&lt; &quot;square area:&quot;&lt;&lt;length * width;\t&#125;\tShape(int r) : radius(r)\t&#123;\t\tcout &lt;&lt; &quot;circular area:&quot;&lt;&lt; 3.14 * pow(radius,2);\t&#125;private:\tint length;\tint width;\tdouble radius;&#125;;int main()&#123;\tShape C;  //area:0\tShape A(3, 2);\t//square area:6\tShape B(2);  //circular area:12.56&#125;\n\n\n无参的构造函数是默认构造函数，一个类只能有一个默认构造函数\n尽管一个类可以包含多个构造函数，但是每一个对象都只执行其中一个\n析构函数不可以被重载，只能有一个，且不能带参数\n\n全局重载函数1void printf(double i) &#123;\tcout &lt;&lt; i;&#125;函数2void printf(int i)&#123;\tcout &lt;&lt; &quot;main&quot; &lt;&lt; i;&#125;int main()&#123;\tvoid printf(int i);     \tprintf(2.2); //调用函数2，作用域内的声明        short a  = 1;    printf(a); //根据匹配规则进行整数提升&#125;\n\n\n如果不在同一作用域，就不能算是函数重载\n\n隐藏派生类的函数屏蔽了与其同名的基类函数，只要同名函数，不管参数列表是否相同，基类函数都会被隐藏\nclass Base &#123;public:\tvoid func1(int i)\t&#123;\t\tcout &lt;&lt; &quot;Base::func1&quot; &lt;&lt; endl;\t&#125;    void func1(char&amp; i) &#123;&#125;&#125;;class Derived :public Base &#123;public:\tvoid func1(char&amp; i)\t&#123;\t\tcout &lt;&lt; i &lt;&lt; endl;\t\tcout &lt;&lt; &quot;Derived::func2&quot; &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tDerived dr;\tdr.func1(1); //编译出错，因为派生类隐藏了基类的同名函数\tdr.Base::func1(1); //通过域限定符::调用&#125;\n\n\n不论基类函数是否为virtual，只要派生类函数与其同名但不同参，基类函数将被隐藏\n\n基类函数非virtual，只要同名，不管是否同参，直接隐藏\n\n隐藏背后原因是为防止在程序库或应用框架内建立新的derived class时从疏远的base classes继承重载函数——《Effetive C++》\n\n\n\n重写（覆盖）派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰\nclass Base &#123;public:\tvirtual void func1(int i,int j)\t&#123;\t\tcout &lt;&lt; &quot;twoSum:&quot; &lt;&lt; i + j &lt;&lt; endl;\t&#125;&#125;;class Derived1 :public Base &#123;public:\tvoid func1(int i,int j)\t&#123;\t\t\tint max = i &gt; j ? i : j;\t\tcout &lt;&lt; &quot;MAX:&quot; &lt;&lt; max &lt;&lt; endl;\t&#125;&#125;;class Derived2 :public Base &#123;public:\tvoid func1(int i, int j)\t&#123;\t\tint min = i &gt; j ? j : i;\t\tcout &lt;&lt; &quot;MIN:&quot; &lt;&lt; min &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tDerived1 a;\ta.func1(10,200);\tDerived2 b;\tb.func1(10, 200);\ta.Base::func1(10, 200);&#125;\n\n\n子类的函数与父类的函数同名，并且参数列表也相同\n父类函数必须virtual关键字，否则将会被子类隐藏\n\n\n右值\n解决非必要的拷贝\n\n\n左值可以取地址，而右值没法取地址\n左值引用只能指向左值，右值引用只能指向右值\n\nint a = 3;int &amp;left = a; //左值引用只能指向左值//int &amp;left = 3; //errorleft = 6;//int &amp;&amp;right = a; //右值引用不能指向左值int &amp;&amp;right = 3;\n\n\nconst左值引用是可以指向右值的\n\nconst int &amp;left = 3; //OK\n\n\n左值引用右值引用其本身是一个左值\n\nvoid funLeft(int &amp; ref)&#123;&#125;void funRight(int &amp;&amp; ref)&#123;&#125;int main()&#123;    int a = 3;    int &amp;left = a;        int &amp;&amp;right = 5;        funLeft(3); //error,左值引用不能指向右值    funLeft(right)  //OK,左值引用指向左值         funRight(3); //OK,右值引用指向右值     funRight(left); //error    funRight(right); //error&#125;\n\n移动语义\n通过move把左值转为右值\n\nint a = 3;int &amp;&amp; right = move(a); //OKcout &lt;&lt; &amp;(move(a)); //errorright = 6;cout &lt;&lt; &amp;a &lt;&lt; &quot; &quot; &lt;&lt; a; //a的地址  a的值为6\n\n可以看到，move可以把a转为右值使得右值引用可以指向\nstring str = &quot;hello&quot;;string &amp;&amp; st = move(str);cout &lt;&lt; &amp;str &lt;&lt; str; //输出的字符串str为空\n\n\nmove返回的是一个右值\nmove底层通过static_cast转型，具体先不管\n可移动对象在 需要拷贝且被拷贝者之后不再被需要 的时候，使用move移动语义，提升性能\nmove本身只做类型转换，对性能无影响。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性\n\n\nforward可以转为右值也可以转为左值\n\nvoid funLeft(int &amp; ref)&#123;&#125;void funRight(int &amp;&amp; ref)&#123;&#125;int main()&#123;    int a = 3;        funLeft(forward&lt;int &amp;&gt;(a)); //转为左值        funRight(forward&lt;int &amp;&amp;&gt;(a)); //转为右值&#125;\n\n参考：\nhttps://zhuanlan.zhihu.com/p/335994370\n\n异常处理异常处理的思想\n\n当程序运行过程中，发现用户使用行为不当或者环境因素造成的计算无法继续，异常处理机制可以让我们的程序具有容错功能，此功能又不会干扰程序执行的主逻辑，可以选择就地处理，或抛出给调用者，这样就可以让不同的模块进行分工，有的模块做专门的主逻辑，有的模块做各种异常容错处理\n\n异常处理手法\nint divide(int x, int y)&#123;    if (y == 0)        throw x; //抛出给调用者    return x / y;&#125;int main()&#123;    try&#123; //有可能造成异常放在try里面        cout &lt;&lt; &quot;5 / 2 =&quot; &lt;&lt; divide(5,2) &lt;&lt; endl;        cout &lt;&lt; &quot;8 / 0 =&quot; &lt;&lt; divide(8,0) &lt;&lt; endl;        /*剩余语句*/  //不执行    &#125; catch (int e)&#123; //捕获异常        cout &lt;&lt; e &lt;&lt; &quot;is divided by zero!&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;That is ok.&quot; &lt;&lt; endl;&#125;\n\n异常接口声明\n可以在函数的声明中列出这个函数可能抛掷的所有异常类型\n\n```c++void fun() throw(A,B,C,D);\n* 若无异常接口声明，则此函数可以抛掷任何类型的异常* 不抛掷任何类型异常的函数声明如下：  ```c++  void fun() throw(); \n\n自动的析构找到一个匹配的catch异常处理后\n\n初始化异常参数\n将从对应的try块开始到异常被抛掷处之间构造（且尚未析构）的所有对象进行析构\n从最后一个catch处理之后开始恢复执行 \n\n先抛出异常，再析构子函数中的局部对象\n标准程序库异常处理标准异常类的继承关系\n\n\n","categories":["C++"],"tags":["异常处理","左值右值","重载"]},{"title":"C++语法","url":"/2022/03/07/C++/C++%E8%AF%AD%E6%B3%95/","content":"const\n要在其他文件使用变量，加extern\nconst必须初始化，类中不能初始化，类中只能通过构造函数\n对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)\n对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &amp;x)\nconst对象只能访问const成员函数\n有些地方不加const编译不过\n\n\nstatic\n在类对象实例化之前就已分配了空间，并且只分配一次\n\n\nstatic静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化\n类中的静态变量由对象共享。对于不同的对象，不能有相同静态变量的多个副本\n静态对象的范围是贯穿程序的生命周期\n允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数\n\n\ninline\n内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率\n如果函数体内代码较长（增加内存消耗）或者出现循环（效率减少），那么不宜用内联\n\n\nsizeof\n静态成员不影响类大小。\n\nclass A &#123;public:\tchar e;\tvirtual void funA() &#123;&#125;;\tstatic int c;\tstatic int a;&#125;;//一个虚指针 + 一个字符型，内存对齐，大小为8\n\n\n类的数据成员按其声明顺序加入内存（字节对齐）\n返回值类型为size_t，\nsize_t类型是一个类型定义，通常将一些无符号的整形定义为size_t，比如说unsigned int或者unsigned long，甚至unsigned long long\n\n\npure virtual\n抽象类至少包含一个纯虚函数\n不能创建抽象类对象，可以通过抽象类的指针或引用访问派生类对象\n如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类\n\n\nvptr_vtable\n每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数\n\nvptr在创建类实例时自动设置，以便指向该类的虚拟表\n\n```c++Base *p = new Drived;p-&gt;func();\n   * 首先识别func()是个虚函数   * 其次用p的vptr来获取Drived的虚表   * 查找虚表中调用的是哪个版本的func()，此处调用的是Drived::func()---### virtual1. 虚函数是动态绑定的，默认参数是静态绑定的。默认参数的使用需要看**指针或者应用本身的类型**，而不是**对象的类型**，这与虚函数的调用机制相反```c++class A&#123;public:    virtual void func(int i = 10)&#123;&#125;&#123;        cout &lt;&lt; i &lt;&lt; &quot;A::func()&quot;;    &#125;&#125;;class B:public A&#123;public:    virtual void func(int i = 20)&#123;        cout &lt;&lt; i &lt;&lt; &quot;B::func()&quot;;    &#125;&#125;;int main()&#123;    A *p = new B;    p-&gt;func(); // i= 10，B::func()&#125;\nstatic成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的\n\n静态成员函数没有this指针。所以无法访问vptr，进而不能访问虚函数表\n\n构造函数不能是虚函数，而析构函数必须是虚析构函数（父类指针指向子类对象，因为是虚函数，编译器会忽略指针的类型，而根据指针的指向来选择函数，先调用子类，在调用父类）\n\n唯一可以内联的时候是：编译器知道所调用的对象是哪个类 Base::func()\n\n\n\nassert\nASSERT ()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0),  程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误\n\n\nextern “C”\n因为C++与C的编译区别，C++调用C函数时应该加上extern “C”\n\n#include &lt;iostream&gt;using namespace std;extern &quot;C&quot; &#123;    #include &quot;add.h&quot;&#125;int main() &#123;    add();&#125;\n\n\nstruct\n\n\nC\nC++\n\n\n\n不能将函数放在结构体声明\n能将函数放在结构体声明\n\n\n在C结构体声明中不能使用C++访问修饰符。\npublic、protected、private 在C++中可以使用。\n\n\n在C中定义结构体变量，如果使用了下面定义必须加struct。\n可以不加struct\n\n\n结构体不能继承（没有这一概念）。\n可以继承\n\n\n若结构体的名字与函数名相同，可以正常运行且正常的调用！\n若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！\n\n\nstruct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体\n\nunionunion Data&#123;    Data(int i = 5):i(i)&#123;&#125; //可以有构造和析构函数    int i;    float j;    char s;    void func() &#123;&#125; //不可以有虚函数&#125;int main()&#123;    union Data data;   \tdata.i = 10;    data.j = 2.5;    cout &lt;&lt; data.j &lt;&lt; data.i; //i的值会被损坏    data.s = &#x27;A&#x27;;    cout &lt;&lt; data.s;&#125;//sizeof(data) = 4; //最大变量的大小\n\n但是任何时候只能有一个成员带有值\n\nfriend\n友元函数：普通函数可以访问某个类中的私有或保护成员\n友元类：类A声明friend类B，类B可以访问类A的私有或保护成员（单向）\n友元关系不可传递\n\n\n优点：提高了程序的运行效率\n缺点：破坏了类的封装性和数据的透明性\n\n\nusing改变访问性：\nclass Base&#123;public: std::size_t size() const &#123; return n;  &#125;protected: std::size_t n;&#125;;class Derived : private Base &#123;public: using Base::size;protected: using Base::n;&#125;;\n\n取代typedef：\ntypedef vector&lt;int&gt; V1; using V2 = vector&lt;int&gt;;\n\n\nenum枚举类：\n//enum class Color2:int //前向声明enum class Color2&#123;    RED=2,    YELLOW,    BLUE&#125;;r2 c2 = Color2::RED;cout &lt;&lt; static_cast&lt;int&gt;(c2) &lt;&lt; endl; //必须转！\n\n怎样在类中建立整个类中永恒的常量：\nclass Person&#123;public:    typedef enum &#123;        BOY = 0,        GIRL    &#125;SexType;&#125;;//访问的时候通过，Person::BOY或者Person::GIRL来进行访问。//sizeof(Person) = 1\n\n\n在类中不会占用空间，在编译时被全部求值\n隐含类型是整数，最大值有限\n\n\ndecltypedecltype(expression) //返回该表达式类型\n\n与using/typedef合用\nusing size_t = decltype(sizeof(0));//sizeof(a)的返回值为size_t类型using ptrdiff_t = decltype((int*)0 - (int*)0);using nullptr_t = decltype(nullptr);vector&lt;int &gt;vec;typedef decltype(vec.begin()) vectype;for (vectype i = vec.begin; i != vec.end(); i++)&#123;//...&#125;\n\n\ntypeid获取类型信息\n#include&lt;typeinfo&gt;//typeid(dataType)//typeid(expression)int main()&#123;    int n = 100;    const type_info &amp;nInfo = typeid(n);    cout &lt;&lt; nInfo.name() &lt;&lt; nInfo.raw_name() &lt;&lt; nInfo.hash_code();&#125;\n\n\n操作数可以是普通变量、对象、内置类型（int、float等）、自定义类型（结构体和类），还可以是一个表达式\n返回type_info对象的引用\n\n&amp;_ptr\n\n\n引用\n指针\n\n\n\n必须初始化\n可以不初始化\n\n\n不能为空\n可以为空\n\n\n不能更换目标\n可以更换目标\n\n\n只能有一级\n可以有多级指针\n\n\nvector&lt;int&gt; v(10);v[5] = 10;    //[]操作符返回引用，然后vector对应元素才能被修改              //如果[]操作符不返回引用而是指针的话，赋值语句则需要这样写*v[5] = 10;   //这种书写方式，完全不符合我们对[]调用的认知，容易产生误解\n\n\n右值引用：\n\n\n消除两个对象交互时不必要的拷贝，节省运算存储资源，提高效率\n能够更间接明确地定义泛型函数\n\n\nC++编译器在编译程序的时候将指针和引用编译成了完全一样的机器码。所以C++中的引用只是C++对指针操作的一个“语法糖”，在底层实现时C++编译器实现这两种操作的方法完全相同\n\ndefinedefine这是简单的字符串替换\n\n字符串化操作符（#）\n\n\n在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组，换言之就是：**#是“字符串化”的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串**\n\n#define func(s) cout&lt;&lt; s&lt;&lt; endl;#define func1(s) cout &lt;&lt; #s&lt;&lt; endl;#define str(a) #a\n\n\n符号连接符（##）\n\n\n“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。将宏定义的多个形参转换成一个实际参数\n连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义\n如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开\n\n#define expA(s) cout &lt;&lt; a##s &lt;&lt;endl;#define expB(s) cout &lt;&lt; gc_ ## s &lt;&lt; endl;#define expC(s,e) cout &lt;&lt; ab##s##e &lt;&lt;endl;#define gc_hello1 &quot;I am gc_hello1&quot;#define abcd &quot;world&quot;int main() &#123;    const char* ahello = &quot;I am gc_hello&quot;;    expA(hello);    expB(hello1);    expC(c,d);&#125;\n\n\n续行操作符（\\）\n\n\n当定义的宏不能用一行表达完整时，可以用”\\”表示下一行继续此宏的定义\n\n\n与typedef比较：\n\n#define PIONTER int*PIONTER a,b; //等同于int* a,b;typedef int* POINTER1POINTER1 c,d;//等同于int *c;int *d;\n\noverride\n可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错\n\n用于检查自己重写的函数，是否条件正确\n\n\nfinal\n 第一个用在类，用于说明该类是继承体系下最后的一个类，不要其他类继承我，当继承时就会报错\n第二个用在虚函数，表示这个虚函数不能再被override了，再override就会报错\n\n","categories":["C++"]},{"title":"linux下使用jsoncpp","url":"/2022/06/02/C++/linux%E4%B8%8B%E4%BD%BF%E7%94%A8jsoncpp/","content":"linux下使用jsoncppwindows安装配置流程：\nhttps://subingwen.cn/cpp/jsoncpp/\n因为是用vs远程在linux进行开发，所以windows下要\n\n没有这个的话，编译器找不到头文件会报错\nlinux下安装jsoncpp：https://blog.csdn.net/qq_31082639/article/details/121581087\n安装CMake对jsoncpp源文件进行编译\n安装CMake：\nhttps://blog.csdn.net/linsenaa/article/details/104629724?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-104629724-blog-122048869.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-104629724-blog-122048869.pc_relevant_default&amp;utm_relevant_index=1\nCmake编译jsoncpp\n遇到的问题：\ng++编译器过老，没办法识别c++11的特性，\n升级编译器 https://blog.csdn.net/chen134225/article/details/109856696\n\n完了在项目文件下放 include和libjson.a \n\n直接编译后果：\n\n正确姿势：\n\n","categories":["C++"],"tags":["json"]},{"title":"new和malloc","url":"/2022/03/07/C++/new%E5%92%8Cmalloc/","content":"new和mallocclass complex &#123;public:\tcomplex(double r = 0, double i = 0) :re(r), im(i)\t&#123;&#125;\tdouble real() const &#123; return re; &#125;\tdouble imag() const &#123; return im; &#125;    ~complex()\t&#123;\t\tcout &lt;&lt; &quot;call dtor to delete&quot; &lt;&lt; endl;\t&#125;private:\tdouble re, im;&#125;;int main()&#123;\tcomplex* p = new complex;\tcout &lt;&lt; p-&gt;real() &lt;&lt; p-&gt;imag() &lt;&lt; endl;    \tcomplex* q = (complex*)malloc(sizeof(complex)); //指定大小，并强制转换\tcout &lt;&lt; q-&gt;real() &lt;&lt; q-&gt;imag();    \tdelete p; \tfree(q); &#125;\n\n\n构造/析构的调用new在申请空间的时候会调用构造函数，malloc不会调用，释放时new也会调用析构函数，而free不会\n是否指定内存大小new无需指定内存块大小，编译器会根据类型自行计算，而malloc需要显示的指出所需内存大小\ncomplex* q = (complex*)malloc(sizeof(1));\n\n上述做法是可以通过编译的，但是…\n返回类型new分配成功时，返回的是对象类型的指针，无须进行类型转换，故new是符合类型安全的操作符，而malloc返回的是void*，需要通过强制类型转换成所需类型\n分配失败的返回值new分配失败时，会抛出bad_alloc异常，而不会像malloc一样返回NULL\nint* q  = (int*)malloc (sizeof (int));if(NULL == a)&#123;    ...&#125;else &#123;    ...&#125;try&#123;    int* a = new int();&#125;catch (bad_alloc)&#123;    ...&#125;\n\n动态分配内存块\n上图分别为debug和release下的情况，灰色则是debug操作下所需的空间\ncookie记录分配到的空间所占大小，以16进制表示\n实际分配的大小比类的大小大得多\n对数组的处理\n如果数组delete不写[]，编译器不知道需要删除的是数组，红色框中仍然删除，但是只调用一次析构，那么数组内指针所指向空间则只删除一个，剩下的则会导致内存泄漏\n\n","categories":["C++"],"tags":["new","malloc","内存"]},{"title":"ARPGDemo","url":"/2022/07/13/Game/ARPGDemo/","content":"面试Demo\n\n\n\n项目概括\n实现了背包，任务，NPC，商店，战斗等RPG游戏常见功能性系统\n\n玩家可以在游戏中NPC处领取任务，副本里击杀敌人完成任务并领取任务奖励，获得更高级的装备后，攻克更高级的副本\n\n游戏一大特点是实现了一些传统RPG所不具备的技能系统，玩家可以根据武器的选择，释放不同的技能，每个技能都拥有自己的特点，如自动索敌，增加状态BUFF，群体攻击等。\n\n游戏实现了脚本，资源的热更新并支持跨平台的数据传输\n\n\n开发工具VS2019，VSCode，Unity2021，Linux，Github，xLua，DoTween\n部分系统概括背包支持物品的分类，拖拽，装备，交易等\n\n背包是跟物品绑定的\n每个物品会有对应的数据类，并且会在物品预制体上挂载实例类和一个拖拽功能的类，实例类会设置自己所对应物品数据，会做一些拖拽的响应事件，一些动画的效果。\n背包的话，通过格子的复用，脚本对外开放设置物品方法，在Toggle组改变的时候，清空所有格子对应的物品，再根据物品类型重新设置对应物品，达到一个分类的功能；并且格子还实现鼠标进入离开点击这几个UI接口方法，实现显示物品信息，或者点击物品显示对应的方法，像使用，卖出，丢弃。\n装备栏的话他也是一个格子，为了达到装备栏与物品类型的匹配，格子也会有属于自己的类型，通过类型判断是否装备物品；拖拽到相应格子，则会进行逻辑判断，如增加角色状态\n通过格子类，进行游戏物品的挂载，更加灵活和复用\n通过实现UGUI接口方法，UI的拖拽装备等复杂性问题很好的得到了解决\n\n任务与NPC支持任务自动寻路至NPC，NPC对话内容随任务状态而改变，任务完成后的子任务解锁等\n\n三个ID：\n任务ID，NPC自身ID，对话内容ID\n对话内容由NpcID和任务状态得到对应的对话内容ID\n\n\n每个任务会有各自任务实例Item类，主要是接收任务响应事件，判断任务进度，和领取任务奖励\n在玩家找NPC接受任务后，会调用管理类里面的添加任务方法，根据接受的任务ID通过反射去创建所对应的任务实例，加入到正在进行中的列表里面，这样的话就成功的接收了一个任务，任务实例就可以接收任务事件的响应，进行进度的更新，并且判断是否完成等\n完成任务后，这些任务响应的事件也会相应的注销掉，并且任务的状态也会改变，我们就可以领取奖励，那么就会调用管理类里面的移除方法，把该任务从玩家所领取的任务表中移除掉，并且，调用加入物品的方法，把奖励物品加入玩家背包，一些有后继解锁任务的，则会在此时解锁对应任务\n通过各个ID，完美的根据任务状态实现不同对话内容，只需配置好对应的ID，无需添加代码即实现添加新内容\n反射动态动态创建所需任务，更加降低了耦合，提高了程序的灵活性和扩展性\n通过事件的传递，发送方以及任务实例的接收方，都无法获得得知对方是谁，更好的实现程序的封装性，解除耦合\n\n技能支持，跟随武器切换当前技能，释放技能特效，技能UI等\n\n每个技能有对应的技能脚本\n通过技能系统类和技能管理类完成技能的调度，释放技能游戏对象，接受动画事件，处理技能冷却等\n技能系统会根据玩家的输入和当前的武器，去得到所对应技能ID，通知技能管理类准备技能，成功后则会根据技能数据里的动画名称，播放对应动画，并且在动画播放后，会在我们所需要发出的时间点接收到动画事件所发出的事件通知，然后通知管理类释放技能游戏对象\n技能游戏物体的重置，则会对游戏物体当前的位置，旋转，攻击力等进行重置，并且向目标移动而去。增加状态，判断敌人距离等技能逻辑则会对应的在此处去实现\n大部分技能都是做成一个触发器，通过OnTrigger来判断是否击中敌人，可以通过OnTrigger的方法参数去调用敌人身上受到伤害的方法\n外部通过系统类触发技能的使用，更好的实现对技能管理这个主要处理技能释放逻辑类的封装\n技能通过重置接口以便外部调用，实现不同技能的重置方法多态性\n增加新技能，只需添加预制体，和技能对应脚本，就可很方便的完成对新技能的扩展\n\n状态机对 群体AI堵塞 的解决\n总结\nUI并没有使用一些常见的UI框架（MVC，MVVM，ECS等），导致后期功能有限，扩展不易\n设计模式运用较少\n部分Bug未解决，例如：\n跳跃进入传送门，导致动画播放的是跳跃动画，而直接加载场景，在第二场景就会一直处于跳跃动画\n解决思路：直接在每次进入场景后，重置动画状态机条件变量\n\n\nBoss状态机随着状态的增多，开始变得繁琐，逻辑复杂，导致一堆莫名其妙的BUG，而耗费太多精力来解决\n是状态机的有限性，和难于扩展\n像Boss这种AI，因为状态数量较多，更应该使用行为树来做\n\n\nlua这块，没有使用像MD5（主要是还没学）来确保信息的完整一致，而是用土方法进行大量的判断\n\n\n总体整个Demo的最终呈现效果其实自己并不太满意，但是因为时间和能力的关系，短期内并无法达到一个质的提升，遂就此罢休，待以后技术进步，会去实现更多自己想要的东西\n\n","categories":["Game"],"tags":["ARPG"]},{"title":"AlgorithmVisualization","url":"/2022/07/13/Game/AlgorithmVisualization/","content":"常用算法的可视化，学习和改进中\n源码\n\n\n\n功能动态生成节点数量，洗牌打乱，根据不同算法，执行相关逻辑\n可一键排序也可以观察算法的执行过程，实时显示算法执行时间\n照相机移动：右键，滚轮，上下左右，和开发时的Scene窗口上移动差不多的方式\n程序\nSortHelper类中用协程完成节点位置相关的功能，包括洗牌的重置，树节点的颜色变化；这个类暂时没有引用其他任何类，所以代码较其他类更多，也有一些冗余，是整个程序被引用最多的类\n在比较大小方面，用字典key存储每个物体的Transform，int存对应的数值。其实也可以直接比较Transform的Y轴缩放大小，因为生成的时候就是对Y轴缩放做了改变\n每个算法都继承了BaseAlgorithm抽象类，必须实现排序功能；声明完成排序时的事件，外部进行添加和删除，内部调用；声明了计时器功能，用于一键排序时计入代码执行时间\n一键排序的计时，在游戏开始后第一次执行总是会慢很多，这是因为JIT的机制，第一次执行时会进行编译\n\n\n树节点的生成会根据树高自动判断每个节点位置。其实就是把最后一排的间距定义死，在往上推出每一层的节点间距\nUnity下拉框的Bug，下拉菜单弹出时，首选项是被选中状态，当点击首选项的时候永远不会调用首选项的方法\n网上查了下，就是重写Dropdown，在每次显示时，再对Toggle的事件进行重新添加监听\n感觉这样也很麻烦，而且Dropdown每次show和hide的时候就是把菜单从场景中删除和再生成，不太懂为什么这样做\n\n\n\n","categories":["Game"]},{"title":"Git基本操作","url":"/2022/07/11/Git/git%E6%93%8D%E4%BD%9C/","content":"Git在本地环境的使用本地初始化一个Git仓库本地新建文件夹，用作Git的本地仓库，并创建新文件\n初始化仓库：文件夹下git bash here，键入\ngit init\n\n\n本地查看本地仓库的状态git status\n\n\n状态信息：\nOn branch master 表示仓库默认在master分支下\nUntracked files 表示 Test.md 这个文件还没有被跟踪，并没有提交到git仓库里。\n添加文件到Git暂存区git add 文件名\n\n\n\nChanges to be committed表示test.markdown这个文件等待被提交，当然你可以使用\ngit rm --cached 文件名\n\n移除这个缓存\n提交暂存区里的文件git commit -m &#x27;提交信息&#x27;\n\n\n-m参数用于指定 commit 信息，是必需的。如果省略-m参数，git commit会自动打开文本编辑器，要求输入\n再次查看仓库状态\n\n\ngit add是先把改动添加到一个 暂存区 ，可以理解为一个缓存区域，临时保存我们的改动，而git commit才是最后真正的提交，这样做的好处就是防止误提交\n\n查看loggit log\n\n\ngit log可以查看所有产生的commit记录，可以看到我们这次添加的版号，发起人，时间，和提交信息First Commit\n分支的查看、添加与切换branch即分支的意思。在一个项目里，两个人负责不同的模块，就创建两个分支。两个人分别在各自的分支里对代码进行的改动，互相独立，互不影响。等到最后两个人的模块都完成了，再统一把分支合并起来。\n查看分支\ngit branch\n\n\n我们有一个默认的master分支，前面的*号表示master是我们当前使用的分支。注意，当我们的Git仓库没有任何提交的话，直接查看分支情况会出现什么都没有的情况\n添加分支\ngit branch 分支名\n\n\n新建分支的命令是基于当前所在分支的基础上进行的，即以上是基于master分支新建了一个叫做cjj的分支，此时cjj分支跟master分支的内容完全一 样。如果你有 A、B、C三个分支，三个分支是三位同学的，各分支内容不一样，如果你当前 是在 B 分支，如果执行新建分支命令，则新建的分支内容跟 B 分支是一样的，同理如果当前 所在是 C 分支，那就是基于 C 分支基础上新建的分支\n可以看到新建分支后，我们仍然在master分支上\n切换分支\ngit checkout 分支名\n\n\n一条龙\ngit checkout -b 分支名\n\n使用这条命令，直接新建分支并切换\n\n分支的合并与删除分支合并就是字面意思，当项目需要模块集成时就需要把各个分支合并到master这个主分支里面来。\n在分支上提交新的文件\n\n合并\n合并分支前，要确保当前的分支是master，所以第一步就是切换到master这个主分支\ngit checkout mastergit merge 分支名\n\n\n现在，cjj这个分支已经被合并到主分支了，所以已经没用了，可以将其删除\ngit branch -d 分支名git branch -D 分支名\n\n上面两个命令选一个就可以，区别在于-D为强制删除，因为cjj分支里面的代码可能还没有合并到master，使用-d是删除不了的，\n\n添加标签\nGit有commit，为什么还要引入tag？\n“请把上周一的那个版本打包发布，commit号是6a5819e…”\n“一串乱七八糟的数字不好找！”\n如果换一个办法：\n“请把上周一的那个版本打包发布，版本号是v1.2”\n“好的，按照tag v1.2查找commit就行！”\n所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\n\n新建标签并查看\ngit tag git show\n\n\n删除标签\ngit tag -d \n\n向Github提交代码关联Github仓库现在，我们已经在本地创建了一个Git仓库，又想在Github创建一个远程仓库，并且让两个参股进行远程同步，这样，Github上的仓库既可以作为备份，又可以让其他人通过仓库来协作\n在Github创建完仓库后，进入本地要关联的本地仓库，键入\ngit remote add origin git@github.com:Github名称/仓库名.git\n\n\n将本地资源更新到Githubgit push origin master\n\n其中，远程库的名字就是origin，这是Git默认的也是大家公认的叫法，当然你也可以自己取个名字。master指的是在本地的master分支。\n所以这条命令的意思就是把本地Git仓库的master分支，推送到Github中与本地Git仓库关联的Github仓库中\n\n这时，就可以在远程Github查看我们推送的内容。但是，需要选择master分支\n\n从Github更新资源到本地如果别人提交代码到远程仓库，这个时候你需要把远程仓库的最新代码拉下来，然后保证两端代码的同步\ngit pull origin master\n\n\n一般我们在push之前都会先pull ，这样不容易冲突。\n克隆克隆可以理解为高级点的复制。将一个项目从Github克隆到本地，那么该项目在本地就已经是一个Git仓库了，不需要使用git init进行初始化，而且都已经关联好了远程仓库，我们只需要在本地的项目目录下任意修改或者添加文件，然后进行commit，之后就可以执行git pull origin master等相关操作。\n复制链接\n\ngit clone 链接\n\n版本控制\n撤销工作区假设我们在一个分支开发 一个小功能，刚写完一半，这时候需求变了，而且是大变化，之前写的代码完全用不了了，好在你刚写，甚至都没有 git add 进暂存区，这个时候很简单的一个操作就直接把原文件还原\ngit checkout 文件名\n\nTest.md原内容\n\n执行命令\n\n结果 Test.md的内容全部撤销\n\n暂存区将我们所需要的文件add至暂存区后，发现有需要更改的地方，可以直接在工作区修改完后，再次进行add\n但此时，又遇到了需求大变化：\n\n一种是代码完全用不了，可以像情况一一样执行git checkout\n一种代码保留，但是暂存区的内容不再需要，那么就\n\ngit reset 文件名git reset\n\n\n本地仓库在这个地方，我们的许多操作都会跟git版本指针有关\ngit log查看提交日志\n\n此时，指针HEAD指向\ngit reset --soft HEAD^\n\n撤销commit至暂存区，代码仍然保留\n\n--soft参数用于回退到某个版本\n也可以使用\ngit reset HEAD^\n\n直接撤销至工作区\nHEAD^表示上一个版本，HEAD^^上上个版本，HEAD^^^上上上个版本。。。依次类推\nHEAD~0当前版本，HEAD~1上个版本。。。以此类推\n上述操作都不会更改已写好的代码，但是如果使用\ngit reset --hard HEAD^\n\n那么，工作区的代码就会回到指定版本\n版本切换git log查看已提交版本\n\n得到版本的SHA\ngit checkout 版本的SHA\n\n\n当前指针指向指定版本，并且本地代码回退到指定版本，代码发生了改变：\n\n键入版本的SHA时，可以只键入前几个字符，就可以切换到指定版本（最少4位）\n技巧对比文件差异我们经常在做代码改动，但是有的时候2天前的代码了，做了哪些改动都忘记了，在提交之前需要确认下，这个时候就可以用diff来查看你到底做了哪些改动。直接输入git diff只能比较当前文件和暂存区文件差异。\n此时往Test.md这个文件添加一行字”HELLO GIHUB“，然后执行git diff。我们会发现终端给出的信息是绿色的”+“号，然后后面跟着”HELLO GIHUB“，由此我们可知绿色加号表示的是增加的内容。\n接着我们继续修改这个文件。我们先删除第一次添加的”HELLO GIHUB“，然后敲入”HELLO UNITY“，并再次执行git diff。我们会发现增加的”HELLO UNITY“显示出来了，但是我们删除的”HELLO GIHUB“并没有显示。这是因为我们并没有执行git add将文件放入暂存区\n\n我们先将文件加入暂存区，然后将里面的”HELLO UNITY“删除，接着添加”HELLO HELLO“。这次我们再git diff就会发现，添加和删除的改动同时给了我们提示。没错，相对应地，绿色”+“号为增加，红色”-“号为删除。\n\n临时保存代码设想一个场景，假设我们正在一个新的分支做新的功能，这个时候突然有一个紧急的bug需要 修复，而且修复完之后需要立即发布。当然你说我先把刚写的一点代码进行提交不就行了 么？这样理论上当然是ok的，但是这会产品垃圾commit，原则上我们每次的commit都要有实际的意义，你的代码只是刚写了一半，还没有什么实际的意义是不建议就这样commit的，那 么有没有一种比较好的办法，可以让我暂时切到别的分支，修复完bug再切回来，而且代码也 能保留的呢？\n这个时候 stash 命令就大有用处了，前提是我们的代码没有进行commit ，哪怕你执行了add也没关系\n保存当前分支代码\ngit stash\n\n意思就是把当前分支所有没有commit的代码先暂存起来，这个时候你再执行git status你会发现当前分支很干净，几乎看不到任何改动，你的代码改动也看不见了，但其实是暂存起来了\n这时就可放心切换分支到其他分支操作\n查询保存记录\ngit stash list\n\n还原代码\ngit stash apply\n\n之前的代码全部又回来了，就好像一切都没发生过一样\n删除记录\n切换回来后，删除最近的stash记录\n后面可以跟stash_id参数来删除指定的某条记录\ngit stash drop\n\n还原并删除记录\ngit stash pop\n\n清空记录\ngit stash clear\n\n给命令起别名类似using指令的alias命令\n给命令起个别名。我们每次都输入git push origin master就很繁琐，要是我们给这条命令起个别名，比如git pom，那我们就可以直接使用git pom来代替git push origin master\ngit config --global alias.别名 &#x27;命令&#x27;\n\n\n参考https://www.runoob.com/git/git-tutorial.html\nhttps://www.bookstack.cn/read/git-tutorial/docs-commands-git-tag.md\nhttps://git-scm.com/book/zh/v2\n","categories":["Git"],"tags":["git","github"]},{"title":"167.两数之和II - 输入有序数组","url":"/2022/05/01/LeetCode/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII---%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"双指针class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;        int left = 0,right = numbers.size() - 1;        while (left &lt;= right)&#123;            int tmp = numbers[left] + numbers[right];            if (tmp &lt; target)                left++;            else if (tmp &gt; target)                right--;            else                 return &#123;left + 1,right + 1&#125;;        &#125;        return &#123;&#125;;    &#125;&#125;;\n\n思路利用数组顺序排列的条件，双指针从两遍向中间遍历，两指针的数相加和目标值做比较，根据大小，移动其中一指针，最后得到解\n","categories":["LeetCode"],"tags":["双指针"]},{"title":"七进制数","url":"/2022/03/07/LeetCode/%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/","content":"十进制转x进制class Solution &#123;public:    string convertToBase7(int num) &#123;        // 不断除7，取余，直到num为0        string str;        string res;        if (num == 0) return &quot;0&quot;;        if (num &gt; 0)&#123;            while (num != 0)&#123;                res = to_string(num % 7);                str.insert(0,res);       \t\t\tnum = num / 7;            &#125;        &#125;        if (num &lt; 0)&#123;            while (num != 0)&#123;            res = to_string(-(num % 7));            str.insert(0,res);            num = num / 7;            &#125;            str.insert(0,&quot;-&quot;);        &#125;        return str;    &#125;&#125;;\n\n思路就是十进制转任何进制的模板，结果反向取余即可\n负数可以跟正数放在一起处理，直接abs(num)拿绝对值\n注意字符串的插入操作，先转型\n","categories":["LeetCode"]},{"title":"两个列表的最小索引总和","url":"/2022/03/14/LeetCode/%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/","content":"哈希表class Solution &#123;public:    vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) &#123;        unordered_map&lt;string,int&gt; table;        vector&lt;string&gt; res;        for (int i = 0;i &lt; list1.size();i++)&#123;            table[list1[i]] = i;        &#125;        int min = list1.size() + list2.size();        for (int j = 0;j &lt; list2.size();j++)&#123;            auto it = table.find(list2[j]);            if (it != table.end())&#123;                if (min &gt; j + it-&gt;second)&#123;                        res.resize(0); //res.clear();                        res.insert(res.begin(),it-&gt;first);                        min = j + it-&gt;second;                &#125; else if (min == j + it-&gt;second)&#123;                    res.push_back(it-&gt;first);                &#125;            &#125;        &#125;        return res;    &#125;&#125;;\n\n思路先将list1记录到哈希表中，再遍历list2，如果存在表中存在list2的元素，就把索引之和与最小索引和做比较\n比先前的索引和小，则把数组清空，把这个餐厅加入结果。清空数组是因为前面可能出现了多个相同索引和的餐厅，但都不是最小的\n因为答案不止一个，那么等于最小索引和的餐厅也应该加入结果\n","categories":["LeetCode"],"tags":["哈希表"]},{"title":"三数之和","url":"/2022/03/09/LeetCode/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"排序+双指针class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;vector&lt;int&gt;&gt; res;        int len = nums.size();        if (len &lt; 3) return res;        sort(nums.begin(),nums.end());        int i = 0;        while (i &lt; len)&#123;            if (nums[i] &gt; 0) break; //当i大于0，则后续不会再有三数和等于0了            int left = i + 1,right = len - 1;            while (left &lt; right)&#123;                 //防止溢出                long long y = static_cast&lt;long long&gt;(nums[i]);                long long x = static_cast&lt;long long&gt;(nums[left]);                long long z = static_cast&lt;long long&gt;(nums[right]);                if (x + y &gt; 0 - z) //right太大，向前移动                    right--;                else if (x + y &lt; 0 - z) //left太小，向后移动                    left++;                else&#123;                    res.push_back(&#123;nums[i],nums[left],nums[right]&#125;);                    //跳过重复元素                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1])                        left++;                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1])                        right--;                    left++;                    right--;                &#125;            &#125;            while (i + 1 &lt; len &amp;&amp; nums[i] == nums[i + 1])                i++;            i++;        &#125;        return res;    &#125;&#125;;\n\n思路第一重循环保持一个不动的数，第二重循环左右指针遍历数组寻找三数和\n每次循环判断三数和大于或小于0，大于0，则选择较小的数再进行判断，小于0则相反\n当a + b + c = 0且不能出现重复，那么必定要有两个数值发生变化，所以左右指针都需跳过重复元素，寻找新的三数和\n当排好序的数组剩余元素都为正数时，直接返回\n","categories":["LeetCode"]},{"title":"两数之和","url":"/2022/02/11/LeetCode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"暴力法class Solution &#123;    public:        vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;int&gt; s;        for( int i = 0;i &lt; nums.size()-1;i++ )            for( int j = i + 1;j &lt; nums.size();j++ )                if( target == nums[i] + nums[j])&#123;                    s.push_back(i);                    s.push_back(j);                    return s;    &#125;        return s;&#125;&#125;;\n\n哈希表class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        unordered_map&lt;int,int&gt; res;        for (int i = 0;i &lt; nums.size();i++)&#123;            auto it = res.find(target - nums[i]);  //寻找表里key是否有所需元素            if (it != res.end())&#123;                  return  &#123;it-&gt;second,i&#125;;            &#125;            res[nums[i]] = i; //没找到则把下标作为value写入表        &#125;          return &#123;&#125;;    &#125;&#125;;\n\n思路以 target - nums[i] 的方式寻找元素 x 是否存在表中，不存在则把 nums[i] 作为key值写入，以便后续查找，查找范围则是下标 i 的前向元素，若target为两个相同元素之和，此时直接返回两个下标，也不会出现重复情况\n","categories":["LeetCode"],"tags":["哈希表"]},{"title":"买卖股票的最佳时机","url":"/2022/03/06/LeetCode/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","content":"一次遍历class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        if (prices.size() &lt;= 1) return 0;        int maxPro = 0;        int minPri = prices[0];        for (int i = 1;i &lt; prices.size();i++)&#123;            maxPro = max(maxPro,prices[i] - minPri); // 今天卖出是否为最大利润            minPri = min(minPri,prices[i]);  // 今天是否为最低价格，是则记下，用作后面比对        &#125;        return maxPro;    &#125;&#125;;\n\n思路对每一天的卖出利润进行比较，选出最大利润，并查看当天是否为最低价格，是的话则记录，后续用于比对最大利润，这样就可以满足最大值始终处于最小值的右侧\n","categories":["LeetCode"]},{"title":"二叉树的中序遍历","url":"/2022/04/03/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"左孩子 —&gt; 根节点 —&gt; 右孩子 \n\n递归class Solution &#123;public:    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        middleTraverse(root,res);        return res;    &#125;    void middleTraverse(TreeNode* root,vector&lt;int&gt;&amp; res)&#123;        if (!root) return;        middleTraverse(root-&gt;left, res);                res.push_back(root-&gt;val);                middleTraverse(root-&gt;right, res);    &#125;&#125;;\n\n思路有做孩子则进入递归，否则加入数组，再把右孩子进入递归\n隐式的维护一个栈，时间空间O(n)，节点总数n，每个节点都会被访问一次\n","categories":["LeetCode"],"tags":["二叉树","中序遍历"]},{"title":"二叉树的前序遍历","url":"/2022/04/10/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"迭代/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; stk;        while (true)&#123;            while (root)&#123;                res.push_back(root-&gt;val);                stk.push(root-&gt;right);                root = root-&gt;left;                          &#125;            if (stk.empty()) break;            root = stk.top();            stk.pop();            &#125;        return res;    &#125;&#125;;\n\n思路V，L，R 的顺序，从左分支向下访问根节点后，访问左孩子，右孩子入栈缓冲，左孩子遇空时，返回，往上弹出栈中先前存入的右孩子作为根进入\n","categories":["LeetCode"],"tags":["二叉树","前序遍历"]},{"title":"二叉树的后序遍历","url":"/2022/04/12/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"递归/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    void postorder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123;        if (!root) return;        postorder(root-&gt;left, res);        postorder(root-&gt;right, res);        res.push_back(root-&gt;val);    &#125;    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;        vector&lt;int&gt; res;        postorder(root, res);        return res;    &#125;&#125;;\n\n","categories":["LeetCode"],"tags":["二叉树","后序遍历"]},{"title":"二叉树的最大深度","url":"/2022/04/18/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","content":"深度优先算法class Solution &#123;public:    int maxDepth(TreeNode* root) &#123;        if (!root) return 0;        if (!root-&gt;left &amp;&amp; !root-&gt;right) return 1;        int maxDep = 0;        //递归进入求子树的最大深度        if (root-&gt;left) maxDep = max(maxDep,maxDepth(root-&gt;left));                if (root-&gt;right) maxDep = max(maxDep,maxDepth(root-&gt;right));        return maxDep + 1;    &#125;&#125;;\n\n思路递归进入求每个子树的最大路径\n遇空节点则返回\n算上根节点root最后返回时要加1\n","categories":["LeetCode"],"tags":["二叉树","深度优先算法"]},{"url":"/2022/04/13/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/","content":"深度优先/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int minDepth(TreeNode *root) &#123;        if (root == nullptr) &#123;            return 0;        &#125;        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;            return 1;        &#125;        int min_depth = INT_MAX;        if (root-&gt;left != nullptr) &#123;            min_depth = min(minDepth(root-&gt;left), min_depth);        &#125;        if (root-&gt;right != nullptr) &#123;            min_depth = min(minDepth(root-&gt;right), min_depth);        &#125;        return min_depth + 1;    &#125;&#125;;\n\n思路递归求每个子树的最小深度，根据min比较，可得该子树的最小深度\n如果为叶节点，直接返回1\n","categories":["LeetCode"],"tags":["二叉树","深度优先"]},{"title":"删除链表的倒数第N个结点","url":"/2022/03/13/LeetCode/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/","content":"双指针class Solution &#123;public:    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;        ListNode* fast = head;        ListNode* slow = head;        for (int i = 0;i &lt; n;i++)&#123;            fast = fast-&gt;next;        &#125;        if (fast == nullptr) return head-&gt;next;        else fast = fast-&gt;next;                while (fast != nullptr)&#123;            fast = fast-&gt;next;            slow = slow-&gt;next;        &#125;        ListNode* p = slow-&gt;next;        slow-&gt;next = p-&gt;next;        p-&gt;next = nullptr;        return head;    &#125;&#125;;\n\n思路利用快慢指针，两指针间距为n个节点，那么当快指针走到空时，慢指针的下一个就是要删除的节点\n为此，快指针必须先走n+1步，此时，慢指针在头部，两指针相距n个节点。\n需要判断如果快指针先走了n步就为空，说明n为节点的长度，要删除的是第一个节点\n","categories":["LeetCode"],"tags":["链表"]},{"title":"剑指Offer24.反转链表","url":"/2022/03/15/LeetCode/%E5%89%91%E6%8C%87Offer24.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","content":"迭代法/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if (!head || !(head-&gt;next)) return head;        ListNode* fast = head-&gt;next;        head-&gt;next = nullptr;        while (fast)&#123;            ListNode* tmp = fast-&gt;next;            fast-&gt;next = head;            head = fast;            fast = tmp;        &#125;        return head;    &#125;&#125;;\n\n思路每循环一次，就把快指针的指向反转，因为next会改变，所以必须提前存储快指针的下一步节点\n","categories":["LeetCode"],"tags":["迭代"]},{"title":"剑指Offer58-II.左旋转字符串","url":"/2022/03/29/LeetCode/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"局部+整体翻转class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        int len = s.size();        if (len == 0) return &quot;&quot;;        //反转n前面字符串        reverse(s.begin(),s.begin() + n);        //反转n后面字符串        reverse(s.begin() + n,s.end());        //反转整个字符串        reverse(s.begin(),s.end());        return s;    &#125;&#125;;\n\n\n\n切分与拼接class Solution &#123;public:    string reverseLeftWords(string s, int n) &#123;        if (s.size() == 0) return &quot;&quot;;        string str = s.substr(0,n);        string res = s.substr(n,s.size() - n) + str;        return res;    &#125;&#125;;\n\n思路substr的使用\n","categories":["LeetCode"],"tags":["字符串"]},{"title":"反转字符串中的单词 III","url":"/2022/03/03/LeetCode/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-III/","content":"原地交换class Solution &#123;public:    string reverseWords(string s) &#123;        int len = s.size();        int tmp = 0;         int fast = 0;        //s.push_back(&#x27; &#x27;);  //末位添加空格，省去多余判断        while (fast &lt; len)&#123;            while (s[fast] != &#x27; &#x27; &amp;&amp; fast != len)&#123;                fast++;            &#125;            int slow = tmp;             tmp = fast + 1;                        while (slow &lt; fast)&#123;                swap(s[slow++],s[--fast]);            &#125;            fast = tmp;        &#125;        //s.resize(len);        return s;    &#125;&#125;;\n\n思路双指针，fast指针遇到空格则开始进行单词反转，并用tmp记录下一次双指针的起点\n考虑到字符串末尾必不是空格，每次fast指针都需要判断是否走到末尾，否则会出现地址越界，所以可以在某位添加一个空格字符，因为遇空格则停的思想，可省去判断\n","categories":["LeetCode"]},{"title":"各位相加","url":"/2022/03/03/LeetCode/%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/","content":"简单class Solution &#123;public:    int addDigits(int num) &#123;        if (num &lt; 10) return num;                while (num &gt; 9)&#123;            int res = 0;            while (num &gt; 0)&#123;                res = res + num % 10; //取出个位数，每次相加                num = num / 10;            &#125;                        num = res;        &#125;        return num;    &#125;&#125;;\n\n","categories":["LeetCode"]},{"title":"合并两个有序数组","url":"/2022/03/10/LeetCode/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"双指针合并class Solution &#123;public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;            if (m == 0 || n == 0) nums1 = nums2;                vector&lt;int&gt; sum;                sum.resize(m + n);                int i = 0,j = 0,k = 0;                   while(i &lt; m &amp;&amp; j &lt; n)&#123;                    if(nums1[i] &lt; nums2[j]) sum[k++] = nums1[i++];                    else sum[k++] = nums2[j++];                &#125;                while (i &lt; m)&#123;                    sum[k++] = nums1[i++];                &#125;                while (j &lt; n)&#123;                    sum[k++] = nums2[j++];                &#125;                nums1 = sum;    &#125;&#125;;\n\n","categories":["LeetCode"]},{"title":"回文链表","url":"/2022/04/22/LeetCode/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","content":"快慢指针翻转/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        //快指针为空时，慢指针指向中，途中翻转前半部分        ListNode* pre = nullptr;        ListNode* fast = head;        ListNode* slow = head;        while (fast &amp;&amp; fast-&gt;next)&#123;            //快指针先走防止慢指针反转操作干扰            fast = fast-&gt;next-&gt;next;            //反转            ListNode* tmp = slow-&gt;next;            slow-&gt;next = pre;                    pre = slow;            slow = tmp;        &#125;        //奇个数，快指针为元素末尾节点        if (fast) slow = slow-&gt;next;                while (slow)&#123;            if (slow-&gt;val != pre-&gt;val) return false;            slow = slow-&gt;next;            pre = pre-&gt;next;        &#125;        return true;    &#125;&#125;;\n\n思路从中间向两边进行遍历比较，全部相同则是回文链表\n快慢指针，过程中翻转前半部分链表，结束后慢指针为链表的中点往前一步\n","categories":["LeetCode"],"tags":["链表","快慢指针"]},{"title":"存在重复元素II","url":"/2022/03/30/LeetCode/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/","content":"哈希 + 滑动窗口class Solution &#123;public:    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int,int&gt; table;        for (int i = 0;i &lt; nums.size();i++)&#123;            if (table.count(nums[i]) &amp;&amp; i - table[nums[i]] &lt;= k)&#123;                return true;            &#125;                  table[nums[i]] = i;            if (table.size() &gt; k)&#123;                table.erase(table[nums[i - k]]);            &#125;        &#125;        return false;    &#125;&#125;;\n\n思路哈希表key存数组元素，value存数组下标\n维护一个窗口大小为k，若存在key相同，且value相减小于k，则直接返回true\n","categories":["LeetCode"],"tags":["哈希表","滑动窗口"]},{"title":"实现strStr()","url":"/2022/02/28/LeetCode/%E5%AE%9E%E7%8E%B0strStr()/","content":"暴力法class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        int len1 = haystack.size();        int len2 = needle.size();        if (len2 == 0) return 0;        if (len1 &lt; len2) return -1;        int ha = 0;        while (ha &lt; len1)&#123;            if (len1 - ha &lt; len2) return -1; //直到haystack剩余数量比needle少            int ne = 0,tmp = ha; //存储haystack的下标，若找到返回这个起始位置            while (haystack[ha] == needle[ne] &amp;&amp; ne &lt; len2)&#123;                ne++;                ha++;            &#125;            if (ne == len2) return tmp;                        ha = tmp + 1;        &#125;        return -1;    &#125;&#125;;\n\n思路不会KMP\n","categories":["LeetCode"],"tags":["KMP"]},{"title":"对称二叉树","url":"/2022/04/20/LeetCode/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"迭代class Solution &#123;public:    bool symmetricTree(TreeNode* r,TreeNode* l)&#123;        queue&lt;TreeNode*&gt; q;        q.push(r),q.push(l);        while (!q.empty())&#123;                TreeNode* ri = q.front();q.pop();            TreeNode* le = q.front();q.pop();\t\t\t//如果两边对称都为空，直接跳过            if (!le &amp;&amp; !ri) continue;\t\t\t            if ((!le || !ri) || le-&gt;val != ri-&gt;val) return false;  \t\t\t//对称进入队列            q.push(le-&gt;right); q.push(ri-&gt;left);            q.push(ri-&gt;right); q.push(le-&gt;left);        &#125;        return true;    &#125;    bool isSymmetric(TreeNode* root) &#123;       return symmetricTree(root,root);    &#125;&#125;;\n\n思路两子树根节点相同，且每颗子树的左右子树互为对称\n若对称两节点满足不为空且值相同，则进入判断其子树\n","categories":["LeetCode"],"tags":["二叉树"]},{"title":"括号匹配","url":"/2022/03/02/LeetCode/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/","content":"简单判断class Solution &#123;public:    bool isValid(string s) &#123;        //奇数直接返回        if (s.size() % 2 == 1) return false;        stack&lt;char&gt; stk;        for (char ch : s)&#123;                        if (ch == &#x27;[&#x27; || ch == &#x27;(&#x27; || ch == &#x27;&#123;&#x27;)&#123; //左括号则入栈                stk.push(ch);                   &#125;                        else if (stk.empty())&#123; //是右括号，但是栈为空，则没有与之匹配的左括号，直接返回                return false;            &#125;                         else if (ch == &#x27;]&#x27;)&#123;                if (stk.top() == &#x27;[&#x27;)                stk.pop();                else return false;            &#125;                         else if (ch == &#x27;)&#x27;)&#123;                if (stk.top() == &#x27;(&#x27;)                stk.pop();                else return false;            &#125;                        else if (ch == &#x27;&#125;&#x27;)&#123;                if (stk.top() == &#x27;&#123;&#x27;)                stk.pop();                else return false;            &#125;        &#125;        return stk.empty(); //全部匹配成功则栈为空    &#125;&#125;;\n\n思路规模小，遇到左括号入栈，遇到右括号则与栈顶进行匹配。遍历结束，若栈为空，则全部pop()完成，否则，一定存在没有找到配对的左括号\n哈希表class Solution &#123;public:    bool isValid(string s) &#123;        //奇数直接返回        if (s.size() % 2 == 1) return false;\t\t//右括号作为key方便读取value与栈顶左括号匹配        unordered_map&lt;char,char&gt; right = &#123;&#123;&#x27;)&#x27;,&#x27;(&#x27;&#125;,&#123;&#x27;]&#x27;,&#x27;[&#x27;&#125;,&#123;&#x27;&#125;&#x27;,&#x27;&#123;&#x27;&#125;&#125;;        stack&lt;char&gt; stk;        for (char ch : s)&#123;                        if (right.count(ch))&#123;                                 if (stk.empty() || right[ch] != stk.top())&#123;                    return false;                                    &#125; else stk.pop();                            &#125; else stk.push(ch);        &#125;        return stk.empty();    &#125;&#125;;\n\n思路同样的只有左括号需要入栈。若规模大，速度会相对较快\n","categories":["LeetCode"],"tags":["哈希表"]},{"title":"排序数组","url":"/2022/03/08/LeetCode/%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"快速排序class Solution &#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;        quickSort(nums,0,nums.size() - 1);        return nums;    &#125;    void quickSort(vector&lt;int&gt;&amp; nums,int lo,int hi)&#123;        if (lo == hi) return;        swap(nums[lo], nums[lo + rand() % (hi - lo)]);                int pivot = nums[lo];        int left = lo;        int right = hi;        while (left &lt; right)&#123;                        while (left &lt; right &amp;&amp; nums[left] &lt; pivot)&#123;                left++;            &#125;            while (left &lt; right &amp;&amp; nums[right] &gt; pivot)&#123;                right--;            &#125;            if (nums[left] == nums[right] &amp;&amp; left &lt; right) left++;            else swap(nums[left],nums[right]);        &#125;\t\t//极端情况，轴点最大或最小        if (left - 1 &gt; lo) quickSort(nums,lo,left - 1);        if (right + 1 &lt; hi) quickSort(nums,left + 1,hi);    &#125;&#125;;\n\n思路从两边往中间遍历，左区间做到比轴点大，右区间比轴点小，遍历完成轴点就会去到属于它的正确位置。\n如果轴点是正好在中间位置，则是最好情况O(NlogN)，如果轴点很偏，即轴点最大或最小，则最差情况O(N2)，那么如果随机选取轴点，好坏情况则是概率事件，根据数学上的长期期望，最后则是O(NlogN)。\n\n归并排序class Solution &#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;        mergeSort(nums,0,nums.size() - 1);        return nums;    &#125;        void mergeSort(vector&lt;int&gt;&amp; nums,int lo,int hi)&#123;        if (lo == hi) return; //递归基        int mi = (lo + hi) &gt;&gt; 1;        mergeSort(nums,lo,mi);        mergeSort(nums,mi + 1,hi);        merge(nums,lo,mi,hi);    &#125;    void merge(vector&lt;int&gt;&amp; nums,int lo,int mi,int hi)&#123;        int* arr = new int[hi - lo + 1]; //用来存放比较结果，最后放回原数组中        int i = 0;        int left = lo;        int right = mi + 1;        while (left &lt;= mi &amp;&amp; right &lt;= hi)&#123;            arr[i++] = nums[left] &lt; nums[right] ? nums[left++] : nums[right++];        &#125;        //只执行一个while，将剩余有序元素依次存入        while (left &lt;= mi)&#123;            arr[i++] = nums[left++];        &#125;        while (right &lt;= hi)&#123;            arr[i++] = nums[right++];        &#125;        for (i = 0;i &lt; hi - lo + 1;i++)&#123;            nums[lo + i] = arr[i];        &#125;                delete[] arr;    &#125;&#125;;\n\n思路每次排列都要新建一个临时数组存放结果，最后再复制回原数组，排列过程总会有一半区间提前完成，那么另一半就可直接存入\nO(NlogN)，每一次的比较行为都没有单纯浪费，而是形成了一个整体有序的部分，进而与下一次更大的范围进行合并\n\n堆排序class Solution &#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;        if (nums.size() &lt; 2) return nums; //小于2自然有序        //形成大根堆        for (int i = 0;i &lt; nums.size();i++)&#123;            heapInsert(nums,i);        &#125;                int heapSize = nums.size();        //根节点，放至数组最后，并且堆大小减1        swap(nums[0],nums[--heapSize]);        while (heapSize &gt; 0)&#123;            heapify(nums,0,heapSize);            swap(nums[0],nums[--heapSize]);        &#125;        return nums;    &#125;    //依次与父节点作比较，形成大根堆，单一路线    void heapInsert(vector&lt;int&gt;&amp; arr,int index)&#123;        while (arr[index] &gt; arr[(index - 1) / 2])&#123;            swap(arr[index],arr[(index - 1) / 2]);            index = (index - 1) / 2;        &#125;    &#125;    //拿掉最大值，仍然保持大根堆    void heapify(vector&lt;int&gt;&amp; arr,int index,int heapSize)&#123;        int left = index * 2 + 1;        while (left &lt; heapSize)&#123; //左节点小于堆大小，则一定没有右节点            //选出左右之间的大孩子            int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ?            left + 1 : left;            //用大孩子与父亲作比较，谁大谁做父亲            largest = arr[largest] &gt; arr[index] ? largest : index;            if (largest == index) break; //若原本父亲最大            swap(arr[largest],arr[index]);            //继续向下寻找是否有比自身大的孩子            index = largest;            left = index * 2 + 1;         &#125;    &#125;&#125;;\n\n思路形成大根堆，每次取出根节点，即拿到最大值，放到数组最后，形成有序，堆大小随即减少，剩余节点继续保持大根堆。\n完全二叉树的高度根据其节点数可以看成logN，所以新加入一个节点调整代价即为logN（只走一条路线），即形成大根堆的过程为O(NlogN)，拿掉根节点并且保持有序O(NlogN)，总体复杂度O(NlogN)。\nO(N2)大量浪费比较行为最后只搞定一个数\n冒泡排序class Solution &#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size() - 1;                while (len &gt; 0)&#123;            int lo = -1;             int last = lo;             while (++lo &lt; len)&#123;                                if (nums[lo] &gt; nums[lo + 1])&#123;                    swap(nums[lo],nums[lo + 1]);                    last = lo + 1;                &#125;               &#125;                        len = last - 1;        &#125;       return nums;     &#125;&#125;;\n\n思路根据没有逆序对则正确顺序的思想，每当碰到逆序对时，记下last位置，结束得到最后一个逆序对的位置，则最后一个逆序对右边全部有序，后续直接判断last前面的数即可\n\n选择排序class Solution &#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;        for (int i = 0;i &lt; nums.size();i++)&#123;            int min = i;            //找出最小值            for (int j = i + 1;j &lt; nums.size();j++)&#123;                if (nums[j] &lt; nums[min])                    min = j;            &#125;                        swap(nums[i],nums[min]);        &#125;                return nums;\t&#125;&#125;;\n\n\n插入排序class Solution &#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;        for (int i = 1;i &lt; nums.size();i++)&#123;            int tmp = nums[i];            //逐个依次往前比，大于此数则交换位置            for (int j = i;j &gt; 0 &amp;&amp; nums[j-1] &gt; tmp;j--)&#123;                nums[j] = nums[j-1];                nums[j-1] = tmp;            &#125;        &#125;                return nums;\t&#125;&#125;;\n\n思路扑克牌排序，小样本时跑得快\n","categories":["LeetCode"],"tags":["快速排序","归并排序","堆排序","插入排序","冒泡排序","选择排序"]},{"title":"整数反转","url":"/2022/03/11/LeetCode/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","content":"取余反转class Solution &#123;public:    int reverse(int x) &#123;        if (x &lt; 10 &amp;&amp; -10 &lt; x) return x; //只有一位数直接返回        int res = 0;        int n = 0; //记录位数，以便在第九位时进行判断接下来的操作是否会溢出        while(x != 0)&#123;            if (n == 9)&#123;                if (abs(res) &gt; 214748364) return 0;                else if (abs(res) == 214748364)&#123;                    if (x &gt; 7 || x &lt; -8) return 0;                &#125;            &#125;            res = res * 10 + x % 10;            x = x / 10;            n++;        &#125;        return res;    &#125;&#125;;\n\n思路逐一取余进行反转，在第九位时，根据int在32位下的最大最小情况，进行判断是否溢出\n","categories":["LeetCode"],"tags":["数学"]},{"title":"最长公共前缀","url":"/2022/03/12/LeetCode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","content":"遍历class Solution &#123;public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;        if (strs.size() &lt; 1) return &quot;&quot;;        int len = strs.size();        int n = strs[0].size();                for (int i = 0;i &lt; n;i++)&#123;                        for (int j = 0;j &lt; len;j++)&#123;                                if (i == strs[j].size() || strs[j][i] != strs[0][i])                    return strs[0].substr(0,i);            &#125;        &#125;        return strs[0];    &#125;&#125;;\n\n思路外循环为第一个单词的长度，内循环为字符串总长，用到substr的操作，简化了另辟空间和加入字符的操作\n","categories":["LeetCode"],"tags":["字符串"]},{"title":"有效的括号","url":"/2022/03/01/LeetCode/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","content":"哈希表+栈class Solution &#123;public:    bool isValid(string s) &#123;        //奇数直接返回        if (s.size() % 2 == 1) return false;        unordered_map&lt;char,char&gt; right = &#123;&#123;&#x27;)&#x27;,&#x27;(&#x27;&#125;,&#123;&#x27;]&#x27;,&#x27;[&#x27;&#125;,&#123;&#x27;&#125;&#x27;,&#x27;&#123;&#x27;&#125;&#125;;         stack&lt;char&gt; stk;        for (char ch : s)&#123;            if (right.count(ch))&#123;                 if (stk.empty() || right[ch] != stk.top())&#123;                    return false;                &#125; else stk.pop();                            &#125; else stk.push(ch);        &#125;        return stk.empty();    &#125;&#125;;\n\n思路先遇到的左括号要先进栈，随后的右括号与左括号配对，成功则出栈，否则，不是有效的括号\n数组遍历完若栈里还有元素，则没有与之匹配的有括号，返回false\n根据count函数找key值，那么右括号是不进栈的\n","categories":["LeetCode"],"tags":["哈希表"]},{"title":"相同的树","url":"/2022/04/05/LeetCode/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","content":"深度优先算法/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isSameTree(TreeNode* p, TreeNode* q) &#123;        if (!p &amp;&amp; !q) return true;\t//若两节点都为空                else if (!p || !q) return false;\t//若两节点只有一个为空\t                else if (p-&gt;val != q-&gt;val) return false;\t//若两节点值不相同       \t//两节点相同，递归进入        else return (isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right));    &#125;&#125;;\n\n","categories":["LeetCode"],"tags":["二叉树","深度优先算法"]},{"title":"环形链表","url":"/2022/03/16/LeetCode/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","content":"哈希表class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (!head) return false;        unordered_map&lt;ListNode*,int&gt; table;        int pos = 0;        while (head != nullptr)&#123;            auto it = table.find(head);            if (it != table.end())&#123;                return true;            &#125;            table[head] = pos++;            head = head-&gt;next;        &#125;    return false;    &#125;&#125;;\n\n思路直接把每个节点存入表中，若出现环路，则节点就会在表中被找到\n快慢指针class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if (!head || !(head-&gt;next)) return false;        ListNode* fast = head-&gt;next;        ListNode* slow = head;        while (fast != slow)&#123;            if (!fast || !(fast-&gt;next)) return false;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;        &#125;    return true;    &#125;&#125;;\n\n思路fast每次走两步，因为判定条件为两指针不相等，则起初fast要比slow快一步。\n如果有环路，fast则会在环中追上slow和他相遇\n","categories":["LeetCode"],"tags":["哈希表"]},{"title":"第K个缺失的正整数","url":"/2022/05/25/LeetCode/%E7%AC%ACK%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/","content":"枚举class Solution &#123;public:    int findKthPositive(vector&lt;int&gt;&amp; arr, int k) &#123;        int current = 1,missCount,lastMiss = -1,ptr = 0;                for (missCount = 0; missCount &lt; k; current++)&#123;                        if (current == arr[ptr]) &#123;                ptr = (ptr + 1 &lt; arr.size()) ? ptr + 1 : ptr;              &#125; else &#123;                missCount++;                lastMiss = current;            &#125;        &#125;        return lastMiss;    &#125;&#125;;\n\n思路每次循环 当前数 current 递增，用一个指针ptr遍历数组，如果和current相等，那么指针后移\n如果不相等，那么表示 当前数current 是缺失的整数，记录到lastMiss，并且missCount加1，直到缺失的数量missCount等于K，lastMiss就是第K个缺失的整数\n","categories":["LeetCode"],"tags":["枚举","二分"]},{"title":"罗马数字转整数","url":"/2022/03/02/LeetCode/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","content":"哈希表class Solution &#123;public:    int romanToInt(string s) &#123;        //大的数如果在小的数左边则做加法，反之做减法        //题目所给字符，一定符合要求，可以转成整数        unordered_map&lt;char,int&gt; rome = &#123;            &#123;&#x27;I&#x27;,1&#125;,            &#123;&#x27;V&#x27;,5&#125;,            &#123;&#x27;X&#x27;,10&#125;,            &#123;&#x27;L&#x27;,50&#125;,            &#123;&#x27;C&#x27;,100&#125;,            &#123;&#x27;D&#x27;,500&#125;,            &#123;&#x27;M&#x27;,1000&#125;        &#125;;                int res = 0;        int i;        for (i = 0;i &lt; s.size() - 1;i++)&#123;            int value = rome[s[i]];            if (rome[s[i]] &lt; rome[s[i + 1]])&#123;                res = res - value;            &#125; else&#123;                res = res + value;            &#125;        &#125;        res = res + rome[s[i]];    return res;    &#125;        &#125;;\n\n思路重点搞清楚大小数的顺序，在较大数的右边记上较小的数字，表示大加小，反之则大减小，最后一位直接加上\n","categories":["LeetCode"],"tags":["哈希表"]},{"title":"路径总和","url":"/2022/04/16/LeetCode/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","content":"路径总和class Solution &#123;public:    bool hasPathSum(TreeNode* root, int targetSum) &#123;        if (!root) return false;        targetSum -= root-&gt;val;        //如果为叶子节点，则判断是否满足条件        if (!root-&gt;left &amp;&amp; !root-&gt;right) return targetSum == 0; \t\t//递归进入子树搜索目标路径        return hasPathSum(root-&gt;left, targetSum) || hasPathSum(root-&gt;right, targetSum);    &#125;&#125;;\n\n思路目标值减去根节点，递归进入子树搜索是否有满足条件的路径\n","categories":["LeetCode"],"tags":["二叉树","递归"]},{"title":"Lua","url":"/2022/06/14/Lua/Lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"Lua面向对象复制表方式function clone(table)    local ins = &#123;&#125;    for k, v in pairs(table) do        ins[k] = v    end    return insendpeople = &#123;&#125;function people.sayHi()    print(&quot;people say hi&quot;)end--通过复制people类创建类实例local t1 = clone(people)t1.sayHi() --输出people sayHi\n\n构造方法function people:sayHi()    print(&quot;people say hi:&quot; .. self.name)endfunction people.new(name)    local self = clone(people)    self.name = name    return selfendlocal t2 = people.new(&quot;zhangsan&quot;)t2:sayHi() --输出people say hi:zhangsan\n\n继承function copy(dist,tab)    for k, v in pairs(tab) do        dist[k] = v    endendman = &#123;&#125;function man.new(name)    local self = people.new(name) --self从people构造而来    copy(self,man) --将man的元素复制进self中，此时self就同时拥有了man和people的成员    return selfend--定义子类自身成员function man.sayHello()    print(&quot;man say hello&quot;)end--重写父类函数function man:sayHi()    print(&quot;man say hi:&quot; .. self.name)end--定义对象mlocal m = man.new(&quot;lisi&quot;)m.sayHello() --man say hellom:sayHi() --man say hi:lisi\n\n函数闭包方式function people(name,age)    local self = &#123;&#125;    --类内部私有成员    local age = age    local function init()        self.name = name    end\t--外界使用接口    self.sayHi = function()        print(self.name .. &quot; say Hi&quot;)        end    self.sayAge = function()        print(self.name .. &quot; age: &quot; .. age)    end    init()    return selfendlocal p = people(&quot;zhangsan&quot;,1)p:sayHi() --zhangsan say Hip.sayAge()\n\n继承function man(name,age)    local self = people(name,age)    local function init()        self.age = age    end\t--使用了self这个upvalue，所以外界并不需要传self    self.sayHello = function()        print(self.name .. &quot; sayHello &quot; .. age)    end    return selfendlocal m = man(&quot;lisi&quot;,1)m.sayHello() --lisi sayHello 1m.sayHi() --lisi say Him.sayAge() --lisi age: 1\n\n元表方式构造 --类的声明，这里声明了类名还有属性，并且给出了属性的初始值people = &#123;name = &quot;&quot;,age = 0&#125;--设置元表的索引people.__index = peoplefunction people:new(name,age)    local t = &#123;&#125;    setmetatable(t,people) --将t的元表设定为people    t.name = name    t.age = age    return tendfunction people:sayHi()    print(self.name .. &quot; say Hi&quot;)endfunction people:Add()    self.age = self.age + 1    print(self.age)endlocal p = people:new(&quot;zhangsan&quot;,10)p:sayHi() --zhangsan say Hip:Add() --11\n\n继承man = &#123;num = 0&#125;--设置元表为父类peoplesetmetatable(man,people)--表索引设置为自身man.__index = manfunction man:new(num,name,age)    local t = &#123;&#125; --初始化自身    t = people:new(name,age) --初始化父类，相当于其他语言的base    setmetatable(t,man) --设置元表为man    t.num = num --新的初始化    return tendfunction man:GetNum()    self.num = self.num + 10    print(self.num)end--重写父类方法function man:Add()    self.age = self.age + 20    print(self.age)endlocal m = man:new(1,&quot;lisi&quot;,10)m:Add() --调用重写方法m:GetNum() --调用自身方法m:sayHi() --调用父类方法\n\n\n\nhttps://juejin.cn/post/6844903433330262030\nhttps://zhuanlan.zhihu.com/p/38127723\n","categories":["Lua"],"tags":["Lua"]},{"title":"AI","url":"/2022/04/26/Unity/AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E9%9A%9C/","content":"AI人工智障群体移动堵塞，拥挤，抖动使用NavMeshAgent在对AI进行寻路追逐玩家时，出现堵塞，拥挤抖动现象\n这是因为Unity Navigation是预处理Bake的，游戏运行过程中，第一个到达的AI所占位置仍然是被Bake，第二个AI仍然会往预先算出的路径走去，而该位置已经被先到达AI所占，后续AI则会一直到不了终点\nNavMeshObstacle导航网格障碍物组件，在运行过程中，新的物体可以被当做障碍物，勾选Carve雕刻选项，并关闭OnlyStation（仅静止时雕刻），这样，游戏过程中，物体停止后就可以在地上挖洞，其他AI则会避开\n但是AI既要使用导航代理寻路，又要可以在游戏中挖洞，unity中这两个组件是不能在一起运行的（出现抖动，胡乱瞎走行为，并且控制台出现警告）\n详情：https://www.youtube.com/watch?v=PxudQmMTLkg\n解决方法：物体移动的距离在一定时间内小于一个阈值时，判定物体被阻塞或停止，此时便可以挖洞，那么就关闭NavMeshAgent，开启NavMeshObstacle\nusing System.Collections;using UnityEngine;using UnityEngine.AI;[RequireComponent(typeof(NavMeshAgent), typeof(NavMeshObstacle))]public class ObstacleAgent : MonoBehaviour &#123;    [SerializeField]    //雕刻时间阈值，物体在这个时间内 移动距离始终小于雕刻移动阈值，则进行雕刻    private float carvingTime = 0.5f;    [SerializeField]    //雕刻移动阈值，物体移动的距离超过这个值，那么不进行雕刻    private float carvingMoveThreshold = 0.1f;    [HideInInspector]    public NavMeshAgent agent;    private NavMeshObstacle obstacle;    //记录上一次移动的时间    private float lastMoveTime;    //记录上一次移动位置    private Vector3 lastPos;    private void Start()    &#123;        agent = GetComponent&lt;NavMeshAgent&gt;();        obstacle = GetComponent&lt;NavMeshObstacle&gt;();        //先将obstacle阻碍组件关闭        obstacle.enabled = false;        //静止不动才雕刻设为false        obstacle.carveOnlyStationary = false;        //始终雕刻        obstacle.carving = true;        lastPos = transform.position;     &#125;    private void Update()    &#123;        //如果物体当前位置距上一次位置超过了 雕刻的移动阈值，就不需要进行雕刻        if (Vector3.Distance(lastPos,transform.position) &gt; carvingMoveThreshold)        &#123;            lastMoveTime = Time.time;            lastPos = transform.position;        &#125;        //如果物体正常移动超过了雕刻移动阈值，那么lastMoveTime在这一帧是一定等于Time.time的，所以直接不判断        //但是物体在移动距离小于阈值的状态下，lastMoveTime记录的就是上一次正常移动的时间点，这个时间点加上雕刻时间阈值，小于当前时间        //则判定物体已经在一段时间内没有进行移动或移动距离始终 &lt; 雕刻移动阈值        if (lastMoveTime + carvingTime &lt; Time.time)        &#123;            agent.enabled = false;            obstacle.enabled = true;        &#125;    &#125;    //对外公开的设置目标点方法    public void SetDistination(Vector3 pos,float stopDis, float speed)    &#123;        //即将移动了，不能共存，导航障碍物就需要关闭        obstacle.enabled = false;        //时间位置不重新设置，出现瞬移        lastMoveTime = Time.time;        lastPos = transform.position;        //先关闭Obstacle，等待一帧再开启Agent        //如果在同一帧进行，那么Obstacle在还没来得及关闭的情况下，Agent就开启了，导致AI此时所处位置是一个洞，就会出现瞬移        StartCoroutine(MoveAgent(pos,stopDis, speed));    &#125;    private IEnumerator MoveAgent(Vector3 pos, float stopDis, float speed)    &#123;        //等待一帧        yield return null;        agent.enabled = true;        agent.SetDestination(pos);        agent.stoppingDistance = stopDis;        agent.speed = speed;    &#125;&#125;\n\n\n问题在制作Boss技能时，因为动画带有位移，Boss会向自身前方位移，然而每次在位移一段距离后，总是会绕会到起始点\n做旋转动画时，大幅度旋转\n//设置开始移动agent.SetDestination(pos);agent.stoppingDistance = stopDis;agent.speed = speed;agent.angularSpeed = 360;\n\n在移动到指定位置后，调用StopMove\nagent.SetDestination(transform.position);\n\n因为在停止移动中设置了当前位置，导致AI做位移动画时，navAgent判断需要移动，会把AI拖回原地\n\n解决方法，设置agent速度为0\n\nagent.speed = 0;agent.angularSpeed = 0;\n\n\n直接取消勾线Root Motion其实也可以解决，但是需要自己为需要位移的动画再添加相应逻辑\n\n","categories":["Unity"],"tags":["AI","Navgation"]},{"title":"A*","url":"/2022/06/10/Unity/AStart/","content":"A*和NavMeshA*\n利用启发式函数，大大减少计算量\n易编辑，直接通过改变节点的表现形式，容易对地图进行动态的修改（例如生成建筑物）\n使用方块作为节点，如果地图很大，方块的数量就会导致处理时间的增加\n单位体积不一样的话，大单位可能会覆盖不可行走区域\n\nNavMesh\n是对A*的一种扩展，基于场景不同区域，划分成众多不规则三角形\n通过计算导航网格上两点的位置关系，就可知道是否可行走或有无障碍物\n自带单位体积，在经过一些转角就可以加上体积半径进行计算\n也可以动态的改变地图区域，但是相对复杂\n\nA*学习网站：http://theory.stanford.edu/~amitp/GameProgramming/\n广度优先算法从起点出发，每次可以朝上下左右四个方向进行移动，在一轮搜索完毕后，会标记这些探索过得方块为边界（绿色方块）， 然后循环往复的从这些边界方块开始，朝他们的上下左右四个方向继续探索 ，直到遍历到终点方块\n\n\n因为对路径的寻找是没有方向性的，会朝各个方向进行探索，所以在最坏的情况下，算法要跑完整张地图才能找到最短路径\n\nA*算法A*算法也叫启发式（Heuristic）搜索，与广度优先不同的是，在每一轮循环的时候不会去搜索每个边界，而是选择当前“代价”最低的方块进行探索\n代价\n当前路径代价（g）：代表从起点出发，一共走过多少个格子\n预估代价（h）：代表当前方块到终点方块大概需要的距离\n欧拉距离（Euler Distance)：两点之间的直线距离\n曼哈顿距离（Manhattan Distance)：两点在竖直方向和水平方向上的距离总和\n\n\n寻路消耗（f）：f = g + h\n\n基本原理搜索过的方块个数明显比广度优先少很多\n\n详细原理\n\n每到达一个新的节点，则计算其周围还未在开启或关闭列表中的并且不是阻挡的点，送进开启列表中，并记录父对象\n然后排序开启列表，找出代价最少点，移入关闭列表（这步是算法最消耗性能的地方）\n每次往关闭列表中放点时，都判断这个点是否是终点\n找到终点后，根据父对象回溯\n父对象存在意义：终点之前，因为程序并不知道阻挡的存在，所以总是会往一个看似正确的方向移动，最终遇到阻挡时，才会回退，直到正确路径，所以关闭列表中的节点最终并不是全部有用的\n\n代码油管大神：https://www.youtube.com/c/SebastianLague/videos\n代码实现：https://github.com/x1aochen/AStart_Algorithm //详细注释\n使用堆结构做开启列表的优化使用List存储开启列表，在每次寻找代价最低节点时，总是需要遍历全部元素，大大降低了性能，使用堆排序，维持一个顶部总是为最低代价的堆结构以提升性能\n相同路径优化前：\nNode currenNode = openSet[0]//找到代价最低节点，总是需要遍历开启列表中的全部元素for (int i = 1;i &lt; openSet.Count; i++)&#123;    //找到代价更小点，或者代价相等，但是h消耗更小点    if (openSet[i].fCost &lt; currenNode.fCost || openSet[i].fCost == currenNode.fCost &amp;&amp; openSet[i].hCost &lt; currenNode.hCost)    &#123;       currenNode = openSet[i];    &#125;&#125;\n\n\n优化后：\n\n多个单位行进与回溯路径简化\n添加了任务请求类，使用协程处理多个单位需要同时进行寻路时的处理，在找到路径后通过回调函数中call到寻路后所需执行的事件，这边是往目标点移动\n\n\n\n原先存储在Grid类中的路径已经不需要了，转而在PathFinding中直接使用数组来存储回溯路径，并且简化了路径，使其只存储那些在方向上发生了改变的点，相比原本List中存放整条路径上的全部点，大大降低了内存消耗\n\n\n\n未完待续。。。。。。\n","categories":["Unity"],"tags":["A*"]},{"title":"编译","url":"/2022/07/02/Unity/Unity%E7%BC%96%E8%AF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/","content":"做算法可视化的时候，发现第一次执行的速度总是会较慢，联想到可能是因为JIT的编译方式，网上学习了下，整理一些概念方便以后复习\nIL(Intermediate Language)https://zhuanlan.zhihu.com/p/100233990\nIL是.NET框架的中间语言，使用.NET框架提供的编译器可以直接将源程序编译为.exe或.dll，但此时编译出来的程序代码并不是CPU能直接执行的机器代码，而是一种中间语言的代码（具体形式是.NET平台编译后得到的.dll动态链接库文件或.exe可执行文件）\nCLR（Common Language Runtime）https://zhuanlan.zhihu.com/p/68158037\n\n公共语言运行时（CLR）是一套完整的、高级的虚拟机，它被设计为用来支持不同的编程语言，并支持它们之间的互操作。\n\n主要功能：主要负责资源管理，包括内存分配，程序集加载，异常处理，线程同步，垃圾回收等，并保证了应用和底层操作系统的分离\n主要目标：就是为了让编程更简单\n被CLR所执行的代码就叫做托管代码\nIL转译方式即使编译（Just in time）JIT：边运行边编译，开发期间，可以动态的下发和执行代码，测试效率高，但运行速度和执行性能会因为运行时即使编译收到影响\n提前编译（Ahead of time）AOT：可以直接将部分源码编译成原生码供对应平台使用，运行速度快，性能好，但每次执行前都需要提前编译，开发效率低\n完全提前编译（Full ahead of time）Full-AOT：程序运行前，将全部源码转为对应平台的原生码\nMonoMono的目标是在尽可能多的平台上使.net标准的东西能正常运行的一套工具，核心在于“跨平台的让.net代码能运行起来\nMono运行时编译器支持将IL代码转为对应平台原生码\n\n构建应用快\n由于mono的JIT机制，所以支持更多托管类库\n支持运行时代码执行\n\nMono和IL2CPP的过程：\n\nIL2CPP由unity开发，把IL中间语言转换成CPP文件（AOT）\n为什么要转成CPP\n\n运行效率快\nMono VM 在各个平台移植，维护非常耗时，有时甚至不可能完成\n可以利用现成的在各个平台的C++编译器对代码执行编译期优化，这样可以进一步减小最终游戏的尺寸并提高游戏运行速度\n多平台移植方便\n\n存在IL2CPP VM的原因\n\n虽然通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 IL2CPP VM的原因：它负责提供诸如GC管理，线程创建这类的服务性工作。但是由于去除了IL加载和动态解析的工作，使得IL2CPP VM可以做的很小，并且使得游戏载入时间缩短\n\n测试更换机制\n\nMono模式编译的第一次运行：\n\nIL2CPP第一次运行：\n\n","categories":["Unity"],"tags":["JIT","AOT"]},{"title":"三维数学基础","url":"/2022/04/05/Unity/%E4%B8%89%E7%BB%B4%E6%95%B0%E5%AD%A6/","content":"向量点乘Dot点积，内积，各分量乘积和\n公式[x1,yz,z1] · [x2,y2,z2] = x1 * x2 + y1 * y2 + z1 * z2\n几何意义$$a · b = |a| * |b| * cos&lt;a,b&gt;$$\n\n两个向量的单位向量相乘再乘以二者夹角的余弦值\n\n应用//只能拿到0到180度夹角float dot = Vector3.Dot(T1.position.normalized, T2.position.normalized);//归一后等同于拿到余弦值//结果为弧度要转成角度angle = Mathf.Acos(dot) * Mathf.Rad2Deg;//拿到夹角if (angle &gt; 60) &#123; &#125;//等同于if (dot &lt; 0.5f) &#123; &#125; //dot0.5 = 60度的余弦值，省去多余的性能开销Vector3.Angle(); //内部使用dot\n\n结果与角度的关系\n对于标准化过的向量，方向完全相同，点乘结果为1，完全相反，点乘结果为-1，互相垂直为0\n\n叉乘Cross叉积，外积\n公式[x1,yz,z1] * [x2,y2,z2] = [y1 * z2 - z1 * y2，z1 * x2 - x1 * z2，x1 * y2 - y1 * x2]\n几何意义结果为两个向量所组成面的垂直向量，模长为两向量模长乘积再乘夹角的正弦值\n应用\n创建垂直于平面的向量\n判断两条向量相对位置（顺逆时针关系）\n\n//与点乘配合得到一圈（360度）夹角Vector3 cross = Vector3.Cross(T1.position, T2.position);if (cross.y &lt; 0) //根据叉乘结果的y值来取得大夹角&#123;    angle = 360 - angle;&#125;\n\n结果与角度的关系\n所得向量模长与角度的关系：0~90度角（因为有点乘存在，所以并不重要）\n\n应用计算是否进入敌人攻击范围\n\nusing UnityEngine;public class Test : MonoBehaviour&#123;    private float attackDistance = 20f; //敌人攻击距离    private float angle = 120f;  //敌人扇形攻击范围    private float dot;  //双方夹角    private float distance; //双方距离     public Transform player; //玩家    private void Update()    &#123;        GetDistance();        if (distance &lt; attackDistance)        &#123;            GetAngle();            if (dot &lt; angle / 2)            &#123;                print(&quot;get player&quot;);            &#125;        &#125;    &#125;        void GetDistance()    &#123;        //计算双方距离        Vector3 v = this.transform.position - player.position;        distance = v.magnitude;         &#125;    void GetAngle()    &#123;        //计算双方夹角        Vector3 tmp = player.position - transform.position;        dot = Vector3.Dot(this.transform.forward.normalized, tmp.normalized);               angle = Mathf.Acos(dot) * Mathf.Rad2Deg;    &#125;&#125;\n\n\n\n欧拉角xz沿自身坐标系，y沿世界坐标系\n优点\n仅使用三个数字表达方位，占用空间小\n 沿坐标轴旋转的单位为角度，符合人的思考方式\n任意三个数字都是合法的，不存在不合法的欧拉角\n\n缺点\n万向节死锁：无法做360度自由旋转\n\n\n物体沿X轴旋转正负90度，自身坐标系Z轴与世界坐标系Y轴将重合，此时再沿Y或Z轴旋转，将失去一个自由度\n\n\n方位的表达方式不唯一\n\n\n对于一个方位，存在多个欧拉角描述，因此无法判断多个欧拉角代表的角位移是否相同\n\n例如:\n\n角度0，5，0与角度0，365，0\n0，-5，0与0，355，0\n250，0，0与290，180，180\n\n\n为了保证任意方位都只有独一无二的标识，Unity已经帮我们限制，X轴旋转为正负90度，Y，Z轴为0到360之间\n\n\n//各分量相加 欧拉角的X增加1度this.transform.eulerAngles += new Vector3(1, 0, 0);\n\n\n\n四元数由一个向量和一个标量组成\n\n向量：弧度的sin值一半再乘以轴的各分量 \n\n$$X/Y/Z = sin(弧度 / 2) * V.x/y/z$$\n\n标量： 弧度一般的cos值，\n\n$$cos(弧度 / 2)$$\nQuaternion qt = new Quaternion();//旋转轴Vector3 axis = Vector3.up;//旋转弧度float rad = 50 * Mathf.Deg2Rad;qt.x = Mathf.Sin(rad / 2) * axis.x;qt.y = Mathf.Sin(rad / 2) * axis.y;qt.z = Mathf.Sin(rad / 2) * axis.z;qt.w = Mathf.Cos(rad / 2);this.transform.rotation = qt;//欧拉角-&gt;四元数this.transform.rotation = Quaternion.Euler(0, 50, 0);//等同于this.transform.Rotate(0,50,0);\n\n优点\n避免万向节死锁\n功能较多\n\n缺点\n难以使用\n存在不合法的四元数\n\n与四元数相乘组合旋转，叠加\nQuaternion.Euler(0, 30, 0) * Quaternion.Euler(0, 20, 0) = Quaternion.Euler(0, 50, 0);\n\n与向量相乘\n四元数左乘向量，表示将该向量按照四元数表示的角度旋转\n\n```c#Vector3 point = new Vector3(0,0,10);Vector3 newPoint = Quaternion.Euler(0,30,0) * point;\n### 应用计算物体右前方30度，10米远坐标```c#Debug.DrawLine(this.transform.position, vect);Vector3 vect = new Vector3(0, 0, 10);//vect 向量根据当前物体的旋转而旋转vect = this.transform.rotation * vect ;//vect 向量沿y轴旋转30度vect = Quaternion.Euler(0, 30, 0) * vect;//vect 向量移动到当前物体位置vect = this.transform.position + vect;//等同于vect = this.transform.position + Quaternion.Euler(0, 30, 0) * this.transform.rotation * new Vector3(0, 0, 10);\n\n\npublic class playerBoom : MonoBehaviour&#123;    private string playerTag = &quot;Player&quot;;    private Transform playerTF;    privare float radius;    void Start()    &#123;        //获取玩家        GameObject player = GameObject.FindWithTag(playerTag);        //玩家位置        playerTF = player.transform;        //玩家半径        radius = player.GetComponent&lt;CapsuleCollider&gt;().radius;    &#125;  \t    void Update()    &#123;        CalculateTangent();        Detection();    &#125;        Vector3 leftTangent, rightTangent;    Vector3 distance; //两点间距离    Vector3 radiusDirection; //玩家与炸弹的半径方向        void CalculateTangent()    &#123;           distance = this.transform.position - playerTF.position;        radiusDirection = distance.normalized * radius;        //计算夹角        float angle = Mathf.Acos(radius / distance.magnitude) * Mathf.Rad2Deg;\t\t//计算切点,旋转半径方向向量        leftTangent = playerTF.position + Quaternion.Euler(0, -angle, 0) * radiusDirection;        rightTangent = playerTF.position + Quaternion.Euler(0, angle, 0) * radiusDirection;    &#125;    void Detection()    &#123;        Debug.DrawLine(this.transform.position, leftTangent);        Debug.DrawLine(this.transform.position, rightTangent);        Debug.DrawLine(Vector3.zero, distance,Color.red);        Debug.DrawLine(Vector3.zero, radiusDirection,Color.green);    &#125;&#125;\n\n转换\n四元数转欧拉角\n   Vector3 v3=transform.rotation.eulerAngles;2. 四元数转方向   ~~~ c#   Vector3 vector3= (transform.rotation * Vector3.forward).normalized;\n欧拉角转四元数\nQuaternion rotation = Quaternion.Euler(vector3);\n欧拉角转方向\nVector3 v3 = (Quaternion.Euler(vector3) * Vector3.forward).normalized;\n方向转四元数\nQuaternion rotation =Quaternion.LookRotation(vector3);\n方向转欧拉角\nVector3 v3 =Quaternion.LookRotation(vector3).eulerAngles;\n\n","categories":["Unity"],"tags":["三维数学","向量","欧拉角","四元数"]},{"title":"事件函数的坑","url":"/2022/06/28/Unity/%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%9D%91/","content":"事件函数 EventFunction事件函数不需要重写的原因\n是因为Unity是通过反射对方法进行调用，而且并不是所有继承了MonoBehaviour的脚本都需要写上全部的事件函数\n在引擎内部存在一张表，这张表的形成是通过在场景中查找全部的MonoBehaviour类型脚本然后遍历里面的方法，将需要的调用的方法是全部记录下来，然后进行调用。防止那些不需要调用的MonoBehaviour中的方法占用空间，节省资源开耗\nSendMessage事件函数也可以被SendMessage使用\n这个函数会通过反射，遍历挂载物体上的所有脚本是否有需要接收消息的函数\n//Test1.cs:private void Awake()&#123;    Debug.Log(&quot;Test1 Awake&quot;);&#125;private void Start()&#123;    SendMessage(&quot;Awake&quot;);&#125;  //Test2.cs:private void Awake()&#123;    Debug.Log(&quot;Test2 Awake&quot;);&#125;\n\n通过SendMessage再次调用了Awake\nAwake和StartAwake：始终在任何Start函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake）\nstart：仅当启用脚本实例后，才会在第一次帧更新之前调用 Start，在第一次Enable后，第一次Update之前调用\n1.Awake只要所挂载的物体被激活，不管自身脚本组件是否被激活都会被调用\n可以理解为，游戏物体实例化后，挂载在其身上的脚本组件都会被一并实例化，不管是否激活，那么Awake就可以理解为在组件实例化后第一时间调用\n\n2.尽量在Awake设置对象的引用，在Start传递信息\nTest1.cs\nText note; private void Awake()&#123;    note = gameObject.AddComponent&lt;Text&gt;();&#125;public void MakeNote(string content)&#123;    note.text = content;&#125;\n\nTest2.cs\nTest1 t;private void Awake()&#123;    GameObject go = new GameObject(&quot;text&quot;);    t = go.AddComponent&lt;Test1&gt;();&#125;private void Start()&#123;    t.MakeNote(&quot;Hello,world&quot;);&#125;\n\n以上代码如果Test1的note引用在Start里面设置，那么Test2的Start调用MakeNote函数，是会报空引用的\n3.手动在Inspector中添加脚本，同一个物体下的脚本，会按住加入的顺序，后加入的总是会最先实例化\n应该是unity用栈来维护component的运行顺序\npublic class Test1 : MonoBehaviour&#123;    private void Awake()    &#123;        Debug.Log(&quot;Test1 Awake&quot;);    &#125;    private void Start()    &#123;        Debug.Log(&quot;Test1 Start&quot;);    &#125;&#125;public class Test2:MonoBehaviour&#123;    private void Awake()    &#123;        Debug.Log(&quot;Test2 Awake&quot;);        Test3 t3 = transform.GetComponent&lt;Test3&gt;();        Debug.Log(&quot;Test2 go:&quot; + t3.go);    &#125;    private void Start()    &#123;        Debug.Log(&quot;Test2 Start&quot;);    &#125;&#125;public class Test3 : MonoBehaviour&#123;    public GameObject go;    private void Awake()    &#123;        Debug.Log(&quot;Test3 Awake&quot;);        go = new GameObject(&quot;Go&quot;);        Debug.Log(&quot;Test3 go:&quot; + go);    &#125;    private void Start()    &#123;        Debug.Log(&quot;Test3 Start&quot;);    &#125;&#125;\n\n\n4. Awake和Start都可以开启协程，并且Start可以是一个协程\nprivate void Awake()&#123;    Debug.Log(&quot;Test1 Awake&quot;);&#125;private IEnumerator Start()&#123;    yield return null;    Debug.Log(&quot;Test1 Start&quot;);&#125;private void Update()&#123;    Debug.Log(&quot;Test2 Update&quot;);    &#125;\n\n\n实际上Start还是在Update前面执行的，只不过碰到了协程等待没有执行后续语句\nOnEnable和OnDisableOnEnable在Start之前调用\nOnDisable在Destroy前调用\n这两个函数一旦被修改则会瞬间跳转执行\nprivate void Update()&#123;    gameObject.SetActive(false);    Debug.Log(&quot;Update&quot;);&#125;private void OnDisable()&#123;    Debug.Log(&quot;OnDisable&quot;);&#125;\n\n​    \n尽管OnDisable在Update之后执行，但是瞬间跳转\n加上OnEnable，同样的因为瞬间跳转执行：\n\n","categories":["Unity"],"tags":["生命周期","事件函数"]},{"title":"热更版本检测与更新流程","url":"/2022/06/12/Unity/%E7%83%AD%E6%9B%B4%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/","content":"热更版本检测与更新机制版本检测打包准备每次打包，要对应生成一个配置文件，assetslist.txt\n记录打包时间\n用于专门打包的PC（高配CPU和内存）\nSVN，GIT，更新到最新版本，然后执行框架的打包功能\nassetslist.txt\n第一行 打包时间：实际就是大版本号\n\n每次打包版本号不能相同\n版本号是递增的\n版本号要有一定的隐蔽性\n\n** 第二行 所有打包资源的描述**\nab包名，MD5信息，资源包size，其他自定义辅助信息\n\n依赖问题：\n\nAB包资源管理器，在使用一个asset时，根据依赖文件，找到所依赖的所有ab包，并先行加载，然后再加载自己\n按照功能模块划分资源，然后公共资源独立\n模块运行前，先加载公共资源，再加载模块资源\n可以一次性全部加载，也可以按需加载\n\n清理资源：\n\n功能关闭，清理对应的ab包\n也可以，延时清理，倒计时N秒， 防止关闭又在短时间内打开，减少消耗\n\n高级机制：结合业务\n\n比如有个功能，10级之前，使用非常频繁，10级之后，不太使用\n那么在清理的时候，就可以加一个维度判断\n在10级之前，N可以设置长一点，10级之后，N再设置短一点，后续可直接设置成0\n更新检测原理在客户端启动时\n\n检测服务器上最新的assetslist的大版本号，和本地的assetslist的大版本号，如果本地小于服务器，则向下执行\n逐一判断服务器当前版本的AB包的MD5信息与本地对应的MD5信息做比较，如果相同，则不需要下载，如果不同，则添加到下载列表\n减少重复下载\n安全检测\n\n\n根据下载列表，开始下载\n\n更新\npersistentDataPath\n可读可写，从服务器下载下来的byte文件，形成资源文件，写入目录\n\n\nStreamingAssets\n只读，不加密\n在更新了一段时间后，随着需要更新的AB包增多，新玩家在下载游戏后，又要等待下载新的AB包，显然是不好的，不如把新的AB包直接放到这个文件夹下，随着包打个新的渠道，下载的时候，就直接下载整个apk，而不需要在apk下载好后，又进行一大段更新而影响体验\n通过UnityWebRequest读取，放到persistentDataPath下，再进行热更判断\n\n\nResources\n只读，加密，可以放一些不用热更新的资源\n\n\n资源服务器\n通过IP地址，定位资源服务器在网络的位置，生产环境，不能直接使用IP\n如果IP写死，那么在服务器需要更换时就会很麻烦，可以使用域名，通过域名解绑\n使用一个IP服务器，从IP服务器上获取资源服务器地址\n接入CDN节点，下载速度得到加快\n\n\n\n具体流程\n项目启动，进入热更新检测模块\n判断persistentDataPath是否存在\n不存在，则创建目录，并且创建assetslist.txt，版本号为0\n\n\n从StreamingAssets复制文件到persistentDataPath下（包括assetslist.txt）\n下载检测CheckResources\n从资源服务器下载assetslist.txt\n从本地persistentDataPath读取本地的assetslist.txt\n判断版本号是否需要热更\n若需要更新，则开始逐一检测服务器ab包\n本地不包含assetslist.txt里的ab包信息，直接加入下载列表\n本地存在，但MD5信息不一样，加入下载列表\n\n\n确定总下载大小和单个文件下载大小\n\n\n开启下载\n下载地址：IP + AB.name + MD5\nMD5：不同的两个文件，MD5完全不同，通过MD5可以检测文件是否被破\nMD5：防止客户端黑客知道资源下载地址，因为每次打包的MD5都不一样，所以别人无法获取最新的下载地址\n\n\n通过UnityWebRequest下载\n通过File.WriteAllBytes写入到persistentDataPath的对应AB包文件下（其实就是把服务器资源写入客户端硬盘上）\n更新本地assetslist.txt\n\n\n下载完成后\n资源处理\n常驻内存资源先读取并加载，lua，字体font，shader，sound等\n\n\n初始化游戏\n\n\n\n","categories":["Unity"],"tags":["热更新"]},{"title":"移动方式","url":"/2022/04/03/Unity/%E7%A7%BB%E5%8A%A8%E6%96%B9%E5%BC%8F/","content":"using UnityEngine;public class MoveModeTest : MonoBehaviour&#123;    public float speed;    public Transform startPoint; //巡逻起始点    public Transform endPoint;  //巡逻结束点    private float startTime;  //开始巡逻时间    private float btDistance; //巡逻两点间间距    public float smoothTime;    public Vector3 vt = Vector3.zero;    private Rigidbody rb;    private void Start()    &#123;        startTime = Time.time;        btDistance = Vector3.Distance(startPoint.position, endPoint.position);        rb = this.GetComponent&lt;Rigidbody&gt;();    &#125;    private void Update()    &#123;        //TransMove1();        //TransMove2();        //TransMove3();        //V3Move1();        //V3Move2();        //RbMove1();        //RbMove2();        RbMove3();    &#125;    private void FixedUpdate()    &#123;        //RbMove2();    &#125;    /// &lt;summary&gt;    /// transform变换-position计算移动    /// 整体移动观感僵硬，设置key代码重复率高，受帧率影响    /// &lt;/summary&gt;        void TransMove1()    &#123;        if (Input.GetKey(KeyCode.W))        &#123;            transform.position =                new Vector3(transform.position.x, transform.position.y, transform.position.z + Time.deltaTime * speed);        &#125;        if (Input.GetKey(KeyCode.S))        &#123;            transform.position =                new Vector3(transform.position.x, transform.position.y, transform.position.z - Time.deltaTime * speed);        &#125;        if (Input.GetKey(KeyCode.A))        &#123;            transform.position =                new Vector3(transform.position.x - Time.deltaTime * speed, transform.position.y, transform.position.z);        &#125;        if (Input.GetKey(KeyCode.D))        &#123;            transform.position =                new Vector3(transform.position.x + Time.deltaTime * speed, transform.position.y, transform.position.z);        &#125;    &#125;    /// &lt;summary&gt;    /// transform变化-translate + V3 + GetAxis    /// 有一定的惯性，同样8向平滑，因为Axis输入方法不受帧率影响，整体流畅度更好，代码更加简洁    /// &lt;/summary&gt;    void TransMove2()    &#123;        float h = Input.GetAxis(&quot;Horizontal&quot;) * Time.deltaTime * speed;        float v = Input.GetAxis(&quot;Vertical&quot;) * Time.deltaTime * speed;                transform.Translate(new Vector3(h, 0, v));    &#125;    /// &lt;summary&gt;    /// transform变化-transform + V3 + KeyCode    /// 与position移动相似    /// &lt;/summary&gt;    void TransMove3()    &#123;        if (Input.GetKey(KeyCode.W))        &#123;            transform.Translate(Vector3.forward * Time.deltaTime * speed);        &#125;        if (Input.GetKey(KeyCode.S))        &#123;            transform.Translate(Vector3.back * Time.deltaTime * speed);        &#125;        if (Input.GetKey(KeyCode.A))        &#123;            transform.Translate(Vector3.left * Time.deltaTime * speed);        &#125;        if (Input.GetKey(KeyCode.D))        &#123;            transform.Translate(Vector3.right * Time.deltaTime * speed);        &#125;    &#125;    /// &lt;summary&gt;    /// 线性插值    /// &lt;/summary&gt;    void V3Move1()    &#123;        float moved = (Time.time - startTime) * speed; //已走路程(m) = 时间(s) * 速度(m/s)        float fractionOfBtDistance = moved / btDistance;        //当前位置 = 已走路程的百分比        transform.position = Vector3.Lerp(startPoint.position, endPoint.position, fractionOfBtDistance);    &#125;    /// &lt;summary&gt;    /// 平滑阻尼,相机跟随角色移动    /// 随时间推移将一个向量逐渐改变为所需目标    /// 无论物体或是摄像机，都可以平滑过渡    /// &lt;/summary&gt;    void V3Move2()    &#123;        transform.position = Vector3.SmoothDamp(transform.position, new Vector3(0, 0, 10), ref vt, smoothTime);    &#125;       /// &lt;summary&gt;    /// 刚体移动-velocity 与质量无关，自行递减速度，有重力的情况下会模拟摩擦力    /// &lt;/summary&gt;    void RbMove1()    &#123;        if (Input.GetKey(KeyCode.W))        &#123;            rb.velocity += new Vector3(0, 0, speed) * Time.deltaTime; //向z轴方向添加speed的速度        &#125;        if (Input.GetKey(KeyCode.S))        &#123;            rb.velocity -= new Vector3(0, 0, speed) * Time.deltaTime; //向z轴方向添加speed的速度        &#125;    &#125;    /// &lt;summary&gt;    /// 刚体移动-MovePosition，掉帧，建议在FixedUpdate使用    /// 启用interpolate刚体插值情况下调用    /// &lt;/summary&gt;    void RbMove2()    &#123;        float h = Input.GetAxis(&quot;Horizontal&quot;) * Time.deltaTime * speed;        float v = Input.GetAxis(&quot;Vertical&quot;) * Time.deltaTime * speed;        //原来的位置 + 输入的位置\t        rb.MovePosition(transform.position + new Vector3(h, 0, v));    &#125;        /// &lt;summary&gt;    /// 刚体移动-Addforce，与质量相关    /// 适合做飞行物投掷物的冲击效果    /// &lt;/summary&gt;    void RbMove3()    &#123;        if (Input.GetKey(KeyCode.W))        &#123;            rb.AddForce(new Vector3(0, 0, 50)); //顺着Z轴给一个力        &#125;        if (Input.GetKey(KeyCode.S))        &#123;            rb.AddForce(new Vector3(0, 0, -50));        &#125;    &#125;&#125;\n\n参考：https://www.bilibili.com/video/BV1iT4y1i7Ga/?spm_id_from=333.788\n//输入坐标在世界坐标系上的位置 减去 自身坐标，指向输入的坐标点motion = transform.TransformPoint(new Vector3(x, 0, z)) - transform.position;chController.Move(motion * Time.deltaTime * moveSpeed;transform.Translate(new Vector3(x,0,z) * Time.deltaTime * moveSpeed;\n\n\n\n","categories":["Unity"],"tags":["Unity","移动"]},{"title":"随便记录","url":"/2022/06/26/Unity/%E9%9A%8F%E4%BE%BF%E8%AE%B0%E5%BD%95/","content":"杂\nJump end 动作没做完，就按下空格，导致使用连跳时，会先播放ground动作，天上跑\n\n从 end 增加 jumping 触发条件到 loop 动作，fall优先判断是否起跳，完美解决\n\n\n物理引擎不计算图层 edit -&gt; project setting -&gt; physics\n\n按住shift奔跑改为长按方向\n\n在按住方向键时，开启计时器，如果达到规定时间，则isRun\nisRun开启下，不计时\n松手一秒钟后isRun关闭\n\n\n在编辑器配置好脚本所需列表参数，运行后，列表数量归0\n\n脚本中，列表List的初始化放在了start中导致，直接在声明时初始化解决了问题\n\n\n在激活对象池对象时，需要重置位置，新对象却不调用重置方法\n\n调用方法所需变量目标点变换组件的赋值放在了Start里面，导致第二次激活时没有调用\nStart只在开始时执行一次，对象禁用后，不会重新计算这个生命周期！！！\n\n\n重置方法放错位置，导致在新对象创建时，不会调用\n\n\n带有碰撞体和刚体不触发碰撞\n\n设置层级关系\n\n\n根据击中物体，生成特效\n\n对象池生成对象的名字：自定义命名规则，Effects + 身体部位\n再根据预制件名字通过资源管理类寻找\n\n\n值类型不会为空，除非加 ? 做可空值类型\n\nhit.normal 特效z轴与法线一致\n\n特效重合导致若隐若现\n\n朝法线方向移动一点点\n\n\nAI在到达攻击范围后任然会保持追逐状态，导致原地踏步\n\n攻击目标消失条件判定的距离和到达攻击范围内判定的距离一个是大于，一个小于等于，导致可能出现无限在这两个状态间切换\n增加了一点点攻击目标消失条件判定的距离，使这两个不共用一个判定距离\n\n\nUI面板push多执行了OnStart方法，导致按钮时间多绑定了一次，点一次，执行了两次Pop\n\n调整调用OnStart方法的位置\n\n\n场景切换，面板不出现\n\n面板生成在了第一个场景Canvas下，随着第一个场景的Canvas一起销毁了\n不销毁第一个Canvas\n\n\nSetting the parent of a transform which resides in a Prefab Asset is disabled to prevent data corruption\n设置预制体的父物体是不允许的\n\n在加载预制体后，未对其进行实例化\n\n原代码\nGameObject obj = ResourceManager.Load&lt;GameObject&gt;(&quot;ArticleItem&quot;); \n更改为\n//加载预制体并实例化GameObject obj = GameObject.Instantiate(ResourceManager.Load&lt;GameObject&gt;(&quot;ArticleItem&quot;)); \n\n\n加上canvas后Button无法检测\n\nhttps://blog.csdn.net/weixin_43673589/article/details/121236786\n\n\nToggle组要实现循环设置监听，就要给各个Toggle设置相对应的编号，而不能用for循环里面的变量\n//添加监听for (int i = 0; i &lt; toggles.Length; i++)&#123;    int k = i; //必须记录，直接把i填进去就没有效果\ttoggles[i].onValueChanged.AddListener((bool value) =&gt; ShowTaskDetails(value, k));&#125;//在多个连续的Toggle中可以准确的获知所点击的toggle下标\n开启navMeshAgent后，旋转被其所控制，这时如果在水平移动鼠标，角色转向跟随鼠标，方向却还是往目标点去\n\n开启寻路后，不要让鼠标水平移动控制角色外层旋转，而是控制相机跟随点，相机跟随点本地旋转，不影响角色的移动旋转，这样才能实现在寻路过程中还能自由控制相机的旋转\n\n\n一些脚本在启动游戏时虽然不是开启状态，Awake照样会调用，除非游戏对象未启用\n\n编辑器允许多目录，unity会把多目录合并成一个，但是目录下不能重名\n\nunityEditor 不能被打包\n\nSerializeField unity会将对象进行序列化存储，所以即使是私有的，那么标记为可序列化后，就会显示，公有默认是可序列化的\n\n[ExecuteInEditMode] 是生命周期函数可以在编辑器模式下执行 Update在场景中对象发生变化或项目组织发生变化时执行\n\nunity的内存管理机制 懒回收的管理机制\n\nAB包被卸载，显示的资源是不会被卸载的\n\n粒子产生位置偏移\n\nEmitter Velocity mode 改为跟踪Transform来计算速度\n\n\nDontDestroyOnLoad的坑\n\n场景来回切换，会生成两个游戏物体\n\n```c#GameObject[] players = GameObject.FindGameObjectsWithTag(“Player”);if (players.Length &gt; 1){\nDestroy(players[1]);\n\n}else{\nDontDestroyOnLoad(player);\n\n}\n    * 删除掉多出来的一个    29. AB包打包不允许有任何报错，否则就打不出来30. 不能用File.Exits() 判断streamingAssets下的资源是否存在，永远返回false，网上的解释是因为streamingAssets本身是一个虚拟路径，并不真实存在31. 消息传递：    * 广播消息 BroadcastMessage() ，广播给所有的孩子      * 可降低代码的耦合性    * sendMessage 只能发送同物体身上脚本    * sendMessageUpwards 向上发送## SQLite### 准备因为不同版本unity可能不兼容Plugins文件夹下放入，mono.Data.Sqlite.dll（编辑器找）和libsqlite3和sqlite3.dll（官网下载）### 操作* 每次操作都需要开启和关闭* 同名表单只能有一份  * 连续创建即报错* 文本输入不是纯数字，必须加上单引号* 查询多条数据时，需要把读取代码放入循环中，直至读完* 直接在编辑器中删除数据库，是没法真正删除的  * 关闭unity，在文件路径中删除* 发布版本同sqlite3同样64位## 优化降低Draw Calls数### 动态批处理1. 网格顶点数3002. 材质相同且材质着色器必须是单pass3. 纹理不影响4. 必须是Mesh Renderer 渲染的组件5. 每个物体的阴影占用一个6. 所有静态物体不参与7. 缩放倍数相差大时无法参与### 静态批处理场景，建筑1. 必须是静态2. 和顶点无关3. pass无关4. 和缩放有关，过大则不参与## 特殊文件夹1. standard Assets 此文件夹下脚本最先被编译，里面会放一些Unity自带的组件，如3rd Person Controller等2.  Pro Standard Assets文件夹，这个文件夹紧接着上一个编译，但是存放的是专业版才有的功能3. Plugins 插件目录，只能是Assets文件夹的直接子目录，优先编译* 以上三个文件夹中的脚本都不会调用其他文件夹中的脚本，所以被优先编译不会报错，但是它们可以通过GameObject.SendMessage()和其他脚本通信1. Editor 允许里面的脚本访问 unity edior的API2. Gizmos，存放用Gizmos.DrawIcon方法使用的贴图，图标资源。放在Gizmos文件夹中的贴图资源可以直接通过名称使用，可以被Editor作为gizmo画在屏幕上Resources：* 里面的的文件不管有没使用，都会跟随游戏一起打包。* 打包后只读* 资源会被压缩成二进制* 无法动态更改* 可以使用Resources.UnloadUnusedAssets释放内存StreamingAssets：* UnityWebRequest加载* 打包资源，二进制文件放在此文件夹下才能够随工程打包* 不压缩不加密* PC端是可读可写的在移动端1. 不能使用FILE等等文件操作来访问，安卓沙盒采用协议地址，文件类找不到2. 要修改只能复制到PersistentDataPath下3. 只读* 几个平台下的路径：  ```c#  #if UNITY_EDITOR || UNITY_STANDALONE              url = &quot;file://&quot; + Application.dataPath + &quot;/StreamingAssets/&quot; + fileName;  #elif UNITY_IPHONE              url = &quot;file://&quot; + Application.dataPath + &quot;/Raw/&quot; + fileName;  #elif UNITY_ANDROID              url = &quot;jar:file://&quot; + Application.dataPath + &quot;!/assets/&quot; + fileName;  #endif\n\n\n\nPersistentDataPath：\n\n可读可写\n\n只能在运行时进行写入读取\n\n\n移动\n\n在安卓可以是程序的沙盒，也可以是sdcard\n\n文件PlayerPrefs 本地持久化\n需要创建一个【Key键名】然后通过PlayerPrefs.GetInt(Key)来获取【value值】\n每一个键名只能对应一个值，也就是说，保存变量有五个，就需要创建五个键\n不适用与存储相对复杂的内容\n适用于存储用户选项设置，图片，简单数值\n\n序列化反序列化中二进制存储\n保存的文件因为是二进制，阅读困难\n\nJSON\n轻量级的数据交换格式\n仅支持简单类型，不支持集合，如字典（但是支持List）\n体积小，速度快\n\nXML\n可以将大量的信息通过XML元素的心事储存在xmlDocument中\n解析得考虑，根元素，子元素，加载过程还要通过 标签名找到xml元素的集合\n冗余信息较多，占用空间最大，文件格式较为复杂，解析文件需要花费较多资源和时间\n\nxLuaxlua_v2.1.15\n泛型Action用不了，Toggle添加不了监听\n\nhttps://blog.csdn.net/woodengm/article/details/112614506?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-112614506-blog-124702410.pc_relevant_antiscanv3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=2\n这个版本不需要像链接这样做，但是打开ExampleConfig热补丁配置文件全部都是被注释的，取消注释就好了\n\n\nToggle监听不能添加带self的函数，无效\n\nnil不能进行字符串拼接\n\n在Lua中调用C# 泛型List 并且使用Find方法，需要传入一个委托，跟第一点一样\n\n\n\n\n需要把我们自己定义的泛型加入到XLua的ExampleConfig下\n\n","categories":["Unity"],"tags":["特殊文件夹","sqlite","批处理","BUG","xLua","文件存储"]},{"title":"第十章 信号量和管程","url":"/2021/11/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter10%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E7%AE%A1%E7%A8%8B/","content":"第十章 信号量和管程信号量信号量的抽象数据类型\n\n一个整形(sem),具有两个原子操作\nP(): sem减一,如果sem&lt;0,等待,否则继续\nV(): sem加一,如果sem≤0,唤醒一个等待的P\n\n信号量是整形\n信号量是被保护的变量\n\n初始化完成后,唯一改变一个信号量的值的办法是通过P()和V()\n操作必须是原子\n\nP()能够阻塞,V()不会阻塞\n我们假定信号量是公平的\n\n没有线程被阻塞在P()仍然堵塞如果V()被无限频繁调用(在同一个信号量)\n在实践中,FIFO经常被使用\n\n两个类型信号量\n\n二进制信号量: 可以是0或1\n计数信号量: 可以取任何非负数\n两者相互表现(给定一个可以实现另一个)\n\n信号量可以用在2个方面\n\n互斥\n条件同步(调度约束——一个线程等待另一个线程的事情发生)\n\n10.3 信号量的使用\n用二进制信号量实现的互斥\nmutex = new Semaphore(1);mutex-&gt;P();...mutex-&gt;V();\n用二进制信号量实现的调度约束\ncondition = new Semaphore(0);//Thread A...condition-&gt;P(); //等待线程B某一些指令完成之后再继续运行,在此阻塞...//Thread B...condition-&gt;V(); //信号量增加唤醒线程A...\n\n\n一个线程等待另一个线程处理事情\n比如生产东西或消费东西(生产者消费者模式)\n互斥(锁机制)是不够的\n有界缓冲区的生产者-消费者问题\n一个或者多个生产者产生数据将数据放在一个缓冲区里\n单个消费者每次从缓冲区取出数据\n在任何一个时间只有一个生产者或消费者可以访问该缓冲区\n\n\n\n正确性要求\n\n在任何一个时间只能有一个线程操作缓冲区(互斥)\n当缓冲区为空时,消费者必须等待生产者(调度,同步约束)\n当缓存区满,生产者必须等待消费者(调度,同步约束)\n\n每个约束用一个单独的信号量\n\n二进制信号量互斥\n一般信号量 fullBuffers\n一般信号了 emptyBuffers\n\nclass BoundedBuffer&#123;\t\tmutex = new Semaphore(1);\t\tfullBuffers = new Semaphore(0);   //说明缓冲区初始为空 \t\temptyBuffers = new Semaphore(n);  //同时可以有n个生产者来生产&#125;;BoundedBuffer::Deposit(c)&#123;\t\temptyBuffers-&gt;P();\t\tmutex-&gt;P();\t\tAdd c to the buffer;\t\tmutex-&gt;V();\t\tfullBuffers-&gt;V();&#125;BoundedBuffer::Remove(c)&#123;\t\tfullBuffers-&gt;P();\t\tmutex-&gt;P();\t\tRemove c from buffer;\t\tmutex-&gt;V();\t\temptyBuffers-&gt;V();&#125;\n\n10.4 信号量的实现使用硬件原语\n\n禁用中断\n原子指令\n\n类似锁\n\n禁用中断\n\nclass Semaphore&#123;\t\tint sem;\t\tWaitQueue q;&#125;;Semaphore::P()&#123;\t\t--sem;\t\tif(sem &lt; 0)&#123;\t\t\t\tAdd this thread t to q;\t\t\t\tblock(p);\t\t&#125;&#125;;Semaphore::V()&#123;\t\t++sem;\t\tif(sem &lt;= 0)&#123;\t\t\t\tRemove a thread t from q;\t\t\t\twakeup(t);\t\t&#125;&#125;\n\n信号量的双用途\n\n互斥和条件同步\n但等待条件是独立的互斥\n\n读,开发代码比较困难\n\n程序员必须非常精通信号量\n\n容易出错\n\n使用的信号量已经被另一个线程占用\n忘记释放信号量\n\n不能够处理死锁问题\n10.5 管程管程是包含了一系列的共享变量，以及针对共享变量的操作函数的组合模块\n目的：分离互斥和条件同步的关注\n什么是管程\n\n一个锁：指定临界区\n0或者多个条件变量：等待/通知信号用于管理并发访问共享数据\n\n一般方法\n\n收集在对象/模块中的相关共享数据\n定义方法来访问共享数据\n\nLock\n\nLock::Acquire() 等待直到锁可用,然后抢占锁\nLock::Release() 释放锁,唤醒等待者如果有\n\nCondition Variable\n\n允许等待状态进入临界区\n允许处于等待(睡眠)的线程进入临界区\n某个时刻原子释放锁进入睡眠\n\n\nWait() operation\n释放锁,睡眠,重新获得锁放回\n\n\nSignal() operation(or broadcast() operation)\n唤醒等待者(或者所有等待者),如果有\n\n\n\n实现\n\n需要维持每个条件队列\n\n线程等待的条件等待signal（）\nclass Condition&#123;\t\tint numWaiting = 0;\t\tWaitQueue q;&#125;;Condition::Wait(lock)&#123;\t\tnumWaiting++;\t\tAdd this thread t to q;\t\trelease(lock);\t\tschedule(); //need mutex\t\trequire(lock);&#125;Condition::Signal()&#123;\t\tif(numWaiting &gt; 0)&#123;\t\t\t\tRemove a thread t from q;\t\t\t\twakeup(t); //need mutex\t\t\t\tnumWaiting--;\t\t&#125;&#125;\n管程解决生产者-消费者问题\nclass BoundedBuffer&#123;\t\tLock lock;\t\tint count = 0;  //buffer 为空\t\tCondition notFull,notEmpty;&#125;;BoundedBuffer::Deposit(c)&#123;\t\tlock-&gt;Acquire();    //管程的定义:只有一个线程能够进入管程\t\twhile(count == n)\t\t\tnotFull.Wait(&amp;lock); //释放前面的锁\t\tAdd c to the buffer;\t\tcount++;\t\tnotEmpty.Signal();\t\tlock-&gt;Release();&#125;BoundedBuffer::Remove(c)&#123;\t\tlock-&gt;Acquire();\t\twhile(count == 0)\t\t\tnotEmpty.Wait(&amp;lock);\t\tRemove c from buffer;\t\tcount--;\t\tnotFull.Signal();\t\tlock-&gt;Release();&#125;\n\n由于同步互斥机制的存在，即使有方法解决，但由于不确定性\n\n开发/调试并行程序很难\n\n非确定性的交叉指令\n\n\n同步结构\n\n锁：互斥\n条件变量：有条件的同步\n其他原语：信号量\n\n\n怎样有效的使用这些结构\n\n制定并遵循严格的程序设计风格/策略\n\n\n\n10.6-10.8 经典同步问题读者-写者问题动机\n\n共享数据访问\n\n两种类型使用者\n\n读者：不需要修改数据\n写者：读取和修改数据\n\n问题的约束\n\n允许同一时间有多个读者，但在任何时候只有一个写者\n当没有写者时，读者才能访问数据\n当没有读者和写者时，写者才能访问数据\n在任何时候只能有一个线程可以操作共享变量\n\n多个并发进程的数据集共享\n\n读者 - 只读数据集：他们不执行任何更新\n写者 - 可以读取和写入\n\n共享数据\n\n数据集\n信号量CountMutex初始化为1\n信号量WriteMutex初始化为1\n整数Rcount（读者的个数）初始化为0\n\n\n读者优先\n\n只要有一个读者处于活动状态, 后来的读者都会被接纳.如果读者源源不断的出现,那么写者使用处于阻塞状态\n//信号量实现//writersem_wait(WriteMutex);write;sem_post(WriteMutex);//readersem_wait(CountMutex);if(Rcount == 0)\t\tsem_wait(WriteMutex); //确保后续不会有写者进入++Rcount;read;--Rcount;if(Rcount == 0)\t\tsem_post(WriteMutex); //全部读者全部离开才能唤醒写者sem_post(CountMutex);\n\n\n写者优先\n\n一旦写者就绪,那么写者会尽可能的执行写操作.如果写者源源不断的出现的话,那么读者就始终处于阻塞状态\n//writerDatabase::Write()&#123;\t\tWait until readers/writers;\t\twrite database;\t\tcheck out - wake up waiting readers/writers;&#125;//readerDatabase::Read()&#123;\t\tWait until no writers;\t\tread database;\t\tcheck out - wake up waiting writers;&#125;//管程实现AR = 0; // # of active readersAW = 0; // # of active writersWR = 0; // # of waiting readersWW = 0; // # of waiting writersCondition okToRead;Condition okToWrite;Lock lock;//writerPublic Database::Write()&#123;\t\t//Wait until no readers/writers;\t\tStartWrite();\t\twrite database;\t\t//check out - wake up waiting readers/writers;\t\tDoneWrite();&#125;Private Database::StartWrite()&#123;\t\tlock.Acquire();\t\twhile((AW + AR) &gt; 0)&#123;\t\t\t\tWW++;\t\t\t\tokToWrite.wait(&amp;lock);\t\t\t\tWW--;\t\t\t\t&#125;\t\tAW++;\t\tlock.Release();&#125;Private Database::DoneWrite()&#123;\t\tlock.Acquire();\t\tAW--;\t\tif(WW &gt; 0)&#123;\t\t\t\tokToWrite.signal();\t\t&#125;\t\telse if(WR &gt; 0)&#123;\t\t\t\tokToRead.broadcast(); //唤醒所有reader \t\t&#125;\t\tlock.Release();&#125;//readerPublic Database::Read()&#123;\t\t//Wait until no writers;\t\tStartRead();\t\tread database;\t\t//check out - wake up waiting writers;\t\tDoneRead();&#125;Private Database::StartRead()&#123;\t\tlock.Acquire();\t\twhile(AW + WW &gt; 0)&#123;    //关注等待的writer,体现出写者优先\t\t\t\tWR++;\t\t\t\tokToRead.wait(&amp;lock);\t\t\t\tWR--;\t\t&#125;\t\tAR++;\t\tlock.Release();&#125;private Database::DoneRead()&#123;\t\tlock.Acquire();\t\tAR--;\t\tif(AR == 0 &amp;&amp; WW &gt; 0)&#123;  //只有读者全部没有了,才需要唤醒\t\t\t\tokToWrite.signal();\t\t&#125;\t\tlock.Release();&#125;\n\n10.9-10.11 哲学家就餐问题怎么来编写程序？\n\n必须有数据结构，来描述每个哲学家的当前状态；\n该状态是一个临界资源，各个哲学家对它的访问应该互斥地进行——进程互斥；\n一个哲学家吃饱后，可能要唤醒它的左邻右舍，两者之间存在着同步关系——进程同步；\n\n共享数据:Bowl of rice(data set)Semaphone fork [5] initialized to 1    #define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N    // 右邻居#define THINKING 0#define HUNGRY   1#define EATING   2typedef int semaphore;int state[N];                // 跟踪每个哲学家的状态semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥semaphore s[N];              // 每个哲学家一个信号量void philosopher(int i) &#123;    while(TRUE) &#123;        think(i);        take_two(i);        eat(i);        put_two(i);    &#125;&#125;void take_two(int i) &#123;    down(&amp;mutex);    state[i] = HUNGRY;    check(i);    up(&amp;mutex);    down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去&#125;void put_two(i) &#123;    down(&amp;mutex);    state[i] = THINKING;    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了    check(RIGHT);    up(&amp;mutex);&#125;void eat(int i) &#123;    down(&amp;mutex);    state[i] = EATING;    up(&amp;mutex);&#125;// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行void check(i) &#123;             if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;        state[i] = EATING;        up(&amp;s[i]);    &#125;&#125;\n\n","categories":["操作系统"],"tags":["信号量","管程"]},{"title":"第十一章 死锁","url":"/2021/11/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter11%E6%AD%BB%E9%94%81/","content":"第十一章 死锁一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源\n由于进程的并发执行的情况导致出现死锁\n通常操作系统一般遇到死锁都使用鸵鸟算法（不理会）\n11.2 系统模型需求方：进程        需求资源：CPU，内存单元，I/O。。。\n进程对资源的访问情况：\n\n需要资源——向空闲资源申请\n得到资源——资源变为被使用状态，其他进程则不能用\n使用资源时间有限——用完释放（free）\n\n可重复使用的资源\n\n在一个时间只能一个进程使用且不能被删除\n进程获得资源，后来释放由其他进程重用\n处理器，I/O通道，主和副存储器，设备和数据结构，如文件，数据库和信号量\n如果每个进程拥有一个资源并请求其他资源，死锁可能发生\n\n使用资源\n\n创建和销毁\n在I/O缓冲区的中断，信号，消息，信息\n如果接受消息阻塞可能会发生死锁\n可能少见的组合事件会引起死锁\n\n资源分配图\n一组顶点V和边E的集合\n\nV有两种类型：\n\nP={P1,P2,…,Pn},集合包括系统中的所有进程\nR={R1,R2,…,Rm},集合包括系统中的所有资源类型\n\n\nrequesting,claiming edge - directed edge Pi → Rj\n\nassignment,holding edge - directed edge Rj → Pi\n\n\n基本情况\n\n如果如钟不包含循环==没有死锁\n如果图中包含循环\n如果每个资源类只有一个实例，那么死锁\n如果每个资源类有几个实例，可能死锁\n\n\n\n11.3 死锁特征死锁出现一定会出现以下四个条件，但是出现以下四个条件不一定死锁：（必要条件）\n\n互斥：在一个时间只能有一个进程使用资源\n持有并等待：进程保持至少一个资源正在等待获取其他进程持有的额外资源\n无抢占：一个资源只能被进程自愿释放，进程已经完成了它的任务之后\n 循坏等待：进程资源链接的关系形成了一个环\n\n\n11.4 死锁处理办法\n确保系统永远不会进入死锁状态\n\n运行系统进入死锁状态，然后恢复\n\n忽略这个问题，假装系统中从来没有发生死锁；用于大多数操作系统，包括UNIX\n\n\n11.5 死锁预防和死锁避免死锁预防限制申请方式\n\n互斥 - 共享资源不是必须的，必须占用非共享资源\n\n占用并等待 - 必须保证当一个进程请求的资源，它不持有任何其他资源（要么拿所有资源，要么sleep）\n\n需要进程请求并分配其所有资源，它开始执行之前或允许进程请求资源仅当进程没有资源\n资源利用率低：可能发生饥饿\n\n\n无抢占\n\n如果进程占有某些资源，并请求其他不能被立即分配的资源，则释放当前正占有的资源\n被抢占资源添加到资源列表中\n只有当它能够获得旧的资源以及它请求新的资源，进程可以得到执行\n\n\n循环等待 - 对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请\n\n确保进程之间形不成环\n通用操作系统用的不多，嵌入式操作系统用的多\n\n\n\n死锁避免需要操作系统具有一些额外的先验信息提供\n\n最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目\n\n资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求（不超过最大）\n\n死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态（不安全状态，处于环形并不一定是死锁，约束较大）\n\n当一个进程请求可用资源，系统必须判断立即分配是否能使系统处于安全状态\n\n系统处于安全状态指：针对所有进程，存在安全序列序列&lt;P1,P2,…,Pn&gt;是安全的: 针对每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,其中j&lt;i\n\n如果Pi资源的需求不是立即可用，那么Pi可以等到所有Pj完成\n当Pi完成后，Pi+1可以得到所需要的的资源，执行，返回所分配的资源，并终止\n用同样的方法，Pi+2，Pi+3和Pn能够获得其所需的资源\n\n\n如果系统处于安全状态==无死锁\n\n如果系统处于不安全状态==可能死锁\n\n避免死锁：确保操作系统永远不会进入不安全状态\n\n\n11.6 银行家算法Banker‘s Algorithm 前提条件\n\n多个资源实例\n\n每个进程都必须能最大限度地利用资源\n\n当一个进程请求一个资源，就不得不等待\n\n当一个进程获得所有的资源就必须在一段有限的时间释放它们\n\n\n银行家算法数据结构\nn = 进程数量，m = 资源类型数量\n\nmax（总需求量）：n*m矩阵。如果max[i , j] = k，表示进程Pi最多请求资源类型Rj的k个实例\n\nAvailable（剩余空闲量）：长度为m的向量。如果Available[j] = k，有k个类型Rj的资源实例可用\n\nAllocation（已分配量）：n*m矩阵。如果Allocation[i , j] = k，则Pi当前分配了k个Rj的实例\n\nNeed（未来需要量）：n*m矩阵。如果Need[i , j] = k，则Pi可能需要至少k个Rj实例完成任务\n\n\nNeed[i , j] = max[i , j] - Allocation[i , j] \n  具体算法：\n\nwork和finish分别是长度m和n的向量\n初始化： work = Available         //当前资源剩余空闲量\n​                finish[i] = false for i - 1,2，。。。，n     //线程i没结束\n\n找这样的i：        //接下来找出need比work小的进程i\n\nfinish[i] = false\n\nneedi&lt;=work\n没有找到这样的i，转到4。\n\n\n\nwork = work + Allocation      //进程i的资源需求量小于剩余空闲资源量，所以配置给它再回收\nfinish[i] = true\n转到2.\n\nif finish[i] == true for all i,           //所有进程的finish为true，表明系统处于安全状态\n\n\n\n11.7 死锁检测和死锁恢复死锁检测\n允许系统进入死锁状态\n死锁检测算法\n恢复机制\n\n\n开销大，更多用在调试系统与应用程序\n检测算法使用\n\n何时，使用什么样的频率来检测依赖于：\n\n死锁多久可能会发生？\n多久进程需要被回滚？\n\n\n如果检测算法多次被调用，有可能是资源图有多个循环，所以我们无法分辨出多个可能死锁进程中的哪些”造成”死锁\n\n\n死锁恢复\n终止所有的死锁进程\n在一个时间内终止一个进程直到死锁消除\n终止进程的顺序应该是\n进程的优先级\n进程运行了多久以及需要多少时间才能完成\n进程占用的资源\n进程完成需要的资源\n多少进程需要被终止\n进程是交互还是批处理\n\n\n\n存在强制性和不合理性\n死锁恢复是出现死锁的最后手段\n资源抢占：\n\n选择一个受害者 - 最小的成本\n回滚 - 返回一些安全状态，重启进程到安全状态\n饥饿 - 同一进程可能一直被选做受害者，包括回滚的数量\n\n11.8 IPC（进程间通讯）进程之间相互保存独立，一个进程不能访问另一个进程的地址空间\n进程与进程之间也需要一定的沟通和协作来完成大的任务\n概述\n进程通信的机制及同步\n\n不使用共享变量的进程通信\n\nIPC facility 提供2个操作：\n\nsend（message）- 消息大小固定或者可变\nreceive（message）\n\n\n如果P和Q想通讯，需要：\n\n在它们之间建立通信链路\n通过send/receive交换信息\n\n\n通信链路的实现\n\n物理（例如，共享内存，硬件总线）\n逻辑（例如，逻辑属性）\n\n\n\n​    直接通讯\n\n进程必须正确的命名对方：\n\nsend（P, message）- 发送消息到进程P\nreceive（Q, message）- 从进程Q接收信息\n\n\n通信链路的属性\n\n自动建立链路\n一条链路恰好对应一对通信进程\n每对进程之间只有一个链路存在\n链路可以是单向的,但通常是双向的\n\n\n\n间接通讯\n\n定向从消息队列接受消息\n\n每个消息队列都有一个唯一的ID\n只有它们共享了一个消息队列，进程才能够通信\n\n\n通信链路的属性\n\n只有进程共享一个共同的消息队列,才建立链路\n链接可以与许多进程相关联\n每对进程可以共享多个通信链路\n链接可以是单向或者双向\n\n\n操作\n\n创建一个新的消息队列\n通过消息队列发送和接收消息\n销毁消息队列\n\n\n原语的定义如下:\n\nsend(A, message)\nreceive(A, message)\n\n\n队列的消息被附加到链路：\n\n0容量 - 0 message\n发送方必须等待接收方\n\n有限容量 - n message的有限长度\n发送方必须等待，如果队列满\n\n无线容量 - 无限长度\n发送发不需要等待\n\n\n\n\n信号signal（信号）\n\n软件中断通知事件处理\n\n接收到信号时会发生什么\n\ncatch：指定信号处理函数被调用\nignore：依靠操作系统的默认操作\nmask：闭塞信号因此不会传送\n可能是暂时的（当处理同样类型的信号）\n\n\n\n不足\n\n不能传输要交换的任何数据\n\n管道子进程从父进程继承文件描述符\n进程不知道（或不关心）从键盘，文件，程序读取或写入到终端，文件，程序。\n例如: $ ls | more (两个进程, 管道是缓存,对于ls来说是stdout,对于more来说是stdin )\n消息队列消息队列按FIFO来管理消息\n\nmessage: 作为一个字节序列存储\nmessage queues: 消息数组\nFIFO &amp; FILO configuration\n\n共享队列进程\n\n每个进程都有私有地址空间\n在每个地址空间内，明确地设置了共享内存段\n\n优点\n\n快速，方便地共享数据\n\n不足\n\n必须同步数据访问\n\n","categories":["操作系统"],"tags":["死锁"]},{"title":"第十二章 文件系统","url":"/2021/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter12%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"第十二章 文件系统12.1-12.9 基本概念文件系统和文件文件系统：一种用于持久性存储的系统抽象\n\n在存储器上：组织，控制，导航，访问和检索数据\n大多数计算机系统包含文件系统\n个人电脑，服务器，笔记本电脑\nipod，tivo/机顶盒，手机/掌上电脑\ngoogle可能是由一个文件系统构成的\n\n文件：文件系统中一个单元的相关数据在操作系统中的抽象\n文件系统的功能分配文件磁盘空间\n\n管理文件块（哪一种属于哪一个文件）\n\n管理空闲空间（哪一块是空闲的）\n\n分配算法（策略）\n\n\n管理文件集合\n\n定位文件及其内容\n命名：通过名字找到文件的接口\n最常见：分层文件系统\n文件系统类型（组织文件的不同方式）\n\n提供便利及特征\n\n保护：分层来保护数据安全\n可靠性/持久性：保持文件的持久及时发生崩溃、媒体错误、攻击等\n\n文件和块文件属性\n\n名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间、。。。\n\n文件头\n\n在存储元数据中保存了每个文件的信息\n保存文件的属性\n跟踪哪一块存储块属于逻辑上文件结构的哪个偏移\n\n文件描述符文件使用模式\n\n使用程序必须在使用前先“打开”文件\n\n内核跟踪每个进程打开的文件\n\n操作系统为每个进程维护一个打开文件表\n一个打开文件描述符是这个表中的索引\n\n需要元数据来管理打开文件：\n\n文件指针：指向最近的一次读写位置，每个打开了这个文件的进程都这个指针\n文件打开次数：记录文件打开的次数 - 当最后一个进程关闭了文件时，允许将其从打开文件表中移除\n文件磁盘位置：缓存数据访问信息\n访问权限：每个程序访问模式信息\n\n用户视图：\n\n持久的数据结构\n\n系统访问接口：\n\n字节的集合\n系统不会关心你想存储在磁盘上的任何数据结构\n\n操作系统内部视角\n\n块的集合（块是逻辑转换单元，而扇区是物理转换单元）\n块大小&lt;&gt;扇区大小；在UNIX中，块的大小是4KB\n\n当用户说：给我2-12字节空间时会发生什么\n\n获取字节所在的块\n返回块内对应部分\n\n如果说要写2-12字节呢？\n\n获取块\n修改块内对应部分\n写回块\n\n在文件系统中的所有操作都是在整个块空间上进行的\n\ngetc() putc() 即使每次只访问1字节的数据,也会缓存目标数据4096字节(一个磁盘块)\n\n用户怎么访问文件\n\n在系统层面需要知道用户的访问模式\n\n顺序访问：按字节一次读取\n\n几乎所有的访问都是这种方式\n\n随机访问：从中间读写\n\n不常用，但是任然重要。例如，虚拟内存支持文件：内存页存储在文件中\n更加快速 - 不希望获取文件中间的内容的时候也必须先获取块内所有的字节\n\n基于内容访问：通过特征\n\n许多系统不提供此种访问方式，相反，数据库是建立在索引内容的磁盘访问上（需要高效的随机访问）\n\n文件内部结构无结构\n\n单词，比特的队列\n\n简单记录结构\n\n列\n固定长度\n可变长度\n\n复杂结构\n\n格式化的文档\n可执行文件（如，MS word ，pdf）\n…\n\n多用户系统中的文件共享是很必要的\n访问控制\n\n谁能够获得哪些文件的哪些访问权限\n访问模式：读，写，执行，删除，列举等\n\n文件访问控制列表（ACL）\n\n文件实体，权限\n\nUNIX：\n\n&lt;用户|组|所有人,读|写|可执行&gt;\n用户ID识别用户,表明每个用户所允许的权限及保护模式\n组ID允许用户组成组,并指定了组访问权限\n\n指定多用户/客户如何同时访问共享文件\n\n和过程同步算法类似\n因磁盘I/O和网络延迟而设计简单\n\nUNIX文件系统（UFS）语义\n\n对打开文件的写入内容立即对其他打开同一文件的其他用户可见\n共享文件指针允许多用户同时读取和写入文件\n\n会话语义\n\n写入内容只有当文件关闭时可见\n\n锁\n\n一些操作系统和文件系统提供该功能\n\n目录文件以目录的方式组织起来\n目录是一类特殊的文件\n\n每个目录都包含了一张表\n\n目录和文件的树型结构，层次命名空间\n目录操作\n典型操作\n\n搜索，创建，删除文件，枚举目录，重命名文件，在文件系统中遍历一个路径\n\n操作系统应该只允许内核模式修改目录\n\n确保映射的完整性\n应用程序能够读目录（如ls）\n\n文件名的线性列表，包涵了指向数据块的指针\n\n编程简单，执行耗时\n\nHash表 - hash数据结构的线性表\n\n减少目录搜索时间\n碰撞 - 两个文件名的hash值相同\n固定大小\n\n路径遍历\n名字解析：逻辑名字转换成物理资源（如文件）的过程\n\n在文件系统中：到实际文件的文件名（路径）\n遍历文件目录直到找到目标文件\n\n举例：解析“/bin/ls”\n\n读取root的文件头（在磁盘固定位置）\n读取root的数据块；搜索“bin”项\n读取bin的文件头\n读取bin的数据块：搜索ls项\n读取ls的文件头\n\n当前工作目录\n\n每个进程都会指向一个文件目录用于解析文件名\n允许用户指定相对路径来代替绝对路径\n\n一个文件系统需要先挂载才能被访问\n一个未挂载的文件系统被挂载在挂载点上\n文件别名两个或多个文件名关联同一个文件\n硬链接：多个文件项指向一个文件\n软链接：以“快捷方式”指向其他文件（存的是路径名）\n通过存储真实文件的逻辑名称来实现\n因为目录是树型结构，引入链接可能导致出现循环路径，如何保证没有循环呢？\n\n只允许到文件的链接，不允许在子目录的链接\n每增加一个新的链接都利用循环检测算法确定是否合理\n限制路径可遍历文件目录的数量\n\n文件系统种类磁盘文件系统\n\n文件存储在数据存储设备上，如磁盘\n例如：FAT，NTFS，ext2/3，ISO9660，等\n\n数据库文件系统\n\n文件根据其特征是可被寻址的（辨识）的\n例如：WinFS\n\n日志文件系统\n\n计算机可能掉电导致文件系统混乱，因此下一次开机时会进行检查文件的内容一致性，导致开销很大，为此增加日志功能，可快速恢复\n记录文件系统的修改/事件\n例如：journaling file system\n\n网络/分布式文件系统\n\n例如：NFS，SMB，AFS，GFS\n在局域网范围内可快速方便的访问另一台机器的文件\n\n12.10 虚拟文件系统分层结构\n\n上层：虚拟（逻辑）文件系统\n底层：特定文件系统模块\n\n\n目的：对所有不同文件系统的抽象\n功能：\n\n提供相同的文件和文件系统接口\n管理所有文件和文件系统关联的数据结构\n高效查询例程，遍历文件系统\n与特定文件系统模块的交互\n\n文件系统基本数据结构：\n\n卷控制块（UNIX：“superblock”）\n\n\n每个文件系统一个\n文件系统详细的信息\n块、块的大小、空余块。计数/指针等\n\n\n文件控制块（UNIX：“vnode” or “inode”）\n\n\n每个文件一个\n文件详细信息\n许可、拥有者、大小、数据库位置等\n\n\n目录节点（Linux：“dentry”）\n\n\n每个目录项一个（目录和文件）\n将目录项数据结构及树型布局编码成树型结构\n指向文件控制块，父节点，项目列表等\n\n持续存储在二级存储中\n\n映射到磁盘的一个或多个扇区\n\n分配在存储设备中的数据块中\n\n\n当需要时加载进内存\n\n1 当文件系统挂载时进入内存\n2 当文件被访问时进入每次\n3 在遍历一个文件路径时进入内存\n\n12.11 数据缓存数据块按需读入内存\n\n提供read（）操作\n预读：预选读取后面的数据块\n\n数据块使用后被缓存\n\n假设数据将会再次被使用\n写操作可能被缓存和延迟写入\n\n两种数据块缓存方式\n\n普通缓冲区缓存\n页缓存：统一缓存数据块和内存页\n\n缓存和页式管理结合，实现基于分页的缓存机制\n分页要求\n\n当需要一个页时才将其载入内存\n\n支持存储\n\n一个页（在虚拟地址空间中）可以被映射到一个本地文件中（在二级存储中）\n\n文件数据块的页缓存\n\n在虚拟内存中文件数据块被映射成页\n文件的读/写操作被转换成对内存的访问\n可能导致缺页或设置为脏页\n\n12.12 打开文件的数据结构硬盘存的关于文件的文件控制块的内容读到内存中，把相关信息放在打开文件表里，项的索引返回给应用程序\n  打开文件描述\n\n每个被打开的文件一个\n文件状态信息\n目录项，当前文件指针，文件操作设置等\n\n打开文件表\n\n一个进程一个\n一个系统级的\n每个卷控制块也会保存一个列表\n所以如果有文件被打开将不能卸载 \n\n锁\n\n一些操作系统和文件系统提供该功能\n调节对文件的访问\n强制和劝告\n强制 - 根据锁保持情况和需求拒绝访问\n劝告 - 进程可以查看锁的状态来决定怎么做\n\n\n\n12.13 文件分配大多数文件都很小\n\n需要对小文件提供强力的支持\n块空间不能太大\n\n一些文件非常大\n\n必须支持大文件（64-bit 文件偏移）\n大文件访问需要相当高效\n\n如何为一个文件分配数据块\n分配方式\n\n连续，链式，索引\n\n指标：\n\n高效：如存储利用（外部碎片）\n表现：如访问速度\n\n连续分配文件头指定起始块和长度，数组方式\n位置/分配策略\n\n最先匹配，最佳匹配。。。\n\n优势\n\n文件读取表现好\n高效的顺序和随机访问\n\n劣势\n\n碎片\n文件增长问题\n\n组织好，性能糟糕，适合只读\n链式分配文件以数据块链表方式存储\n文件头包含了到第一块和最后一块的指针\n优点\n\n创建，增大，缩小很容易\n没有碎片\n\n缺点\n\n不可能进行真正的随机访问（访问第二块要先找到第一块）\n可靠性（一旦断了一个链。。。）\n\n索引分配为每个文件创建一个名索引数据块的非数据数据块\n\n到文件数据块的指针列表\n\n文件头包含了索引数据块\n\n得到索引快后调入内存，然后查找对应文件位置\n\n优点\n\n创建，增大，缩小很容易\n没有碎片\n支持直接访问\n\n缺点\n\n当文件很小时，存储索引的开销大\n很大的文件，索引块能够表示的数据块的个数有限，一个索引块不够，其他索引块又要如何管理\n\n链式索引块（IB+IB+…)\n线性扩展的方式，对大文件的扩展还是有限，万一链断了怎么办\n多级索引块（IB*IB…)\n分层方式灵活支持大小文件\n12.14 空闲空间列表跟踪在存储中的所有未分配的数据块\n空闲空间列表存储在哪里？\n空闲空间列表的最佳数据结构怎么样？\n用位图代表空闲数据块列表\n\n11111101101110111 如果 i = 0表明数据块i是空闲的,反之是分配的\n\n使用简单但是可能回事一个big vector\n\n160GB disk → 40M blocks → 5MB worth of bits\n\n然而，如果空闲空间在磁盘中均匀分布,那么再找到”0“之前需要扫描的开销：\n磁盘上数据块总数 / 空闲块的数目\n\n\n12.15 多磁盘管理-RAID通常磁盘通过分区来最大限度减少寻道时间\n\n一个分区是一个柱面的集合\n每个分区都是逻辑上独立的磁盘\n\n分区：硬件磁盘的一种适合操作系统指定格式的划分\n卷（多个disk变成一个卷）：一个拥有一个文件系统实例的可访问的存储空间\nRAID\n提高磁盘访问效率\n使用多个并行磁盘来增加\n\n吞吐量（通过并行）\n可靠性和可用性（通过冗余）\n\nRAID - 冗余磁盘阵列\n\n各种磁盘管理技术\nRAID level：不同RAID分类（如，RAID-0，RAID-1，RAID-5）\n\n实现\n\n在操作系统内核：存储/卷管理\nRAID硬件控制器（I/O）\n\nRAID-0（提高吞吐量）\n数据块分成多个子块，存储在独立的磁盘中\n\n和内存交叉相似\n\n通过更大的有效快大小来提供更大的磁盘带宽\nRAID-1（提高可靠性）\n可靠性成倍增长\n读取性能线性增加\n\n向两个硬盘写入，随机一个读取\n\nRAID-4（即提高性能，又增加可靠性）\n数据块级磁带配有专用奇偶校验磁盘\n\n允许从任意一个故障磁盘中恢复\n\n额外的盘完成容错功能\n往任何一个disk里写一个数据，就要往parity disk里面也做写操作\nPAID-5\n把奇偶校验的块均匀分布在不同的disk里面，开销均匀，访问并行。允许有一个disk错误\nRAID-6\n两个冗余块，有一种特殊的编码方式，允许两个磁盘错误\n12.16 磁盘调度读取或写入时，磁头必须被定为在期望的磁道，并从所期望的扇区开始\n寻到时间\n\n定位到期望的磁道所花费的时间\n\n旋转延迟\n\n从扇区的开始到到达目的处所花费的时间\n\n寻道时间是性能上区别的原因\n对单个磁盘，会有一个IO请求数目\n如果请求是随机的,那么会表现很差\nFIFO\n\n按顺序处理请求\n公平对待所有进程\n在有很多进程的情况下，接近随机调度的性能\n\n最短服务优先\n\n选择从磁臂当前位置需要移动最少的I/O请求\n总是选择最短寻道时间\n如果请求频繁出现在当前访问位置，而远处的访问请求持续得不到服务，导致饥饿现象\n访问不公平性和不均匀性\n\nskan\n\n磁臂在一个方向上移动，满足所有未完成的请求，直到磁臂到达该方向上最后的磁道\n\n调度方向\n\n\nc-skan\n\n限制了仅在一个方向上扫描\n当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行扫描\n公平效率高\n\nc-loop\n\n磁臂先到达该方向上最后一个请求处，然后立即反转\n\n","categories":["操作系统"],"tags":["文件系统"]},{"title":"第三章 物理内存分配","url":"/2021/11/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter3%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第三章 物理内存分配3.1 计算机体系结构及内存分层体系计算机体系结构计算机组成原理\nCPU，内存，总线，I/O\n内存体系结构OS内存管理目标\n抽象（逻辑地址空间）：应用程序不需要考虑底层细节\n保护（独立地址空间）：内存中可以运行多个应用程序，多个程序可能访问别的程序的地址空间或者破坏其他程序\n共享（访问相同内存）：进程之间安全有效可靠的数据传递\n虚拟化（更多的地址空间）：当内存不够时，把最需要的数据放在内存中，暂时不需要访问的数据可以临时的放到硬盘上\n\nOS内存管理方法\n程序重定位\n分段\n分页\n虚拟内存\n按需分页虚拟内存\n\n实现高度依赖于硬件\n\nMMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求\n\n3.2 地址空间与地址生成地址空间物理地址空间——硬件支持的地址空间（起始0，MAX_sys）\n逻辑地址空间——一个运行的程序所拥有的的内存范围（0，MAX_prog）\n逻辑地址的生成\n\n物理地址的生成\n\n\n地址安全检查\n\n3.3 连续内存分配内存碎片内存碎片问题指的是空闲的内存无法被利用\n\n外部碎片：分配单元之间的未使用内存\n内部碎片 :  分配给应用程序的单元内的未使用内存\n\n分区的动态分配\n第一匹配分配：在内存中找到第一个比需求大的空闲块, 分配给应用程序\n\n\n\n\n分配方式\n第一匹配分配\n最优适配分配\n最差适配分配\n\n\n\n实现需求\n1. 按地址排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配最大的分区3. 重分配需要检查是否可以合并相邻空闲分区\n\n\n优势\n简单 / 易于产生更大空闲块\n比较简单 / 大部分分配是小尺寸时有效\n分配很快 / 大部分分配是中尺寸时高效\n\n\n劣势\n产生外部碎片 / 不确定性\n产生外部碎片 / 重分配慢 / 易产生很多没用的微小碎片\n产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配\n\n\n3.4 连续内存分配：压缩式与交换式碎片整理无论使用那种算法，都可能产生碎片，希望想有一些办法使得碎片减少甚至消失\n压缩式碎片整理\n重置程序以合并空洞\n要求所有程序是动态可充值的\n议题\n何时重置？\n开销\n\n\n\n\n通过拷贝完成（重定位）\n在运行的时候挪操作，地址会不对\n\n应在程序停止时进行\n\n开销很大，甚至可能影响整个系统的正常执行\n\n\n交换式碎片整理\n运行程序需要更多的内存\n抢占等待的程序&amp;回收他们的内存(把暂时不用的内容挪到磁盘里)\n议题：哪些程序应该被抢占以及什么时候执行\n\n\n操作系统内核特征\n\n并发：计算机系统中同时存在多个运行的程序，需要OS管理和调度\n共享：宏观上“同时访问”，微观上互斥共享\n虚拟：利用多到程序设计技术，让每个用户都觉得有一个计算机专门为他服务\n异步：程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知，只要运行环境相同，OS需要保证程序运行的结果也要相同\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第四章 非连续内存分配","url":"/2021/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter4%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"第四章 非连续内存分配\n为什么需要非连续内存分配\n\n连续内存分配的缺点\n\n分配给一个程序的物理内存是连续的\n内存利用率低\n有外碎片，内碎片的问题\n\n非连续内存分配的优点\n\n一个程序的物理地址是非连续的\n更好的内存利用和管理\n允许共享代码与数据（共享库等）\n支持动态加载和动态链接\n\n非连续分配缺点\n\n如何建立虚拟地址和物理地址之间的转换\n软件方案\n硬件方案（分段，分页）\n\n\n\n4.1 分段\n程序的分段地址空间，分段寻址方案\n\n计算机程序由各种段组成\n\n分段：更好的分离和共享\n\n\n\n左边连续的虚拟地址，右边不连续的物理地址，采用映射机制进行两边的关联\n\n分段寻址方案\n\n\n一个段：一个内存“块”\n\n\n程序访问内存需要：\n\n\n一个2维的二元组（s，addr）\ns—段号\naddr—段内偏移\n\n\n\n\n操作系统建立段表\n分页\n划分物理内存至固定大小的帧\n\n大小是2的幂，e.g.，512,4096,8192\n\n\n划分逻辑地址空间至相同大小的页\n\n大小同物理地址\n\n\n建立方案 转换逻辑地址为物理地址（pages to frames）\n\n页表\nMMU/TLB（加速地址的转换）\n\n\n\n帧（Frame）\n物理内存被分割为大小相等的帧\n\n一个内存物理地址是一个二元组（f，o）\n\nf—帧号（F位，共有2F个帧）\no—帧内偏移（S位，每帧有2S字节）\n物理地址=2S * f + o\n\n\n16-bit地址空间, 9-bit(512 byte) 大小的页帧\n\n物理地址=（3，6）\n物理地址=1542\n\n\n\n\n页（Page）\n一个程序的逻辑地址空间被划分为大小相等的页\n\n页内偏移的大小 = 帧内偏移的大小\n页号大小 &lt;&gt; 帧号大小\n\n\n一个逻辑地址是一个二元组(p, o) \n\np—页号（P位，2P个页）\no—页内偏移（S位，每页有2S字节）\n逻辑地址=2S * P + o\n\n\n\n页寻址机制\n\n操作系统建立页表\n\n逻辑地址空间应当大于物理内存空间\n页映射到帧\n页是连续的虚拟内存\n帧是非连续的物理内存(有助于减少碎片的产生)\n不是所有的页都有对应的帧\n\n4.3 页表-概述、TLB页表概述页表结构\n\n每一个运行的程序都有一个页表\n属于程序运行状态, 会动态变化\nPTBR : 页表基址寄存器\n\n\n\n地址转换\n\n分页机制的性能问题\n问题：访问一个内存单元需要2次内存访问\n\n一次用于获取页表项\n一次用于访问数据\n\n页表可能非常大\n\n64位机器如果每页1024字节, 那么一个页表的大小会是多少？(264 / 210 = 254 存放不下)\n每一个运行的程序都需要有一个页表\n\n如何处理\n\n缓存\n间接访问\n\nTranslation Look-aside Buffer（TLB）（解决速度上问题）CPU的MMU里面的一个缓冲，CPU中的快表\n缓存近期访问的页帧转换表项\n\nTLB使用associative memory（关联内存）实现, 具备快速访问性能\n如果TLB命中, 物理页号可以很快被获取\n如果TLB未命中, 对应的表项被更新到TLB中\n常用的表项放在TLB里面\nTLB的miss不会很大\n写程序时，写出的程序尽量具有访问的局部性，把平时的访问集中在一个区域里，有效较少TLB的缺失\nx86的CPU由硬件实现, 其他的可能是由操作系统实现\n\n4.4 页表-二级，多级页表二级页表（解决空间上问题）\n\n将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.\n一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号\n节约了一定的空间, 在一级页表中如果resident bit = 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留多级页表\n\n\n通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”\n\n4.5 页表-反向页表大地址空间问题\n\n有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表\n不是让页表与逻辑地址空间的大小相对应, 而是让页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间 \n\n基于页寄存器（page registers）的方案每一个帧和一个寄存器关联, 寄存器内容包括 :\n\nresident bit : 此帧是否被占用\noccupier : 对应的页号 p\nprotection bits : 保护位\n\n实例\n\n物理内存大小是 : 4096 * 4096 = 4K * 4KB = 16 MB\n页面大小是 : 4096 bytes = 4 KB\n页帧数 : 4096 = 4 K\n页寄存器使用的空间(假设8 bytes / register) : 8 * 4096 = 32 Kbytes\n页寄存器带来的额外开销 : 32K / 16M = 0.2%\n虚拟内存大小 : 任意\n\n优势\n\n转换表的大小相对于物理内存来说很小\n转换表的大小跟逻辑地址空间的大小无关\n\n劣势\n\n需要的信息对调了, 即根据帧号可以找到页号\n如何转换回来? (如何根据页号找到帧号)\n在需要在反向页表中搜索想要的页号\n\n基于关联内存(associative memory)的方案硬件逻辑复杂，容量不能做太大，还需要放到CPU里面\n\n如果帧数较少, 页寄存器可以被放置在关联内存中\n\n在关联内存中查找逻辑页号\n\n成功 : 帧号被提取\n失败 : 页错误异常 (page fault)\n\n\n限制因素：\n\n大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)\n\n\n\n基于哈希(hash)的方案哈希表，哈希函数 : h(PID, p) 从 PID 标号获得页号\n在反向页表中通过哈希算法来搜索一个页对应的帧号\n\n对页号做哈希计算, 为了在帧表中获取对应的帧号\n页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数\n为了查找页 i , 执行下列操作 :\n计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器\n检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败\n\n\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第五章 虚拟内存","url":"/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","content":"第五章 虚拟内存5.1 起因程序规模的增长远大于存储器容量发展的速度，让更多的程序跑在有限的内存里面\n使用硬盘/磁盘使更多的程序在有限的内存中运行\n理想的存储器：\n更大，更快，更便宜的非易失性存储器\n实际中的存储器：\n\n5.2 覆盖技术目标：是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用\n原理：\n\n把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行\n必要部分(常用功能)的代码和数据常驻内存\n可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存\n不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区\n\n\n\n\n\n缺点：\n由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度\n覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省\n\n\n\n5.3 交换技术如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中\n目标：\n\n多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源\n\n方法：\n\n可将暂时不能运行的程序送到外存, 从而获得空闲内存空间\n操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间\n\n交换技术实现中的几个问题：\n\n交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出\n交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取\n程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法\n\n覆盖与交换的比较\n\n覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构\n交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部\n\n5.4 虚存技术在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :\n\n覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担\n交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销\n\n目标：\n\n像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉\n像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换\n以更小的页粒度为单位装入更多更大的程序\n\n程序的局部性原理\n\n程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域\n时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内\n空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内\n\n\n\n程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果\n实例：\n页面大小为4k, 分配给每个进程的物理页面是1. 在一个进程中, 定义了如下的二维数组 int A[1024][1024]. 该数组按行存放在内存, 每一行放在一个页面中.考虑一下程序的编写方法对缺页率的影响?程序编写方法1 : (发生了1024*1024次缺页中断)for(j = 0; j &lt; 1024; j++)\t\tfor(i = 0; i &lt; 1024; i++)\t\t\t\tA[i][j] = 0;程序编写方法2 : (发生了1024次缺页中断)for(i = 0; i &lt; 1024; i++)\t\tfor(j = 0; j &lt; 1024; j++)\t\t\t\tA[i][j] = 0;\n\n基本概念\n可以在页式或段式内存管理的基础上实现\n\n在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行\n在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序\n另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段\n\n基本特征\n\n大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB\n部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的\n不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性\n\n页式内存管理页表 : 完成逻辑页到物理页帧的映射\n根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址\n虚拟页式内存管理\n\n大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能\n\n基本思路\n\n当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.\n在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行\n\n\n页表表项\n\n驻留位 : 表示该页是在内存中还是在外存\n保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等\n修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存\n访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法\n\n\n缺页中断处理过程\n\n如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步\n采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存\n对q所对应的页表项修改, 把驻留位置为0\n将需要访问的页p装入到物理页面f当中\n修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f\n重新运行被中断是指令\n\n\n\n在何处保存未被映射的页？\n\n能够简单地识别在二级存储器中的页\n交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面\n\n后备存储 backing store（二级存储）\n一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置\n代码段 : 映射到可执行二进制文件\n动态加载的共享库程序段 : 映射到动态调用的库文件\n其他段 : 可能被映射到交换文件(swap file)\n\n虚拟内存性能为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)\nEAT = 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第六章 页面置换算法","url":"/2021/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter6%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/","content":"第六章 页面置换算法6.1 页面置换算法功能与目标功能：当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个页面被置换\n目标：尽可能地减少页面的换进换出次数（即缺页中断的次数）。具体的说，把未来不再使用或短期内较少使用的页面换出，通常只能在局部性原理知道下依据过去的统计数据来进行预测\n页面锁定（frame locking）：用于描述必须常驻内存的操作系统的关键部分或时间关键（time-critical）的应用进程。实现方法是：在页表中添加锁定标志（lock bit）\n实验设置\n记录一个进程对页访问的一个轨迹\n\n举例：（虚拟）地址跟踪（页号，位移）…\n\n（3,0），（1,9），（4,1），（2,1），（5,3），（2,0），（1,9），…\n\n\n生成页面轨迹\n\n3, 1, 4, 2, 5, 2, 1,…..\n\n\n\n模拟一个页面置换的行为并且记录产生页缺失数的数量\n\n更少的缺失，更好的性能\n\n最优页面置换算法\n基本思路：当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面\n这只是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问\n可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法)\n\n\n局部页面置换算法6.2 先进先出算法First-In First-out，FIFO\n\n基本思路： 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾\n\n性能较差, 调出的页面有可能是经常要访问的页面. 并且有 Belady现象. FIFO算法很少单独使用\n\n\n6.3 最近最久未使用算法Least Recently Used，LRU\n\n基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰\n它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问（根据过去来实现）\nLRU算法需要记录各个页面使用时间的先后顺序, 开销比较大\n两种可能得实现方法：\n系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面\n设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的\n\n\n\n6.4 时钟页面置换算法Clock页面置换算法，LRU的近视，对FIFO的一种改进\n\n基本思路\n需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为0. 然后如果这个页面被访问, 则把该位置设为1\n把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来)\n当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格\n\n\n\n\n6.5 二次机会法“脏”位区分读（0）和写（1）\n访问位与“脏”位的结合，减少写回操作的次数\n\n替换used和dirty都是0的页\n把经常使用的页留在内存中\n\n相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会\n\n6.6 最不常用算法Least Frequently Used ,LFU\n\n基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰\n实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 当发生缺页中断时, 淘汰计数值最小的那个页面\nLRU和LFU的对比 : LRU考察的是多久未访问, 时间越短越好. 而LFU考察的是访问的次数和频度, 访问次数越多越好\n\n6.7 Belady现象、LRU、FIFO、Clock的比较Belady现象在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象\n现象原因：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的\n\n给更多的物理页却产生更多的缺页\nLRU、FIFO和Clock的比较\nLRU和FIFO都是先进先出的思路, 只不过LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法\nLRU算法性能较好，但系统开销较大; FIFO算法系统开销较小，但可能会发生Belady现象。因此，折衷的办法就是Clock算法，在每一次页面访问时，它不必去动态地调整该页面在链表当中的顺序，而仅仅是做一个标记，然后等到发生缺页中断的时候，再把它移动到链表末尾。对于内存当中那些末被访问的页面，Clock算法的表现和LRU算法一样好: 而对于那些曾经被访问过的页面，它不能象LRU算法那样，记住它们的准确位置。\n\n全局页面置换算法6.8 局部页替换算法的问题、工作机模型全局页面置换算法考虑的问题：根据程序不同的运行阶段，动态分配调整物理页帧的算法\n工作集模型前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立？\n\n如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断\n如果局部性原理是成立的，那么如何来证明它的存在，如何来对它进行定量地分析? 这就是工作集模型\n\n工作集：一个进程当前正在使用的逻辑页面集合\n可以使用一个二元函数 W(t, △delta) 来表示\n\nt 是当前的执行时刻\ndelta 称为工作集窗口, 即一个定长的页面访问的时间窗口\nW(t, delta) = 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)\n|W(t, delta)| 是工作集的大小, 即逻辑页的数量\n\n\nt2具有很好的局部性\nt1具有一定的局部性（重复访问7）\n\n常驻集常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合\n\n工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法\n如果一个进程的整个工作集都在内存当中, 即常驻集包含工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态)\n当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降\n\n6.9 两个全局置换算法工作集页置换算法\n当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃\n缺页率置换算法可变分配策略： 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小\n\n可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面\n优缺点 : 性能较好, 但增加了系统开销\n具体实现 : 可以使用缺页率算法来动态调整常驻集的大小\n\n缺页率 : 表示 “缺页次数 / 内存访问次数”（比率）或“缺页的平均时间间隔的倒数”\n影响因素：\n\n页面置换算法\n分配给进程的物理页面数目\n页面本身的大小\n程序的编写方法\n\n若运行的程序缺页率过高，则通过增加工作集来分配更多的物理页面；若运行的程序缺页率过低，则通过减少工作集来减少它的物理页面数。力图使运行的程序的缺页率保持在一个合理的范围内（寻求balance）\n6.10 抖动问题\n如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”\n产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡\n\n","categories":["操作系统"],"tags":["内存分配"]},{"title":"第七章 进程管理","url":"/2021/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","content":"第七章 进程管理7.1-7.4 进程描述进程的定义进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程\n进程的组成一个进程应该包括：\n\n程序的代码\n\n程序处理的数据\n\n程序计数器中的值, 指示下一条将运行的指令\n\n一组通用的寄存器的当前值, 堆, 栈\n\n一组系统资源(如打开的文件)\n\n进程包含了正在运行的一个程序的所有状态信息*\n\n\n进程与程序的联系\n\n程序是产生进程的基础\n程序的每次运行构成不同的进程\n进程是程序功能的体现\n通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序\n\n进程与程序的区别：\n\n进程是动态的, 程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 / 用户态（进程在执行过程中需要完成特定的只能操作系统提供的功能，进程只需给OS发出请求，OS代表进程在内核中执行，此时进程处于核心态）\n进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存\n进程和程序的组成不同 : 进程的组成包括程序, 数据和进程控制块（进程状态信息）\n\n\n进程的特点\n可动态地创建, 结果进程\n并发性 : 进程可以被独立调度并占用处理机运行; (并发:一段, 并行:一时刻)\n独立性 : 不同进程的工作不相互影响;(页表是保障措施之一)\n制约性 : 因访问共享数据, 资源或进程间同步而产生制约\n\n进程控制结构程序=算法+数据结构\n描述进程的数据结构：进程控制块（Process Control Block，PCB）\n\n进程控制块：操作系统管理控制进程运行所用的信息集合\n操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在唯一标志\n\n使用进程控制块\n\n进程的创建：为该进程生成一个PCB\n进程的终止 : 回收它的PCB\n进程的组织管理：通过对PCB的组织管理来实现\n\nPCB含有以下三大类信息：\n\n进程标志信息。如本进程的标志，本进程的产生者标志（父进程标志），用户标志\n\n处理机状态信息保存区。保存进程的运行现场信息：\n\n用户可见寄存器，用户程序可以使用的数据，地址等寄存器\n控制和状态寄存器，如程序计数器(PC)，程序状态字(PSW)\n栈指针，过程调用/系统调用/中断处理和返回时需要用到它\n\n\n进程控制信息：\n\n调度和状态信息，用于操作系统调度进程并占用处理机使用\n进程间通信信息，为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中\n存储管理信息， 包含有指向本进程映像存储空间的数据结构\n进程所用资源 说明由进程打开，使用的系统资源，如打开的文件等\n有关数据结构的链接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB\n\n\n\nPCB的组织方式\n链表：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表（各状态的进程形成不同的链表：就绪链表，阻塞链表）\n索引表：同一状态的进程归入一个index表（由index指向PCB）， 多个状态对应多个不同的index表（各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表）\n7.5-7.7 进程状态进程生命周期管理进程创建\n引进进程创建的3个主要事件：\n\n系统初始化；\n用户请求创建一个新进程；\n正在运行的程序执行了创建进程的系统调用；\n\n进程运行\n内核选择一个就绪的进程，让他占用处理机并执行\n\n为何选择？如何选择？\n\n进程等待\n在以下情况下，进程等待（阻塞）：\n\n请求并等待系统服务, 无法马上完成\n启动某种操作, 无法马上完成\n需要的数据没有到达\n\n进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生\n进程唤醒\n唤醒进程的原因：\n\n被阻塞进程需要的资源可被满足\n被阻塞进程等待的事件到达\n将该进程的PCB插入到就绪队列\n\n进程只能被别的进程或操作系统唤醒\n进程结束\n在以下四种情况下，进程结束：\n\n正常退出(自愿)\n错误退出(自愿)\n致命错误(OS强制性)\n被其他进程杀死(强制性)\n\n进程状态变化模型进程的三种基本状态：进程在生命结束前处于三种基本状态之一\n不同系统设置的进程状态数目不同\n\n运行状态（Running）：当一个进程正在处理机上运行时\n就绪状态（Ready）：一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行\n等待状态（阻塞状态 Blocked）：一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入/输出完成\n\n进程其他的基本状态：\n创建状态（New）：一个进程正在被创建, 还没被转到就绪状态之前的状态\n结束状态（Exit）：一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致\n\n可能的状态变化如下：\nNULL → New：一个新进程被产生出来执行一个程序\nNew → Ready：当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态\nReady → Running：处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行\nRunning → Exit：当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理\nRunning → Ready：处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机（OS完成）\nRunning → Blocked：当进程请求某样东西且必须等待时（等待定时器的到达，等待读写文件…）\nBlocked → Ready：当进程要等待某事件到来时, 它从阻塞状态变到就绪状态\n进程挂起合理且充分低利用系统资源\n进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上（把进程放到磁盘上）\n挂起状态\n阻塞挂起状态：进程在外存并等待某事件的出现\n就绪挂起状态：进程在外存，但只要进入内存，即可运行\n与挂起相关的状态转换\n挂起：把一个进程从内存转到外存；可能有一下集中情况：\n\n阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以提交新进程或运行时就绪进程\n就绪到就绪挂起：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程\n运行到就绪挂起：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转导就绪挂起状态\n\n在外存时的状态转换：\n\n阻塞挂起到就绪挂起：当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程\n\n解挂/激活：把一个进程从外存转到内存；可能有一下几种情况：\n\n就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换\n阻塞挂起到阻塞：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程\n\n状态队列\n\n由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态\n不同的状态分别用不同的队列来表示（就绪队列, 各种类型的阻塞队列）\n每个进程的PCB都根据它的状态加入到相应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态中脱离出来，加入到另外一个队列\n\n7.8-7.10 线程为什么使用线程【案例】编写一个MP3播放软件\n核心功能模块有三个：\n\n从MP3音频文件当中读取数据；\n对数据进行压缩；\n把解压缩后的音频数据播放出来\n\n//单进程方式while(TRUE)&#123;\tRead();// I/O\tDecompress();// CPU\tPlay();&#125;//问题: 播放出来的声音能否连贯? 各个函数之间不是并发执行, 影响资源的使用效率//多进程方式//进程1while(TRUE)&#123;\tRead();&#125;//进程2while(TRUE)&#123;\tDecompress();&#125;//进程3while(TRUE)&#123;\tPlay();&#125;//问题: 进程之间如何通信,共享数据?另外,维护进程的系统开销较大://创建进程时,分配资源,建立PCB;撤销进程时,回收资源,撤销PCB;进程切换时,保存当前进程的状态信息\n\n需要提出一种新的实体，满足一下特性：\n\n实体之间可以并发地执行\n实体之间共享相同的地址空间\n\n什么是线程Thread：\n\n进程当中的一条执行流程\n从两个方面重新理解进程：\n从资源组合的角度：进程把一组相关的资源组合起来，构成了一个资源平台（环境），包括地址空间（代码段，数据段），打开的文件等各种资源\n从运行的角度：代码在这个资源平台上的一条执行流程（线程）\n\n\n\n线程=进程—共享资源\n线程的优点：\n\n一个进程中可以同时存在多个线程;\n各个线程之间可以并发地执行;\n各个线程之间可以共享地址空间和文件等资源\n\n线程的缺点：\n\n一个线程崩溃，会导致其所属进程的所有线程崩溃（给它了”权限”就得有更高的”责任”）\n\n进程所需的资源：\n不同的线程需要独立的寄存器和堆栈，共享代码，数据和文件等\n线程与进程的比较\n\n进程是资源分配单位，线程是CPU调度单位\n进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈\n线程同样具有就绪，阻塞和执行三种基本状态，同样具有状态之间的转换关系\n线程能减少并发执行的时间和空间开销：\n线程的创建时间比进程短；（直接利用所属进程的一些状态信息）\n线程的终止时间比进程短；（不需要考虑把这些状态信息给释放）\n同一进程内的线程切换时间比进程短；（同一进程不同线程的切换不需要切换页表）\n由于同一进程的各线程之间共享内存和文件资源，可直接进行不通过内核的通信。（直接通过内存地址读写资源）\n\n\n\n线程的实现主要有三种线程的实现方式\n\n用户线程：在用户空间实现；POSIX Pthreads，Mach C-threads, Solaris threads\n内核线程：在内核中实现；Windows，Solaris，Linux\n轻量级进程：在内核中实现，支持用户线程；Solaris\n\n用户线程与内核线程的对应关系\n\n多对一，一对一，多对多\n\n用户线程在用户空间实现的线程机制, 它不依赖于操作系统的内核, 由一组用户级的线程库来完成线程的管理, 包括进程的创建,终止,同步和调度等\n\n由于用户线程的维护由相应的进程来完成（通过线程库函数），不需要操作系统内核了解用户进程的存在，可用于不支持线程技术的多进程操作系统；\n每个进程都需要它自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态信息（PC，栈指针，寄存器），TCB由线程库函数来维护；\n用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快；\n允许每个进程拥有自定义的线程调度算法.\n\n用户线程缺点：\n\n阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待；（操作系统看不到线程）\n当一个线程开始运行时，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行；（用户态线程库无法主动打断当前用户线程的执行）\n由于时间片分配给进程，所以与其他进程比,在多线程执行时，每个线程得到的时间片较少，执行会较慢\n\n内核线程内核线程是在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建,终止和管理\n\n在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB和TCB）；\n线程的创建,终止和切换都是通过系统调用，内核函数的方式来进行，由内核来完成,因此系统开销较大；\n在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；\n时间片分配给线程，多线程的进程获得更多CPU时间；\nWindows NT 和 Windows 2000/XP 支持内核线程\n\n轻量级线程\n它是内核支持的用户线程。一个进程可以有一个或多个轻量化进程，每个量级进程由一个单独的内核线程来支持。（Solaris，Linux）\n7.11 上下文切换停止当前运行进程（从运行状态改变其他状态）并且调度其他进程（转变成运行状态）\n\n必须在切换之前存储许多部分的进程上下文\n必须能够在之后恢复他们,所以进程不能显示它曾经被暂停过\n必须快速（上下文切换时非常频繁）\n\n需要存储什么上下文？\n\n寄存器（PC，SP…），CPU状态等信息\n一些时候可能会费时,所以我们应该尽可能避免\n\n操作系统为活跃进程准备了进程控制块\n操作系统将进程控制块放置在一个合适的队列中\n\n就绪队列\n等待I/O队列（每个设备的队列）\n僵尸队列\n\n7.12-7.14 进程的控制创建进程fork（）的简单实现\n\n对子进程分配内存\n复制父进程的内存和CPU寄存器到子进程\n开销昂贵\n\n在99%的情况下,我们在调用fork()之后调用exec()\n\n在fork()操作中内存复制是没有作用的\n子进程将可能关闭打开的文件和连接\n开销因此是最高的\n为什么不能结合它们在一个调用中(OS/2, windows)?\n\nvfork（）\n\n一个创建进程的系统调用,不需要创建一个同样的内存映像\n一些时候称为轻量级fork（）\n子进程应该几乎立即调用exec（）\n现在不再使用如果我们使用 copy on write 技术\n\n加载和执行进程\n系统调用exec()加载程序取代当前运行的进程\n\nexec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)\n\n它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)\n\n如果调用成功(相同的进程,不同的程序)\n\n代码,stack,heap重写\n\n\n等待和终止进程wait()系统调用是被父进程用来等待子进程的结束\n\n一个子进程向父进程返回一个值,所以父进程必须接受这个值并处理\n\nwait（）系统调用担任这个要求\n\n它使父进程去睡眠来等待子进程的结束\n当一个子进程调用exit（）的时候，操作系统解锁父进程，并且将通过exit（）传递得到的返回值作为wait调用的一个结果（连同子进程的pid一起）如果这里没有子进程存活，wait（）立刻返回\n当然,如果这里有为父进程的僵尸等待，wait（）立即返回其中一个值（并且解除僵尸状态）\n\n\n进程结束执行之后，它调用exit（）\n\n这个系统调用：\n\n将这程序的”结果”作为一个参数\n关闭所有打开的文件,连接等等\n释放内存\n释放大部分支持进程的操作系统结构\n检查是否父进程是存活着的：\n如果是的话,它保留结果的值直到父进程需要它;在这种情况里,进程没有真正死亡,但是它进入了僵尸状态\n如果没有,它释放所有的数据结构,这个进程死亡\n\n\n清理所有等待的僵尸进程\n\n\n进程终止是最终的垃圾收集（资源回收）\n\n\n\n","categories":["操作系统"],"tags":["进程线程"]},{"title":"第八章 调度算法","url":"/2021/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":"第八章 调度算法8.1 背景上下文切换\n\n切换CPU的当前任务, 从一个进程/线程到另一个\n保存当前进程/线程在PCB/TCB中的执行上下文(CPU状态)\n读取下一个进程/线程的上下文\n\nCPU调度\n\n从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程\n调度程序：挑选进程/线程的内核函数(通过一些调度策略)\n什么时候进行调度？\n\n内核运行调度程序的条件（满足一条即可）\n\n一个进程从运行状态切换到等待状态\n一个进程被终结了\n\n不可抢占\n\n调度程序必须等待事件结束\n\n可以抢占\n\n调度程序在中断被响应后执行\n当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪\n当前运行的进程可以被换出\n\n8.2 调度原则评价指标\n\nCPU使用率：CPU处于忙状态所占时间的百分比\n吞吐量：在单位时间内完成的进程数量\n周转时间：一个进程从初始化到结束，包括所有等待时间所花费的时间\n等待时间：进程在就绪队列中的总时间\n响应时间：从一个请求被提交到产生第一次相应所花费的总时间\n\n人们通常都需要“更快”的服务\n什么是更快\n\n传输文件时的高带宽\n玩游戏时的低延迟\n这两个因素是独立的\n\n和水管类比\n\n低延迟：喝水的时候想要一打开水龙头水就流出来\n高带宽：给游泳池冲水时希望从水龙头里同时流出大量的水，并且不介意是否存在延迟\n\n目标：\n\n减少响应时间：及时处理用户的输出并且尽快将输出提供给用户\n\n减少平均响应时间的波动：在交互系统中，可预测性比高差异低平均更重要\n\n增加吞吐量\n\n减少开销（操作系统开销，上下文切换）\n系统资源的高效利用（CPU，I/O设备）\n\n\n减少等待时间：减少每个进程的等待时间\n\n\n各指标在操作系统上的表现：\n\n低延迟调度增加了交互式表现\n\n如果移动了鼠标，但是屏幕中的光标却没动，我们可能会重启电脑\n\n\n操作系统需要保证低吞吐量不受影响\n\n我想要结束长时间的编程，所以操作系统必须不时进行调度，即使存在许多交互任务\n\n\n吞吐量是操作系统的计算带宽\n\n响应时间是操作系统的计算延迟\n\n\n公平的定义\n举例：\n\n保证每个进程占用相同的CPU时间\n这公平嘛?如果一个用户比其他用户运行更多的进程怎么办\n\n举例：\n\n保证每个进程都等待相同的时间\n\n公平通常会增加平均响应时间\n8.3-8.4 调度算法面向通用型计算机系统的调度算法\n\n一. FCFS（先来先去服务）FIFO队列的规定\n\n如果进程在执行中阻塞，队列中的下一个会得到CPU\n\n\n\n优点：简单\n缺点\n平均等待时间波动较大\n花费时间少的任务可能排在花费时间长的任务后面\n可能导致I/O和CPU之间的重叠处理\n\n\n\n二. SPN/SRT 短进程优先Shortest Process Next(Shortest Job First) Shortest Remaining Time\n\n按照预测的完成时间来将任务入队\n\n可以是可抢占或者不可抢占的\n\n可抢占：又叫Shortest-Remaining-Time(SRT)（最短剩余时间）\n\n\n可能导致饥饿\n\n连续的短任务流会使长任务饥饿\n短任务可用时的任何长任务的CPU时间都会增加平均等待时间\n\n\n需要预知未来\n\n怎么预估下一个CPU突发的持续时间\n简单的解决办法：询问用户\n如果用户欺骗就杀死进程\n如果用户不知道怎么办\n从执行历史来推断\n\n\n\n\n\n三. HRRN 最高响应比优先Highest Response Ratio Next（HRRN)\n\n在SPN调度的基础上改进\n不可抢占\n关注进程等待了多长时间\n防止无限期推迟\n\n综合考虑了进程的执行时间和等待时间\n饥饿现象得到有效的缓解\n问题\n\n不可抢占\n依然需要知道进程的执行时间\n\n四. Round Robin 轮循\n\nPR花销：额外的上下文切换\n\n时间量子太大\n\n等待时间过长\n极限情况退化成FCFS\n\n\n时间量子太小\n\n反应迅速\n吞吐量由于大量的上下文切换开销收到影响\n\n\n\n目标：\n\n选择一个合适的时间量子\n经验规则：维持上下文切换开销处于1%以内\n\n五. MLFQ 多级反馈队列Multilevel Feedback Queues\n\n就绪队列被划分成独立的队列：\n比如前台（交互），后台（批处理）\n\n每个队列拥有自己的调度策略：\n比如前台（PR），后台（FCFS）\n\n调度必须在队列间进行\n\n固定优先级\n先处理前台，然后处理后台\n可能导致饥饿\n\n\n时间切片\n每个队列都得到一个确定的能够调度其进程的CPU总时间\n比如，80%给使用PR的前台，20%给使用FCFS的后台\n\n\n\n\n一个进程可以在不同的队列中移动\n\n例如：n级优先级—优先级调度在所有级别中，PR在每个级别中\n\n时间量子大小随优先级别增加而增加\n如果任务在当前的时间量子中没有完成，则降到下一个优先级\n\n\n\n优点\n\nCPU密集型任务的优先级下降很快\nI/O密集型任务停留在高优先级\n\n六. Fair-Share Scheduling 公平共享调度FSS控制用户对系统资源的访问\n\n一些用户组比其他用户组更重要\n保证不重要的组无法垄断资源\n未使用的资源按照每个组所分配的资源的比例来分配\n没有达到资源使用率目标的组获得更高的优先级\n\n8.5 实时调度定义：正确性依赖于时间和功能两方面的一种操作系统\n性能指标：时间约束的及时性；速度和平均性能相对不重要\n主要特性：时间约束的可预测性\n两类：\n\n强实时系统：需要在保证的时间内完成重要任务，必须完成\n弱实时系统：要求重要的进程的优先级更高，尽量完成，并非必须\n\n任务（工作单元）：一次计算，一次文件读取，一次信息传递等等\n属性：取得进展所需要的资源；定时参数\nRM（Rate Monotonic）速率单调调度\n\n最佳静态优先级调度\n通过周期安排优先级\n周期越短优先级越高\n执行周期最短的任务\n\nEDF（Earliest Deadline First）最早期限调度\n\n最佳的动态优先级调度\nDeadline越早优先级越高\n执行Deadline最早的任务\n\n8.6 多处理器调度与优先级反转多处理器的CPU调度更复杂\n\n多个相同的单处理器组成一个多处理器\n优点：复杂共享\n\n对称多处理器（SMP）\n\n每个处理器运行自己的调度程序\n需要在调度程序中同步\n\n优先级反转\n\n可以发生在任务基于优先级的可抢占的调度机制中\n当系统内的环境强制使高优先级任务等待低优先级任务时发生\n\n","categories":["操作系统"],"tags":["调度"]},{"title":"第九章 同步互斥","url":"/2021/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter9%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/","content":"第九章 同步互斥9.1 背景到目前为止\n\n多道程序设计: 现代操作系统的重要特性\n并行很有用(为什么?) 提示: 多个并发实体: CPU IO 用户 等\n进程,线程: 操作系统抽象出来用于支持多道程序设计\nCPU调度: 实现多道程序设计的机制\n调度算法: 不同的策略\n\n独立的线程：\n\n不和其他线程共享资源或状态\n确定性: 输入状态决定结果\n可重现: 能够重现起始条件，I/O\n调度顺序不重要\n\n合作的线程：\n\n在多个线程中共享状态\n不确定性\n不可重现\n\n不确定性和不可重现意味着bug可能是间歇性发生的\n进程/线程，计算机/设备需要合作\n优点1：共享资源\n\n一台电脑，多个用户\n一个银行存款余额，多台ATM机\n嵌入式系统（机器人控制：手臂和手的协调）\n\n优点2：加速\n\nI/O操作和计算机可以重写\n多处理器-将程序分成多个部分并执行\n\n优点3：模块化\n\n将大程序分解成小程序\n使系统易于扩展\n\n程序可以调用函数fork（）来创建一个新的进程\n\n操作系统需要分配一个新的并且唯一的进程ID\n\n因此在内核中，这个系统调用会运行\n\nnew_pid=next_pid++;\n\n\n翻译成机器指令\n\nLOAD next_pid Reg1\nSTORE Reg1 new_pid\nINC Reg1\nSTORE Reg1 next_pid\n\n\n\n假如两个进程并发执行\n\n如果next_pid等于100，那么其中一个进程得到的ID应该是100，另一个进程的ID应该是101，next_pid应该增加到102\n\n可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100，而next_pid也是101\n\n\n9.2-9.4 概念前面的现象称为Race Condition(竞态条件)\n系统缺陷: 结果依赖于并发执行或者时间的顺序,时间\n\n不确定性\n不可重视\n\nAtomic Operator(原子操作)\n原子操作是指一次不存在任何终端或者失败的执行\n\n该执行成功结束\n或者根本没有执行\n并且不应发生任何部分执行的状态\n\n实际上操作往往不是原子的\n\n有些看上去是原子操作,实际上不是\n连x++这样的简单语句,实际上是由三条指令构成的\n有时候甚至连单条假期指令都不是原子的\n\n)\nCritical section（临界区）：进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域\nMutual exclusion（互斥）：当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源\nDead lock（死锁）：是指两个或以上进程，在相互等待完成特定任务，而最终没法将自身任务进行下去\nStarvation（饥饿）：一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行\n\n9.5 临界区互斥：同一时间临界区中最多存在一个线程\nProgress：如果一个线程想要进入临界区，那么它最终会成功\n有限等待：如果一个线程i处于入口区，那么在i的请求被接受之前，其他线程进入临界区的时间是有限制的（如果无线等待，则会进入饥饿）\n无忙等待（可选）：如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起\n9.6 方法一 禁用硬件中断没有中断，没有上下文切换，因此没有并发\n\n硬件将中断处理延迟到中断被启用之后\n大多数现代计算机体系结构都提供指令来完成\n\n进入临界区\n\n禁用中断\n\n离开临界区\n\n开启中断\n\n一旦中断被禁用，线程就无法被停止\n\n整个系统都会为你停下来\n可能导致七天线程处于饥饿状态\n\n要是临界区可以任意长怎么办\n\n无法限制响应中断所需的时间（可能存在硬件影响）\n\n要小心使用\n简单有效，受制于临界区时间，整个系统效率会产生很大影响，不太适合于多CPU\n9.7 方法2 基于软件的解决方法满足进程Pi和Pj之间互斥的经典的基于软件的解决方法(1981年)\n\n使用两个共享数据项\nint turn；//指示该谁进入临界区\nboolean flag[]；//指示进程是否准备好进入临界区\n\n进入临界区\n\n\nflag[i] = TRUE;turn = j;while(flag[j] &amp;&amp; turn==j);\n\n\n退出临界区\n\nflag[i]=FALSE;\n\n进程pi的算法：\ndo&#123;\tflag[i] = true;\tturn = j;\twhile(flag[j] &amp;&amp; turn == j);\t\tCRITICAL SECTION\tflag[i] = false;\t\tREMAINDER SECTION&#125;while(true);\n\nBakery 算法(N个进程的临界区)\n\n进入临界区之前,进程接收一个数字\n得到的数字最小的进入临界区\n如果进程Pi和Pj收到相同的数字,那么如果i&lt;j,Pi先进入临界区,否则Pj先进入临界区\n编号方案总是按照枚举的增加顺序生成数字\n\n复杂\n\n需要两个进程的共享数据项\n\n需要忙等待\n\n浪费CPU时间\n\n没有硬件保证的情况下无真正的软件解决方案\n\nPerterson算法需要原子的LOAD和STORE指令\n\n软件方法的开销与实现复杂性较大\n9.8 方法3 更高级的抽象硬件提供了一些原语\n\n像中断禁用，原子操作指令等\n大多数现代体系结构都这样\n\n操作系统提供更高级的编程抽象来简化并行编程\n\n例如：锁，信号量\n从硬件原语中构建\n\n锁是一个抽象的数据结构\n\n一个二进制状态（锁定/解锁），两种办法\nLock::Acquire() — 锁被释放前一直等待，然后得到锁\nLock::Release() — 释放锁，唤醒任何等待的进程\n\n使用锁来编写临界区\nlock_next_pid-&gt;Acquire();new_pid = next_pid++;lock_next_pid-&gt;Release();\n\n大多数现代体系结构都提供特殊的原子操作指令\n\n通过特殊的内存访问电路\n针对单处理器和多处理器\n\nTest-and-Set 测试和置位\n\n从内存中读取值\n测试该值是否为1（然后返回真或假）\n内存值设置为1\n\n交换\n\n交换内存中的两个值\n\nboolean TestandSet(boolean *target)&#123;\t\tboolean rv = *target;\t\t*target = true;\t\treturn rv;&#125;void Exchange(boolean *a, boolean *b)&#123;\t\tboolean tmp = *a;\t\t*a = *b;\t\t*b = tmp;&#125;\n\n采取基于原子操作的机器指令方式：\n\n优点：\n\n适用于单处理器或者共享主存的多处理器中任意数量的进程\n简单并且容易证明\n可以用于支持多临界区\n\n\n缺点：\n\n忙等待消耗处理器时间\n当进程离开临界区并且多个进程在等待的时候可能导致饥饿\n死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程也需求，那么高优先级进程会获得处理器并等待临界区\n\n\n\n总结\n锁是更高等级的编程抽象\n\n互斥可以使用锁来实现\n通常需要一个等级的硬件支持\n\n\n常用的三种实现方法\n\n禁用中断（仅限于单处理器）\n软件方法（复杂）\n原子操作指令（单处理器或多处理器均可）\n\n\n可选的实现内容：\n\n有忙等待\n无忙等待\n\n\n\n","categories":["操作系统"],"tags":["同步互斥"]},{"title":"二叉树搜索树","url":"/2021/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"二叉搜索树概述二叉树结构可以认为是二维的列表(列表在维度上的扩充)\n二叉搜索树在形式上继承了二叉树(列表结构的特点)，同时也巧妙的借鉴了有序向量的特点和优势(一种质的提高)\n循关键码访问\n数据项之间，依照各自的关键码彼此区分\n条件：关键码之间支持大小比较与想等比对\n数据集合中的数据项，统一地表示和实现为词条entry形式\n\n词条emplate &lt;typename K, typename V&gt; struct Entry &#123; //词条模板类   K key; V value; //关键码、数值   Entry ( K k = K(), V v = V() ) : key ( k ), value ( v ) &#123;&#125;; //默认构造函数   Entry ( Entry&lt;K, V&gt; const&amp; e ) : key ( e.key ), value ( e.value ) &#123;&#125;; //基于克隆的构造函数   bool operator&lt; ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key &lt;  e.key; &#125;  //比较器：小于   bool operator&gt; ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key &gt;  e.key; &#125;  //比较器：大于   bool operator== ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key == e.key; &#125; //判等器：等于   bool operator!= ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key != e.key; &#125; //判等器：不等于&#125;; //得益于比较器和判等器，从此往后，不必严格区分词条及其对应的关键码\n\n有序性\n局部性的特征\n\nBST(二叉搜索树)：节点词条关键码\n顺序性：任一节点均不小于/不大于其左/右后代\n只含单个节点或即便只含单分支，都可以称作BST\n单调性BST的中序遍历序列，必然单调非降\n这一性质，也是BST的充要条件\n\n所有节点的垂直投影所构成的序列即是中序序列\n在微观上处处满足顺序性，在宏观上整体满足单调性\n接口template &lt;typename T&gt; class BST : public BinTree&lt;T&gt; &#123; //由BinTree派生BST模板类protected:   BinNodePosi&lt;T&gt; _hot; //“命中”节点的父亲   BinNodePosi&lt;T&gt; connect34 ( //按照“3 + 4”结构，联接3个节点及四棵子树      BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;,      BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt; );   BinNodePosi&lt;T&gt; rotateAt ( BinNodePosi&lt;T&gt; x ); //对x及其父亲、祖父做统一旋转调整public: //基本接口：以virtual修饰，强制要求所有派生类（BST变种）根据各自的规则对其重写   virtual BinNodePosi&lt;T&gt; &amp; search ( const T&amp; e ); //查找   virtual BinNodePosi&lt;T&gt; insert ( const T&amp; e ); //插入   virtual bool remove ( const T&amp; e ); //删除   /*DSA*/   /*DSA*/void stretchToLPath() &#123; stretchByZag ( _root ); &#125; //借助zag旋转，转化为左向单链   /*DSA*/void stretchToRPath() &#123; stretchByZig ( _root ); &#125; //借助zig旋转，转化为右向单链   /*DSA*/void stretch();&#125;;\n\n查找\n减而治之：从根节点出发，逐步地缩小查找范围，直到发现目标(成功)，或查找范围缩小至空树(失败)\n对照中序遍历序列可见，整个过程可视作是在仿效有序向量的二分查找\ntemplate &lt;typename T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search(const T &amp; e)&#123;return searchIn( _root,e,_hot = NULL);&#125; //从根节点启动查找static BinNodePosi(T) &amp; searchIn(    BinNodePosi(T) &amp; v,//当前(子)树根    const T &amp; e, //目标关键码    BinNodePosi(T) &amp; hot) //记忆热点&#123;    if (!v || (e == v-&gt;data)) return v; //足以确定失败，成功，或者    hot = v; //先记下当前(非空)节点，然后再...    return searchIn(((e &lt; v-&gt;data) ? v-&gt;lChild : v-&gt;rChild),e,hot);&#125; //运行时间正比于返回节点v的深度，不超过树高O(h)\n\n\n插入\ntemplate &lt;typename T&gt; BinNodePosi&lt;T&gt; BST&lt;T&gt;::insert ( const T&amp; e ) &#123; //将关键码e插入BST树中BinNodePosi&lt;T&gt; &amp; x = search ( e );   if ( x ) return x; //确认目标不存在（留意对_hot的设置）    x = new BinNode&lt;T&gt; ( e, _hot ); //创建新节点x：以e为关键码，以_hot为父\t_size++; //更新全树规模\tupdateHeightAbove ( x ); //更新x及其历代祖先的高度   return x; //新插入的节点，必为叶子&#125; //无论e是否存在于原树中，返回时总有x-&gt;data == e\n\n删除template &lt;typename T&gt; bool BST&lt;T&gt;::remove ( const T&amp; e ) &#123; //从BST树中删除关键码e   BinNodePosi&lt;T&gt; &amp; x = search ( e ); if ( !x ) return false; //确认目标存在（留意_hot的设置）   removeAt ( x, _hot ); _size--; //实施删除   updateHeightAbove ( _hot ); //更新_hot及其历代祖先的高度   return true;&#125; //删除成功与否，由返回值指示\n\ntemplate &lt;typename T&gt;static BinNodePosi&lt;T&gt; removeAt ( BinNodePosi&lt;T&gt; &amp; x, BinNodePosi&lt;T&gt; &amp; hot ) &#123;   BinNodePosi&lt;T&gt; w = x; //实际被摘除的节点，初值同x   BinNodePosi&lt;T&gt; succ = NULL; //实际被删除节点的接替者   if ( !HasLChild ( *x ) ) //若*x的左子树为空，则可      succ = x = x-&gt;rc; //直接将*x替换为其右子树   else if ( !HasRChild ( *x ) ) //若右子树为空，则可      succ = x = x-&gt;lc; //对称地处理——注意：此时succ != NULL   else &#123; //若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要      w = w-&gt;succ(); //（在右子树中）找到*x的直接后继*w      swap ( x-&gt;data, w-&gt;data ); //交换*x和*w的数据元素      BinNodePosi&lt;T&gt; u = w-&gt;parent;      ( ( u == x ) ? u-&gt;rc : u-&gt;lc ) = succ = w-&gt;rc; //隔离节点*w   &#125;   hot = w-&gt;parent; //记录实际被删除节点的父亲   if ( succ ) succ-&gt;parent = hot; //并将被删除节点的接替者与hot相联   release ( w-&gt;data ); release ( w ); return succ; //释放被摘除节点，返回接替者&#125; //release()负责释放复杂结构，与算法无直接关系，具体实现详见代码包\n\n平衡极短退化：当BST中所有节点的度数都不超过1，实际上已经退化成一条单链，此时整棵树的高度与整棵树的节点个数成线性正比关系(h=n-1)，这种情况下，最坏和平均意义都需要O(n)的时间\n平均高度\n随机生成的统一口径：当关键码总数为n时，可能的排列为n!棵，平均高度为logn，会出现冗余\n随机组成：将所有n个关键码视作n个互异的积木，所有BST的平均高度值为根号n\n中位数或是越接近与中位数的关键码，越是更早的插入，这类BST的高度会更低\n理想+适度什么样的树高度相对会更低\n\n节点数目固定时，兄弟子树高度越接近(平衡)，全树也将倾向于更低\n\n由n个节点组成的二叉树，高度不低于[ log2n]，恰为log2n时，称作理想平衡\n\n这样一种树在实际应用中是可遇不可求的，即便BST在某一时刻能够达到，在接下来的动态操作中，这样的高度也难以持续，因此所谓的理想平衡在实际意义中是不具任何意义的\n\n\n理想平衡出现概率极低，维护成本过高，故须适当地放松标准\n\n退一步海阔天空：高度渐进地不超过O(logn)，即称作适度平衡\n\n适度平衡BST，称作平衡二叉搜索树(BBST)\n\n\n歧义=等价\n相互等价的BST：两组BST的中序遍历序列完全一样，而拓扑却不尽相同\n\n上下可变：联接关系不尽相同，承袭关系可能颠倒，如19和16可以交换\n左右不乱：中序遍历序列完全一致，全局单调非降\n\n等价交换\n遵循两大准则\n\n局部性：执行的每一次等价变换，都应该局限在某一常数规模的局部(v和c)\n在将一棵刚刚失衡的BBST重新恢复于BST的过程中，累计需要执行的操作次数不要过多，至多不超过O(logn)\n\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"二叉树","url":"/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"二叉树树无论是向量还是列表都无法做到兼顾静态和动态的高效\n半线性结构：树型结构不是狭义的线性结构，却带有线性的特征\n\n树是按照层次关系来组织数据项的方式\n\n有根树：r树根（父亲），subtree子树，ri之间互称兄弟（sibling），d = degree（r)为r的度，e树的边数，n顶点总数\n\n故在衡量相关复杂度时，可以n作为参照\n若指定Ti作为T的第i棵子树，ri作为r的第i个孩子，则T称作有序树(ordered tree)\n路径+环路\n连通+无环\n一旦指定了根，其他的节点都将获得一个确定的指标，通过指标，同一类顶点所具有的指标都是相等的，也称为等价类\n深度+层次\n根节点是所有节点的公共祖先，深度为0\n没有后代的节点称作叶子（leaf）\n所有叶子深度中的最大者，称作树的高度\n一个节点都没有的树称作空树，高度为-1\ndepth(v) + height(v) &lt;= height(T)\n树的表示\n性能：\n\n长子+兄弟每个节点均设两个引用\n纵：firstChild（）\n横：nextSibling（）\n\n二叉树节点度数不超过2的树称作二叉树（binary tree）\n同一节点的孩子和子树，均以左、右区分\n在有根性和有序性能够保证的前提下，二叉树足以描述所有的树\n\n深度为k的节点，至多为2^k个\n\n含n个节点，高度为h的二叉树中\nh &lt; n &lt; 2^h+1\n\nn = h + 1时，退化为一条单链\n\nn = 2^h+1 - 1时，即所谓满二叉树（full binary tree）\n\n\n真二叉树每个节点的度数都是偶数\n假想添加：\n\n用长子兄弟法将多叉树转化为二叉树\n\n即可以用二叉树来表示任何一棵有根有序树\n正因如此，二叉树虽是树的特例，却可直接研究二叉树\n实现BinNode类\n每个节点通过引用指向其他节点，每个节点所占据的一个空间为一个位置\n#define BinNodePosi(T) BinNode&lt;T&gt;* //节点位置template&lt;typename T&gt; struct BinNode&#123;    BinNodePosi(T) parent,lChild,rChild; //父亲，孩子    T data; int height; int size(); //高度，子树规模    BinNodePosi(T) insertAsLc(T const &amp;); //作为左孩子插入新节点    BinNodePosi(T) insertAsRc(T const &amp;); //作为右孩子插入新节点    BinNodePosi(T) succ(); //(中序遍历意义下)当前节点的直接后继    template &lt;typename VST&gt; void travLevel( VST &amp; ); //子树层次遍历    template &lt;typename VST&gt; void travPre( VST &amp; ); //子树先序遍历    template &lt;typename VST&gt; void travIn( VST &amp; ); //子树中序遍历    template &lt;typename VST&gt; void travPost( VST &amp; ); //子树后序遍历&#125;\n\n接口实现\n传入参数e进行封装，并且将它作为当前节点的左/右孩子，接入所属树中\ntemplate&lt;typename T&gt; BinNodePosi(T)::insertAsLc(T const &amp; e)&#123; return l Child = new BinNode(e,this); &#125; //O(1)\n\nsize(后代总数，即以其为根的子树的规模)\ntemplate&lt;typename T&gt;int BinNode&lt;T&gt;::size()&#123;    int s = 1; //计入本身    if(lChild) s += lChild-&gt;size(); //递归计入左子树规模    if(rChild) s += rChild-&gt;size(); //递归计入右子树规模    return s;&#125; //O(n=size)\n\nBinTree模板类template&lt;typename T&gt; class BinTree&#123;protected:    int _size; //规模    BinNodePosi(T) _root; //根节点    virtual int updateHeight( BinNodePosi(T) x); //更新节点x的速度    void updateHeightAbove(BinNodePosi(T) x); //更新x即祖先的速度public:    int size() const &#123; return _size; &#125; //规模    bool empty() const &#123; return !_root; &#125; //判空    BinNodePosi(T) root() const &#123; return _root; &#125; //树根    /* ...子树接入、删除和分离接口...*/    /* ...遍历接口... */&#125;\n\n高度更新根节点高度为0，空树高度为-1\n一个节点的高度恰好等于左右孩子中的更大者+1\n定义一个新的等价意义上的高度，使得算法更为简便：\n#define stature(p) ( (p) ? (p)-&gt;height : -1)\n\ntemplate&lt;typename T&gt; //更新节点x高度，具体规则因树不同而异int BinTree&lt;T&gt;::updateHeight( BinNodePosi(T) x)&#123;    return x-&gt;height = 1 + max( stature( x-&gt;lChild ),stature( x-&gt;rChild ) );&#125; //此处采用常规二叉树规则，O(1)\n\n如果x的父节点存在，那么x的高度变化，则会连锁到父节点，祖父节点…，因此更新节点从x出发，向上逐层追溯它的历代祖先直到抵达根节点\ntemplate&lt;typename T&gt; //更新v及其历代祖先的高度void BinTree&lt;T&gt;::updateHeightAbove( BinNodePosi(T) x )&#123;    while(x) //可优化：一旦高度未变，即可终止    &#123; updateHeight(x); x = x-&gt;parent; &#125;&#125; //O( n = depth(x) )\n\n节点插入在一棵二叉树中，将某个新生成的节点，作为树中某一原本没有右孩子的节点的右孩子接入\n\ntemplate&lt;typename T&gt; BinNodePosi(T)BinTree&lt;T&gt;::insertAsRc( BinNodePosi(T) X,T const &amp; e )&#123;    _size++;    x-&gt;insertAsRc(e); //x祖先的高度可能增加，其余节点必要不变    updateHeightAbove(x);    return x-&gt;rChild;&#125;\n\n先序遍历遍历：按照某种次序访问树中各节点，每个节点被访问恰好一次\n先序：V-&gt;L-&gt;R        中序：L-&gt;V-&gt;R        后序：L-&gt;R-&gt;V\n先序遍历顺序：自上而下访问左侧链上的节点，再自下而上访问它们的右子树\ntemplate&lt;typename T,typename VST&gt;void traverse(BinNodePosi(T) x,VST &amp; visit)&#123; //递归实现    if(!x) return; //递归基的处理    visit( x-&gt;data );     traverse( x-&gt;lChild,visit );    traverse( x-&gt;rChild,visit );&#125; //T(n) = O(1) + T(a) + T(n-a-1) = O(n)\n\n这种算法只具有渐进的意义，在实际过程中，因为递归程序的实现机制，只能采用通用的方法，运行栈中每个递归实例都具有一帧，但是因为它们必须具有通用格式，所以并不能做到足够的小。因此，作为树算法的重要基石，遍历算法非常有必要从递归改写为迭代\n迭代实现(1)template&lt;typename T,typename VST&gt;void travPre_I1( BinNodePosi(T) x,VST &amp; visit)&#123;    Stack&lt;BinNodePosi(T)&gt; S; //辅助栈    if(x) S.push(x); //根节点入栈    while( !S.empty() )&#123; //在栈变空之前反复循环        x = S.pop();        visit( x-&gt;data ); //弹出并访问当前节点        if( HasRChild(*x) ) S.push(x-&gt;rChild); //右孩子先入后出        if( HasLchild(*x) ) S.push(x-&gt;lChild); //左孩子后入先出    &#125;&#125;\n\n所有的遍历算法都是先访问左孩子再访问右孩子，所以依据栈的特性，右孩子先入后出（后遍历）\n\n对于任何一根子树，我们都将起始于树根的总是沿着左侧孩子分支不断下行的这条链，称作当前这棵子树的左侧链\n\n首先自顶而下的依次访问左侧链上的沿途节点，再倒过来，自底而上地依次遍历各个层次上的右子树\n迭代实现(2)template&lt;typename T,typename VST&gt; //分摊(1)\t static void visitAlongLeftBranch(BinNodePosi(T) x,VST &amp; visit,Stack&lt;BinNodePosi&gt; &amp; s)&#123;    while(x)&#123;        visit( x-&gt;data ); //反复访问当前节点        S.push( x-&gt;rChild ); //右孩子入栈        x = x-&gt;lChild; //沿左侧链下行    &#125;&#125;\n\ntemplate&lt;typename T,typename VST&gt;void travPre_I2( BinNodePosi(T) x,VST &amp; visit )&#123;    Stack&lt;BinNodePosi(T)&gt;S; //辅助栈    while(true)&#123; //以右子树为单位，逐批访问节点        visitAlongLeftBranch( x,visit,S); //访问子树x的左侧链，右子树入栈缓冲        if( S.empty() ) break; //栈空即退出        x = S.pop(); //弹出下一子树的根    &#125;&#125;\n\n\n中序遍历思路递归：\ntemplate&lt;typename T,typename VST&gt;void traverse( BinNodePosi(T) x,VST &amp; visit )&#123;    if( !x ) return;    traverse( x-&gt;lChild,visit );    visit( x-&gt;data );    traverse( x-&gt;rChild,visit );&#125; //T(n) = T(a) + O(1) + T(n-a-1) = O(n)\n\n\n从根节点开始一直沿着左侧分支逐层向下直到末端\n因此整个中序遍历分解为在不同尺度下的一系列的对左侧分支的逐步处理\n\n\n从根出发沿左分支下行，直到最深的节点——它就是全局首先被访问者\n自上而下谦让，再自下而上访问\n\n实现template&lt;typename T&gt;static void goAlingLeftBranch( BinNodePosi(T) x,Stack&lt;BinNodePosi(T)&gt; &amp; S )&#123; while(x) &#123; S.push(x); x = x-&gt;lChild; &#125;&#125; //反复地入栈，沿左分支深入template&lt;typename T,typename v&gt; void travIn_I1( BinNodePosi(T) x,V&amp; visit )&#123;    Stack&lt;BinNodePosi(T)&gt; S; //辅助栈    while(true)&#123;        goAlongLeftBranch(x, S); //从当前节点出发，逐批入栈        if( S.empty() ) break; //直至所有节点处理完毕        x = S.pop(); //x的左子树或为空，或已遍历（等效于空），故可以        visit( x-&gt;data ); //立即访问之        x = x-&gt;rChild; //再转向其右子树(可能为空，需留意处理手法)    &#125;&#125;\n\n\n所有左侧链的长度集中在一起也就是O(n)\n每一个节点的入栈操作对应的是左侧链上的一步，因此左侧链的长度就是push的操作次数\n后序遍历递归：\ntemplate&lt;typename T,typename VST&gt;void traverse( BinNodePosi&lt;T&gt; x,VST &amp; visit )&#123;    if( !x ) return;    traverse( x-&gt;lc,visit );    traverse( x-&gt;rc,visit );    visit( x-&gt;data );&#125;\n\n\n\n从根出发下行，尽可能沿左分支，实不得已，才沿右分支\n最后一个节点，必是叶子，而且是按中序遍历次序最靠左者，也是递归版中visit()首次执行处\n\ntemplate&lt;typename T&gt;static void gotoleftmostleaf( Stack&lt;BinNodePosi&lt;T&gt;&gt; &amp; S)&#123;    while( BinNOdePosi&lt;T&gt; x = S.top() ) //自顶而下反复检查栈顶节点        if( HasLChild(*x) )&#123; //尽可能向左，在此之前            if( HasRChild(*x) ) //若有右孩子，则                S.push( x-&gt;rc ); //优先入栈            S.push( x-&gt;lc ); //然后转向左孩子        &#125;else //实不得已            S.push( x-&gt;rc ); //才转向右孩子    S.pop(); //返回之前，弹出栈顶的空节点&#125;\n\ntemplate&lt;typename T,typename VST&gt;void travPost_I( BinNodePosi&lt;T&gt; x,VST &amp; visit )&#123;    Stack&lt;BinNodePosi&lt;T&gt;&gt; S; //辅助栈    if(&#125;\n\n层次遍历在此前的三种遍历中，都是后代先于祖先访问，即逆序，为此，都会使用到栈\n而在层次遍历中，所有节点都将按照深度次序由高至低访问\ntemplate&lt;typename T&gt;template&lt;typename T&gt;void BinNode&lt;T&gt;::travLevel( VST &amp; visit)    Queue&lt;BinNodePosi(T) Q; //引入辅助队列\tQ.enqueue( this ); //根节点入队\twhile( !Q.empty() )&#123; //在队列再次清空之前，反复迭代        BinNodePosi(T) x = Q.dequeue(); //在取出队首节点        visit( x-&gt;data );         if( HasLChild(*x) ) Q.enqueue( x-&gt;lChild ); //左孩子入队        if( HasRChile(*x) ) Q.enqueue( x-&gt;rChild ); //右孩子入队    &#125;\n\n\nHuffman树无前缀冲突编码各自的叶子不会待在另一叶子的通路上\n\n编码成本相差一个bit，影响的是带宽，费用，成本等等\n\n之所以要平衡，是为了杜绝深度差够大，至少是2的瑕疵，一旦有这种瑕疵，就可以通过交换进行优化\n带权编码长度因为频度的不同\n\n根据频率高/低的(超)字符，应尽可能放在高/低处\n故此，通过适当的交换，同样可以缩短wald(T)\n\n编码算法贪婪策略：频率低的字符优先引入，位置亦更低\n为每个字符创建一棵单节点的树，组成森林F\n按照出现频率，对所有树排列\nwhile( F中的树不止一棵 )    取频率最小的两棵树：T1和T2    将它们合并成一棵新树T，并令：    \tlchild(T) = T1且rChild(T) = T2    \tw(root(T)) = w(root(t1)) + w(root(T2))\n\n构造编码书\n每次取最小两个数合并(贪心)，并慢慢成长\n \n编码表：遍历，先中后序都可以，因为都是深度优先\n解码：从根开始，走到叶子，打印字符，再重置到根循环\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"列表","url":"/2021/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%97%E8%A1%A8/","content":"列表接口与实现根据是否修改数据结构，所有操作大致分为两类方式\n\n静态：仅读取，数据结构的内容及组成一般不变：get、search\n动态：需写入，数据结构的局部或整体将改变：insert、remove\n\n与操作方式相对应地，数据元素的存储与组织方式也分为两种\n\n静态：\n\n数据空间整体创建或销毁\n数据元素的物理存储次序与其逻辑次序严格一致\n可支持高效的静态操作\n比如向量，元素的物理地址与其逻辑次序线性对应\n\n\n动态：\n\n为各数据元素动态地分配和回收的物理空间\n逻辑上相邻的元素记录彼此的物理地址，在逻辑上形成一个整体\n可支持高效的动态操作\n\n\n\n从向量到列表列表（list）是采用动态存储策略的典型结构，其中的元素称作节点（node）\n各节点通过指针或引用彼此联接，在逻辑上构成一个线性序列\n相邻节点彼此互称前驱或后驱\n没有前后驱的唯一节点称作首（first/front）/末（last/rear）节点\n从秩到位置向量支持循秩访问的方式（这种方式效率高）\n然而在列表中，这种循秩访问的成本过高，已不合时宜\n因此，应该用循位置访问的方式，即利用节点之间的相互引用，找到特定的节点 \n\nADT接口\n\n列表节点类：\n#define Posi(T) ListNode&lt;T&gt;* //列表节点位置template&lt;typename T&gt;struct ListNode&#123; //列表节点模板类（以双向链表形式实现）    T data; //数值    Posi(T) pred; //前驱    Posi(T) succ; //后继    ListNode()&#123;&#125; //针对header和trailer的构造    ListNode(T e,Posi(T)p = NULL,Posi(T) s = NULL)        :data(e),pred(p),succ(s)&#123;&#125; //默认构造器    Posi(T) insertAsPred(T const&amp; e); //前插入    Posi(T) insertAsSucc(T const&amp; e); //后插入 &#125;;\n\n\n头、首、末、尾节点的秩可分别理解尾-1，0，n-1，n\n\n template&lt;typename T&gt; void List&lt;T&gt;::init()&#123;//初始化，创建列表对象时统一调用    header = new ListNode&lt;T&gt;; //创建头哨兵节点    trailer = new ListNode&lt;T&gt;; //创建尾哨兵节点    header-&gt;succ = trailer; header-&gt;pred = NULL; //互联    trailer-&gt;pred = header; trailer-&gt;succ = NULL; //互联    _size = 0; //记录规模&#125;\n\n无序列表插入template&lt;typename T&gt;Posi(T) List&lt;T&gt;::insertBefore(Posi(T)p,T const&amp; e)&#123; _size++; return p-&gt;insertAsPred(e); &#125;//e当做p的前驱插入\n\ntemplate&lt;typename T&gt; //前插入算法（后插入算法完全对称）Posi(T)ListNde&lt;T&gt;::insertAsPred(T const&amp; e)&#123;    Posi(T) x = new ListNode(e,pred,this); //创建（耗时一百倍）    pred-&gt;succ = x;    pred = x;    return x; //建立连接，返回新节点的位置&#125;\n\n即便当前节点是首节点，前驱依然是存在的（哨兵）\n\n基于复制的构造\ntemplate&lt;typename T&gt; //基本接口void List&lt;T&gt;::copyNodes(Posi(T) p,int n)&#123;    init(); //创建头、尾哨兵节点并做初始化    while(n--) //将起自p的n项依次作为末节点插入    &#123; insertAslast(p-&gt;data); p = p-&gt;succ; &#125;&#125;\n\n所谓insertAsLast其实就是insertBefore(trailer)\n删除与析构删除：\ntemplate&lt;typename T&gt; //删除合法位置p处节点，返回其数值T List&lt;T&gt;::remove(Pose(T) P)&#123; //O(1)    T e = p-&gt;data; //备份待删除节点数值（设类型T可直接赋值）    p-&gt;pred-&gt;succ = p-&gt;succ;    p-&gt;succ-&gt;pred = p-&gt;pred;    delete p;    _size--;    return e; //返回备份数值&#125;\n\n\n析构：\ntemplate&lt;typename T&gt; List&lt;T&gt;::~List()//列表析构&#123; clear(); delete header; delete trailer; &#125; //清空列表，释放头、尾\n\ntemplate&lt;typename T&gt; int List&lt;T&gt;::clear()&#123; //清空列表\tint oldSize = _size;    while(0 &lt; _size) //反复删除首节点，直至列表变空        remove(header-&gt;succ);    return oldSize;&#125; //O(n),线性正比于列表规模\n\n查找在节点p（可能是trailer）的n个（真）前驱中，找到等于e的最后者\ntemplate&lt;typename T&gt; //从外部调用时，0&lt;=n&lt;=rank(p)&lt;_sizePosi(T) List&lt;T&gt;::find(T const &amp;e,int n,Pose(T) p) const&#123; //顺序查找，O(n)    while(0 &lt; n--) //从右向左，逐个将p的前驱与e比对        if(e == (p = p-&gt;pred)-&gt;data)            return p; //直至命中或范围越界    return NULL; //若越出左边界，意味着查找失败&#125; \n\n如果目标节点有多个，那么会停止于最靠后的节点\n\n去重template&lt;typename T&gt; int List&lt;T&gt;::deduplicate()&#123; //剔除无序列表中重复的节点    if(_size &lt; 2) return 0; //平凡列表自然无重复    int oldSize = _size; //记录原规模    Pose(T) p = first(); rank r = 1; //p从首节点起    while(trailer != (p = p-&gt;succ))    &#123; //依次直到末节点        Posi(T) q = find(p-&gt;data,r,p); //在p的r个（真）前驱中，查找与之雷同者        q ? remove(q) : r++; //若的确存在，则删除；否则秩递增    &#125; //assert：循环过程中的任意时刻，p的所有前驱互不相同    return oldSize - _size; //列表规模变化量，即被删除元素总数&#125;\t\t\n\n有序列表唯一化\ntemplate&lt;typename T&gt; int List&lt;T&gt;::uniquify()&#123; //成批剔除重复元素    if(_size &lt; 2) return 0;    int oldSize = size;     ListNodePosi(T) p = first();    ListNodePosi(T) q; //p为各区段起点，q为其后继    while(trailer != (q = p-&gt;succ)) //反复考察紧邻的节点对（p，q）        if(p-&gt;data != q-&gt;data) p = q; //若互异，则转向下一区段    \telse remove(q);    return oldSize - _size; //被删除元素总数&#125; //只需遍历整个列表一趟，O(n)\n\n查找template&lt;typename T&gt; //在有序列表内节点p的n个（真）前驱中，找到不大于e的最后者Posi(T) List&lt;T&gt;::search(T const &amp;e,int n,posi(T) p) const&#123;    while(0 &lt;= n--) //对于p的最近的n个前驱，从右向左        if(((p = p-&gt;pred)-&gt;data) &lt;= e) break; //逐个比较   return p; //直至命中、数值越界或范围越界后，返回查找终止的位置&#125; //最好O(1)，最坏O(n);等概率时平均O(n),正比于区间宽度\n\nvector访问方式依据 rank 秩（RAM模型）\nList访问方式依据 Posi （TM模型）\n选择排序改进思路：相较于起泡排序的短距离小步慢跑式的挪动最大元素，为何不一次性完成这项工作\n\n//对列表中起始于位置p的连续n个元素做排序，valid（p） &amp;&amp; rank（p） + n &lt;= sizetemplate&lt;typname T&gt;void List&lt;T&gt;::selectionsort(Posi(T) p,int n)&#123;    Posi(T) head = p-&gt;pred;    Posi(T) tail = p; //待排序区间（head，tail）    for(int i = 0;i &lt; n;i++)         tail = tail -&gt; succ; //head/tail可能是头/尾哨兵    while(1 &lt; n)&#123;//反复从（非平凡的）待排序区间内找出最大者，并移至有序区间前端        insertBefore(tail,remove(selectMax(head-&gt;succ,n)));        tail = tail-&gt;pred;        n--; //待排序区间、有序区间的范围，均同步更新    &#125;&#125;\n\n\nselectMax（）\ntemplate&lt;typename T&gt; //从起始于位置p的n个元素中选出最大者，1 &lt; nPosi(T) List&lt;T&gt;::selectMax(Posi(T) P,int n)&#123; //O(n)    Posi(T) max = p; //最大者暂定为p    for(Posi(T) cur = p;1 &lt; n;n--) //后续节点逐一与max比较        if( !lt((cur = cur-&gt;succ)-&gt;data,max-&gt;data)) //若&gt;=max,则更新最大元素位置记录            max = cur;    return max;&#125;\n\n使用 &gt;= 可以对重复元素进行处理\n插入排序\n前缀部分总是有序直到整段有序\n//对列表中起始于位置p的连续n个元素做插入排序，valid(p) &amp;&amp; rank(p) + n &lt;= sizetemplate&lt;typename T&gt;void List&lt;T&gt;::insertionSort(Posi(T) p,int n)&#123;    for(int r = 0;r &lt; n;r++)&#123;        insertAfter(search(p-&gt;data,r,p),p-&gt;data); //查找+插入        p = p-&gt;succ;        remove(p-&gt;pred); //转向下一节点    &#125; //n次迭代，每次O(r+1)&#125; //仅使用O(1)辅助空间，属于就地算法\n\n\n最好情况：完全（或几乎）有序\n每次迭代，只需1次比较，0次交换，累计O(n)时间\n最坏情况：完全（或几乎）逆序\n第k次迭代，需O(k)次比较，1次交换，累计O(n^2)时间\n逆序对（inversion）某两个元素一左一右，左侧更大，右侧更小，则称为逆序对\n任何两个元素都可能构成逆序，所以长度为n的序列而言，逆序对的总数有可能多达O(n^2)，而将每一个逆序对都记到后面的账上，则对任何一个节点p，所对应的逆序对的总和则是整个序列逆序对的总数。\n\n p所对应的inversion有多少个，p就需要经过多少次比较抵达最终的插入位置，i（p）即是查找长度\n最好情况即是所有元素顺序输入，逐次递增，不含任何逆序对，所有，O（I+n），I为0\n相反，完全逆序输入情况，复杂度为n^2，其中任何一对都为逆序对。\n敏感输入(input-sensitive)：算法复杂度不光取决于问题的规模，而更多取决于输入本身所具有的特性，也就是无序程度。\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"向量","url":"/2021/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F/","content":"向量抽象数据类型=数据模型+定义在该模型上的一组操作\n数据结构 =基于某种特定语言，实现ADT的一整套算法\n向量ADT向量是数组的抽象与泛化，由一组元素按线性次序封装而成\n各元素与[0，n）内的秩（rank）一一对应（循秩访问）\n元素的类型不限于基本类型\n操作、管理维护更加简化、统一安全\n可更为便捷地参与复杂数据结构的定制与实现\n\n构造与析构http://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/vector/vector.h.htm\nusing Rank = int; //秩#define DEFAULT_CAPACITY  3 //默认的初始容量（实际应用中可设置为更大）template &lt;typename T&gt; class Vector &#123; //向量模板类protected:Rank _size; Rank _capacity;  T* _elem; //规模、容量、数据区void copyFrom ( T const* A, Rank lo, Rank hi ); //复制数组区间A[lo, hi)void expand(); //空间不足时扩容void shrink(); //装填因子过小时压缩bool bubble ( Rank lo, Rank hi ); //扫描交换void bubbleSort ( Rank lo, Rank hi ); //起泡排序算法Rank maxItem ( Rank lo, Rank hi ); //选取最大元素void selectionSort ( Rank lo, Rank hi ); //选择排序算法void merge ( Rank lo, Rank mi, Rank hi ); //归并算法void mergeSort ( Rank lo, Rank hi ); //归并排序算法void heapSort ( Rank lo, Rank hi ); //堆排序（稍后结合完全堆讲解）Rank partition ( Rank lo, Rank hi ); //轴点构造算法void quickSort ( Rank lo, Rank hi ); //快速排序算法void shellSort ( Rank lo, Rank hi ); //希尔排序算法public:// 构造函数Vector ( int c = DEFAULT_CAPACITY, Rank s = 0, T v = 0 ) //容量为c、规模为s、所有元素初始为v&#123; _elem = new T[_capacity = c]; for ( _size = 0; _size &lt; s; _elem[_size++] = v ); &#125; //s&lt;=cVector ( T const* A, Rank n ) &#123; copyFrom ( A, 0, n ); &#125; //数组整体复制Vector ( T const* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; //区间Vector ( Vector&lt;T&gt; const&amp; V ) &#123; copyFrom ( V._elem, 0, V._size ); &#125; //向量整体复制Vector ( Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; //区间// 析构函数~Vector() &#123; delete [] _elem; &#125; //释放内部空间// 只读访问接口Rank size() const &#123; return _size; &#125; //规模bool empty() const &#123; return !_size; &#125; //判空Rank find ( T const&amp; e ) const &#123; return find ( e, 0, _size ); &#125; //无序向量整体查找Rank find ( T const&amp; e, Rank lo, Rank hi ) const; //无序向量区间查找Rank search ( T const&amp; e ) const //有序向量整体查找&#123; return ( 0 &gt;= _size ) ? -1 : search ( e, 0, _size ); &#125;Rank search ( T const&amp; e, Rank lo, Rank hi ) const; //有序向量区间查找// 可写访问接口T&amp; operator[] ( Rank r ); //重载下标操作符，可以类似于数组形式引用各元素const T&amp; operator[] ( Rank r ) const; //仅限于做右值的重载版本Vector&lt;T&gt; &amp; operator= ( Vector&lt;T&gt; const&amp; ); //重载赋值操作符，以便直接克隆向量T remove ( Rank r ); //删除秩为r的元素int remove ( Rank lo, Rank hi ); //删除秩在区间[lo, hi)之内的元素Rank insert ( Rank r, T const&amp; e ); //插入元素Rank insert ( T const&amp; e ) &#123; return insert ( _size, e ); &#125; //默认作为末元素插入void sort ( Rank lo, Rank hi ); //对[lo, hi)排序void sort() &#123; sort ( 0, _size ); &#125; //整体排序void unsort ( Rank lo, Rank hi ); //对[lo, hi)置乱void unsort() &#123; unsort ( 0, _size ); &#125; //整体置乱Rank deduplicate(); //无序去重Rank uniquify(); //有序去重// 遍历void traverse ( void (* ) ( T&amp; ) ); //遍历（使用函数指针，只读或局部性修改）template &lt;typename VST&gt; void traverse ( VST&amp; ); //遍历（使用函数对象，可全局性修改）&#125;; //Vector\n\n原理：\n\n向量的复制\ntemplate&lt;typename T&gt; //T为基本类型，或已重载赋值操作符&#x27;=&#x27;void vector&lt;T&gt;::copyFrom(T* const A,Rank lo,Rank hi)&#123;    _elem = new T[_capacity = 2*(hi-lo)]; //分配空间,预留出足够的空间，在接下去足够长的时间内，不必因为有必要的扩容而打断计算过程    _size = 0; //规模清零    while(lo&lt;hi) //A[lo,hi)内的元素逐一        _elem[size++] = A[lo++]; // 复制至_elem[0,hi-lo)&#125;\n\n\n可扩充向量若采用静态空间管理策略，容量_capacity固定，则有明显的不足\n\n上溢（overflow）：_elem[]不足以存放所有元素\n尽管此时系统仍有足够的空间\n\n下溢（underflow）：_elem[]中的元素寥寥无几\n装填因子（load factor）size/capacity &lt;&lt; 50% \n\n\n更糟糕的是，一般的应用环境中难以准确预测空间的需求量\n可否使得向量可随实际需求动态调整容量，并同事保证高效率？\n动态空间管理在即将发生上溢时，适当的扩大内部数组的容量\n\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::expand()&#123;\t//向量空间不足时扩容    if(_size&lt;_capacity)return; //尚未满员，不必扩容    _capacity = max(_capacity,DEFAULT_CAPACITY); //不低于最小容量    T* oldElem = _elem;    _elem = new T[_capacity &lt;&lt;= 1]; //容量加倍    for(int i = 0;i &lt; _size; i++) //复制原向量内容        _elem[i] = oldElem[i]; //T为基本类型，或已重载赋值操作符&#x27;=&#x27;    delete[]oldElem; //释放原空间&#125;\n\n得益于向量的封装，尽管扩容之后的数据区的物理地址有所改变，却不致出现野指针\n递增式扩容T* oldElem = _elem; _elem = new T[_capacity += INCREMENT];//追加固定大小的容量\n\n最坏情况：在初始容量0的空向量中，连续插入n=m*I &gt;&gt; 2个元素…\n每一次的扩容与复制都会使得时间成本过多\n加倍式扩容T* oldElem = _elem; _elem = new T[_capacity &lt;&lt;= 1];//容量加倍\n\n在最坏去情况下，在初始容量为1的满向量中，连续插入n=2^m &gt;&gt; 2个元素\n各次扩容过程中复制原向量的时间成本依次为\n1,2,4,8，。。。，2^m = n  //几何级数\n总体耗时=O(n)，每次扩容的分摊成本为O(1)\n\n分摊复杂度平均复杂度或期望复杂度( average/expected complexity )\n\n根据数据结构各种操作出现概率的分布，将对应的成本加权平均\n\n各种可能的操作，作为独立事件分别考查\n\n割裂了操作之间的相关性和连贯性\n\n往往不能准确地评判数据结构和算法的真实性能\n\n\n分摊复杂度( amortized complexity )\n\n对数据结构连续地实施足够多次操作,所需总体成本分摊至单次操作\n从实际可行的角度,对一系列操作做整体的考量\n更加忠实地刻画了可能出现的操作序列\n可以更为精准地评判数据结构和算法的真实性能\n\n无序向量循秩访问从便捷性出发，实现和数组元素访问方式一样的：A[r]\n因此，重载下标操作符“[]”\ntemplate&lt;typename T&gt; //0 &lt;= r &lt; _sizeT &amp; vector&lt;T&gt;::operator[](Rank r) const &#123; return _elem[r]; &#125;\n\n右值：T x = v[r] + U[s] * W[t];\n左值：v[r] = (T)(2*X+3); //因为是引用的方式，所以可以为左值\n插入因为所有的向量元素都是紧邻排序的，所以为了能够插入新的元素，就必须将新元素的后缀元素整体右移\ntemplate&lt;typename T&gt; //e作为秩为r元素插入，0&lt;=r&lt;=sizeRank vector&lt;T&gt;::insert(Rank r,T const &amp; e)&#123;//O(n-r)    expand(); //若有必要，扩容    for(int i = _size;i &gt; r;i--) //自后向前，如果次序颠倒，则有可能出现数据被覆盖的危险        _elem[i] = _elem[i-1]; //后继元素顺次后移一个单元    _elem[r] = e; _size++; //置入新元素，更新容量    return r; //返回秩&#125;\n\n\n删除删除后，后缀统一左移，自前向后的前移操作，若顺序颠倒，可能出现危险\ntemplate&lt;typename T&gt; //删除区间[lo,hi),0&lt;=lo&lt;=hi&lt;=sizeint vector&lt;T&gt;::remove(Rank lo,Rank hi)&#123;//O(n-hi)    if(lo==hi) return 0; //出于效率考虑，单独处理退化情况    while(hi&lt;_size)        _elem[lo++] = _elem[hi++]; //[hi,_size)顺次前移hi-lo位    _size = lo; shrink(); //更新规模，若有必要缩容    return hi-lo;&#125;\n\n\n单元素删除可以视作区间删除操作的特例：[r] = [r,r+1)\n template&lt;typename T&gt; //删除向量中秩为r的元素，0&lt;=r&lt;sizeT vector&lt;T&gt;::remove(Rank r)&#123; //O(n-r)    T e = _elem[r]; //备份被删除的元素    remove(r,r+1); //调用区间删除算法    return e; //返回被删除元素&#125;\n\n查找template&lt;typename T&gt; //0&lt;=lo&lt;hi&lt;=_sizeRank vector&lt;T&gt;::find(T const &amp; e,Rank lo,Rank hi)const&#123;//O(hi-lo)=O(n),在命中多个元素时可返回秩最大者   while((lo &lt; hi--)&amp;&amp;(e != _elem[hi])); //逆向查找    return hi; //hi&lt;lo意味着失败；否则hi即命中元素的秩&#125;\n\n输入敏感算法：最好O(1)，最差O(n)\n去重/唯一化应用实例：网络搜索的局部结果经过去重操作，汇总为最终报告\ntemplate &lt;typename T&gt; //删除重复元素，返回被删除元素数目int Vector&lt;T&gt;::deduplicate() &#123; //繁琐版+错误版   int oldSize = _size; //记录原规模   Rank i = 1; //从_elem[1]开始   while (i &lt; _size) //自前向后逐一考查各元素_elem[i]      if (find(_elem[i], 0, i) &lt; 0) //在前缀中寻找与之雷同者（至多一个）         i++; //若无雷同则继续考查其后继      else         remove(i); //否则删除当前元素（至多一个？）   return oldSize - _size; //被删除元素总数&#125;\n\n正确性：\n不变性：在当前元素 v[i] 的前缀 v[0,i] 中，各元素彼此互异\n单调性：随着反复的while迭代\n\n当前元素前缀的长度单调非降，且迟早增至_size \n当前元素后缀的长度单调下降，且迟早减至0\n\n故算法必然终止，且至多迭代O(n)轮\n\n复杂度：\n每轮迭代中 find() 和 remove() 累计耗费线性时间，故总体为O(n^2)\n遍历遍历向量，统一对各元素分别实施visit操作\n利用函数指针实例，只读或局部性修改\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::traverse(void (*visit)(T&amp;)) //函数指针&#123;    for (int i = 0;i &lt; _size;i++)        visit(_elem[i]);&#125;\n\n利用函数对象机制，可全局性修改\ntemplate&lt;typename T&gt; template&lt;typename VST&gt;void vector&lt;T&gt;::traverse(VST&amp; visit) //函数对象&#123;    for (int i = 0;i &lt; _size;i++)        visit(_elem[i]);&#125;\n\n有序向量如何甄别一个向量是否有序\n有序/无序序列中，任意/总有一对相邻元素顺序/逆序\n因此，相邻逆序对的数目，可用以度量向量的逆序程度\ntemplate&lt;typename T&gt; //返回逆序相邻元素对的总数int vector&lt;T&gt;::disordered()const&#123;    int n = 0; //计数器    for(int i = 1;i &lt; _size;i++) //逐一检查各队相邻元素        n += (_elem[i - 1] &gt; _elem[i]); //逆序则计数    return n; //向量有序当且仅当 n = 0&#125; //若只判断是否有序，则首次遇到逆序对之后，即可立即终止\n\n唯一化低效版观察：在有序向量中，重复的元素必要相互紧邻构成一个区间，每一个区间只需保留单个元素即可\ntemplate&lt;typename T&gt;int vector&lt;T&gt;::uniquify()&#123;    int oldSize = _size;    int i = 0; //从首元素开始    while(i &lt; _size-1) //从前向后，逐一比对各对相邻元素，若雷同，则删除后者；否则，转至后一元素        (_elem[i] == _elem[i+1])?remove(i+1):i++;    return oldSize - _size; //向量规模变化量，即删除元素总数&#125; //注意：其中_size的减少，由remove()隐式地完成\n\n运行时间主要取决于while循环，次数共计： _size-1 = n-1\n最坏情况下：每次都需调用remove()，耗时O(n-1)~O(1)；累计O(n^2) \n\n高效版如果能够将每一个区间作为一个整体，成批的删除雷同元素，则有可能实现一步到位式移动\ntemplate&lt;typename T&gt;int vector&lt;T&gt;::uniquify()&#123;    Rank i = 0,j = 0; //各对互异“相邻”元素的秩    while(++j &lt; _size) //逐一扫描，直至末元素        //跳过雷同；发现不同元素时，向前移至紧邻于前者右侧        if(_elem[i] != _elem[j])            _elem[++i] = _elem[j];    _size = ++i;     shrink(); //直接删除尾部多余元素    return j - i; //向量规模变化量，即被删除元素总数&#125; //注意：通过remove(lo,hi)批量删除，依然不能达到高效率\n\n共计n-1次迭代，每次常数时间，累计O(n)时间\n\n二分查找（A)语义约定至少应该便于有序向量自身的维护：v.insert ( 1 + v.search(e) , e )\n即便失败，也应给出新元素适当的插入位置\n若允许重复元素，则每一组也需按其插入的次序排列\n\n约定：在有序向量区间v[lo , hi) 中，确定不大于e的最后一个元素秩\n若-无穷 &lt; e &lt; v[lo]，则返回lo - 1（左侧哨兵）\n若 v[hi-1] &lt; e &lt; +无穷，则返回 hi-1（末元素=右侧哨兵左邻）\n原理\n二分（折半）策略：轴点mi总是取作中点——于是\n每经过至多两次比较，或者能够命中，或者将问题规模缩减一半\n实现template&lt;typename T&gt; //在有序向量区间[lo,hi)内查找元素estatic Rank binSearch(T* A,T const&amp; e,Rank lo,Rank hi)&#123;    while(lo &lt; hi)    &#123;\tRank mi = (lo + hi)&gt;&gt;1; //以中点为轴点     \tif(e &lt; A[mi]) hi = mi; //目标处于e的左侧，深入前半段[lo,mi)继续查找    \telse if(A[mi] &lt; e) lo = mi + 1; //目标\t处于e的右侧，深入后半段(mi,hi)     \telse return mi; //在mi处命中    &#125;    return -1; //查找失败&#125;\n\n\n\nFib查找\n二分查找版本A的效率仍有改进余地，因为不难发现转向左、右分支前的关键吗比较次数不等，而递归深度却相同\n若能通过递归深度的不均衡，来转向成本的不均衡进行补偿，平均查找长度应能进一步缩短\n\n\ntemplate&lt;typename T&gt; //0 &lt;= lo &lt;=hi &lt;= _sizestatic Rank fibsearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    Fib fib(hi-lo);    while(lo &lt; hi)    &#123;        while(hi - lo &lt; fib.get())            fib.prev(); //至多迭代几次？        //通过向前顺序查找，确定形如fib(k) - 1的轴点(分摊O(1))        Rank mi = lo + fib.get() - 1; //按黄金比例切分        if(e &lt; A[mi]) hi = mi; //深入前半段[lo,mi)继续查找        else if (A[mi] &lt; e)lo = mi + 1; //深入后半段(mi,hi)        else return mi; //在mi处命中    &#125;    return -1; //查找失败&#125;\n\n二分查找(B)每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个\n\n\n以上二分查找及Fibnacci查找算法\n均为严格地兑现search（）接口的语义约定：返回不大于e的最后一个元素\n\n只有兑现这一约定，才可有效支持相关算法，比如：v.insert（1+v.search（e），e）\n\n只有多个命中元素时，必须返回最靠后（秩最大）者\n失败时，应返回小于e的最大者（含哨兵[lo-1]）\n\n\n\ntemplate&lt;typename T&gt;static Rank binSearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    while(1 &lt; hi - lo)    &#123;//有效查找区间的宽度缩短至1时，算法才会终止        Rank mi = (lo + hi) &gt;&gt; 1; //以中点为轴点，经比较后确定深入        （e &lt; A[mi]) ? hi = mi : lo = mi; //[lo,mi)或[mi,hi)    &#125; //出口时hi = lo + 1,查找区间仅含一个元素A[lo]    return (e == A[lo]) ? lo : -1; //返回命中元素的秩或者-1&#125; //相较于版本A，最好（坏）情况下更坏（好）；各种情况下的SL更加接近，整体性能更趋稳定\n\n\n二分查找（C）template&lt;typename T&gt;static Rank binSearch(T* A,T const &amp; e,Rank lo,Rank hi)&#123;    while(hi &lt; lo)    &#123;//不变性：A[0,lo) &lt;= e &lt; A[hi,n]        Rank mi = (lo + hi) &gt;&gt; 1; //以中点为轴点，经比较后确定深入        （e &lt; A[mi]) ? hi = mi : lo = mi + 1; //[lo,mi)或（mi,hi)    &#125; //出口时,A[lo = hi]为大于e的最小元素    return --lo; //故lo - 1即不大于e的元素的最大秩&#125;\n\n与版本B的差异\n\n待查找区间宽度缩短至0而非1时，算法才结束\n转入右侧子向量时，左边界取作mi+1而非mi\n无论成功与否，返回的秩严格符合接口的语义约定\n\n\n插值排序假设已知有序向量中各元素随机分布的规律，比如均匀且独立的随机分布\n那么[lo，hi）内各元素应大致按照线性趋势增长\n因此通过猜测轴点mi，可以极大提高收敛速度\n\n最坏情况：可能退化为平凡的顺序查找  O（hi - lo） = O（n）\n平均情况：每经一次比较，n缩至根号n\n\n\n易受小扰动的干扰和“蒙骗”\n\n须引入乘法、除法运算\n\n实际可行的方法\n首先通过插值查找，将查找范围缩小到一定的范围，然后再进行二分查找\n\n\n大规模：插值查找\n中规模：折半查找\n小规模：顺序查找\n起泡排序向量若有序排列，计算效率将大大提升\n如何实现向量的有序化？（排序算法）\n统一接口 sort（Rank lo，Rank hi）\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while(!bubble(lo,hi--)); &#125; //逐趟做扫描交换，直至全序\n\n不变性：每经过对bubble的调用，都会有一个新的元素就位（减而治之），有序的部分逐渐拓展，无序的部分逐渐缩减\n\n改进：绿色的部分未必都是无序的，有可能存在一部分或者所有绿色都是有序的\n如何尽早判定这种情况？\n每一趟扫描交换，都记录下是否存在逆序元素，若存在，当且仅当做过交换\n反例\n实质需要排序的元素集中在一个宽度仅为根号n的区间中\n \n多余出来的消耗就是在后缀中已就位元素的扫描交换\n记录在上一趟扫描交换中所进行的最后一趟交换，就可以知道上一趟有多长的后缀没有进行扫描交换，如果这样，只需将右侧标志hi指向新的位置\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while(lo &lt; (hi = bubble(lo,hi))); &#125; //逐趟做扫描交换，直至全序template&lt;typname T&gt;Rank vector&lt;T&gt;::bubble(Rank lo,Rank hi)&#123;    Rank last = lo; //最右侧的逆序对初始化为[lo - 1,lo]    while(++lo &lt; hi) //自左向右，逐一检查各队相邻元素        if(_elem[lo - 1] &gt; _elem[lo])        &#123;//若逆序，则更新最右侧逆序对位置记录，并交换         \tlast = lo;            swap(_elem[lo - 1],_elem[lo]);        &#125;    return last; //返回最右侧的逆序对位置&#125; \t\n\n归并排序\n序列一分为二，子序列递归排序，合并有序子序列\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::mergeSort(Rank lo,Rank hi)&#123;    if(hi - lo &lt; 2) return; //单元素区间自然有序    int mi = (lo + hi) &gt;&gt; 1; //以中点为界    mergeSort(lo,mi); //对前半段排序    mergeSort(mi,hi); //对后半段排序    merge(lo,mi,hi); //归并&#125;\n\n二路归并\n\ntemplate&lt;typename T&gt;void vector&lt;T&gt;::merge(Rank lo,Rank mi,Rank hi)&#123;    T*A = _elem + lo; //合并后的向量A[0,hi - lo) = _elem[lo,hi)    int 1b = mi - lo;    T*B = new T[1b]; //前子向量B[0,1b) = _elem[lo,mi)    for(Rank i = 0;i &lt; 1b;B[i] = A[i++]); //复制前子向量B    int 1c = hi - mi;    T*C = _elem + mi; //后子向量C[0,1c) = _elem[mi,hi)    for(Rank i = 0,j = 0, k = 0;(j &lt; 1b) || (k &lt; 1c);)    &#123;//B[j]和C[k]中小者转至A的末尾        if((j &lt; 1b) &amp;&amp; (1c &lt;=k || (B[j] &lt;= C[k])))             A[i++] = B[j++]; //C[k]已无或不小        if((k &lt; 1c) &amp;&amp; (1b &lt;= j || (C[k] &lt; B[j])))            A[i++] = C[j++]; //B[j]已无或更大    &#125; //该循环实现紧凑；但就效率而言，不如拆分处理    delete[] B; &#125;\n\n\n\n\n一般B提前耗尽，就可终止算法\n复杂度\n算法的运行时间主要消耗与for循环，共有两个控制变量\n\n初始：j = 0，k = 0\n最终：j = lb，k = lc\n亦即：j + k = lb + lc = hi - lo = n\n\n每经过一次迭代，j和k中至少有一个会加一（j+k也必至少加一）\n故知：merge()总体迭代不过O(n)次，累计只需线性时间\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"图","url":"/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/","content":"图概述邻接+关联关系G = (V;E) 顶点;边\n邻接：顶点与顶点之间的关系\n关联：顶点以及与它相关的某条边的关系\n序列和树是图的一种特例\n\n\n在图中，任何两个节点之间都允许存在邻接关系，此课不讨论自环边\n无向图/有向图总度数(D)等于边数(e)的两倍。\nD=2e\n图G的顶点数n和边数e的关系\n\n若G是无向图，则0≤e≤n(n-1)/2。\n恰有n(n-1)/2条边的无向图称无向完全图(Undireet-ed Complete Graph)。\n\n若G是有向图，则0≤e≤n(n-1)。\n恰有n(n-1)条边的有向图称为有向完全图(Directed Complete Graph)。\n\n\nu，v分别称作边(u，v)的尾(tail)，头(head)\n混合图：既有有向边，又有无向边\n\n路径+环路简单路径simple path：如果在一条通路中不含重复的节点\n环路：路径的起点终点相同，也有简单与不简单之分\n有向无环图(DAG)：一个有向图中不包含任何环路\n欧拉环路：所有的有向边都可以构成一个环路\n哈密尔顿环路：经过每一个点一次而且恰好一次    \n邻接矩阵Graph模板类\n\n邻接矩阵+关联矩阵描述顶点之间相互邻接关系的一种形式\n\n\n无向图具有冗余性\n带权图：各边记录的权重记录于对应的单元 \n顶点和边vertex\ntypedef enum &#123;UNDISCOVERED,DISCOVERED,VISITED&#125; VStatus;template&lt;typename Tv&gt;struct Vertex &#123; //顶点对象(并未严格封装)    Tv data;int inDegree,outDegree; //数据、出入度数    VStatus status; //(如上三种)状态    int dTime,fTime; //时间标签    int parent; //在遍历树中的父节点    int priorty; //在遍历树种的优先级(最短通路、极短跨边等)    Vertex(Tv const &amp; d): //构造新顶点    data(d),inDegree(0),outDegree(0),status(UNDISCOVERED),    dTime(-1),fTime(-1),parent(-1),priority(INT_MAX)&#123;&#125;&#125;;\n\nEdge\ntypedef    enum&#123;UNDETERMINED,TREE,CROSS,FORWARD,BACKWARD&#125;\tEStatus;template&lt;typename T&gt;struct Edge&#123; //边对象(并未严格封装)    T data; //数据    int weight; //权重    EStatus status; //类型    Edge(Te const &amp; d,int w)://构造新边    \tdata(d),weight(w),status(UNDETERMINED)&#123;&#125;&#125;；\n\n邻接矩阵GraphMatrix\n用邻接矩阵实现含n个顶点e条边的图，空间复杂度;O(n^2)\n删除边(i, j)的时间复杂度:O(1)\n遍历顶点v的所有邻居的时间复杂度:O(n)\n访问顶点v中存储的数据的时间复杂度:O(1)\ntemplate&lt;typename Tv,typename Te&gt;class GraphMatrix:public Graph&lt;Tv,Te&gt;&#123;private:    vector&lt;Vertex&lt;Tv&gt;&gt; V; //顶点集    Vector&lt;Vector&lt;Edge&lt;Te&gt;*&gt;&gt; E; //二维向量，边集 E[i][j]public:    /*操作接口：顶点相关，边相关，。。。*/    GraphMatrix() &#123;n = e = 0;&#125; //构造    ~GraphMatrix()&#123; //析构        for (int j = 0;j &lt; n;j++)            for(int k = 0;k &lt; n;k++)                delete E[j][k]; //清除所有动态申请的边记录    &#125;&#125;\n\n\n顶点静态操作Tv &amp; vertex(int i) &#123;return V[i].data;&#125; //数据int inDegree(int i) &#123;return V[i].inDegree;&#125; //入度int outDegree(int i) &#123;return V[i].outDegree;&#125; //出度Vstatus &amp; status(int i) &#123;return V[i].status;&#125; //状态int &amp; dTime(int i) &#123;return V[i].dTime;&#125;int &amp; fTime(int i) &#123;return V[i].fTime;&#125;int &amp; parent(int i) &#123;return V[i].parant;&#125; //在遍历树中的父亲int &amp; priority(int i) &#123;return V[i].priority;&#125; //优先级数\n\n对于任意顶点i，如何枚举其所有的邻接顶点neighbor？\ni在邻接矩阵中对应的那一行，或0或1\nint nextNbr(int i,int j)&#123; //若已枚举至邻居j，则转向下一邻居    while((-1 &lt; j) &amp;&amp; !exist(i,--j)); //逆向顺序查找，O(n)    return j;&#125;int firstNbr(int i)&#123;    return nextNbr(i,n);&#125; //首个连接，通过假想哨兵n\n\n边操作bool exists(int i,int j) &#123;//判断(i,j)是否存在    return (0 &lt;= i) &amp;&amp; (i &lt; n) &amp;&amp; (0 &lt;= j) &amp;&amp; (j &lt; n) &amp;&amp; E[i][j] != NULL; //短路求值&#125; //以下假定exists(i,j)...Te &amp; edge(int i,int j) //边(i,j)的数据&#123; return E[i][j]-&gt;data; &#125; //O(1)Estatus &amp; status(int i,int j) //边(i,j)的状态&#123; return E[i][j]-&gt;status; &#125; //O(1)Estatus &amp; Weight(int i,int j) //边(i,j)的权重&#123; return E[i][j]-&gt;Weight; &#125; //O(1)\n\n如何在一幅图中插入一条边\n假设顶点i和顶点j之间连接一条有向边，只需要将待插入的边的信息封装为一个具体的边记录，然后将新的边记录的地址存入邻接矩阵对应的那个单元，反过来这个单元也将指向记录\nvoid insert(Te const&amp; edge,int w,int i,int j)&#123; //插入(i,j,w)    if (exists(i,j)) return; //忽略已有的边    E[i][j] = new Edge&lt;Te&gt;(edge,w); //创建新边    e++; //更新边计数    v[i].outDegree++; //更新关联顶点i的出度    v[j].inDegree++; //更新关联顶点j的入度&#125;\n\n边删除\n将对应的边记录释放，然后邻接矩阵中的引用指向空\nTe remove(int i,int j)&#123; //删除顶点i和j之间的联边(exists(i,j))    Te eBak = edge(i,j); //备份边(i,j)的信息    delete E[i][j]; E[i][j] = NULL; //删除边(i,j)    e--; //更新边计数    V[i].outDegree--; //更新关联顶点i的出度    V[j].inDegree--; //更新关联顶点j的入度    return eBak; //返回被删除边的信息&#125;\n\n顶点动态操作\nint insert(Tv const &amp; vertex) &#123; //插入顶点，返回编号    for (int j = 0;j &lt; n;j++) E[j].insert(NULL); n++; //第一步：插入新一列    E.insert(vector&lt;Edge&lt;Te&gt;*&gt;(n,n,NULL)); //第二三步：长度为新n的行向量   \treturn v.insert(Vertex&lt;Tv&gt;(vertex)); //\t第四步：创建顶点记录，存入顶点向量&#125;\n\n\n综合评价优点：\n\n直观，易于理解和实现\n适用范围广\n判断两点之间是否存在联边O(1)\n获取顶点的度数：O(1)，添加、删除边后更新度数：O(1)\n扩展性：\n得益于vector良好的空间控制策略\n空间溢出等情况可“透明地”予以处理\n\n\n\n缺点：\n\nO(n^2)空间，与边数无关！\n真会有这么多条边？\n平面图：不相联的边不能相交，可嵌于平面的图\n欧拉公式出发，对于平面图而言，边的总是不可能超过顶点的总数。&lt;&lt;n^2 ,此时空间利用率约等于 1/n\n\n广度优先搜索支撑树\n以S为起点，将所有顶点划分为若干个等价类，同一等价类内部，各顶点的边不会被采纳，只有连接于相邻等价类之间的边才会被采纳(未必)\n所有被保留并且采纳的边，足以把所有的点连起来，也不至于造成环路(极大无环图)\n等价类到起点S的距离是逐次单调变化，等同于树的层次遍历\n实现Graph::BFS()\ntemplate&lt;typename Tv,typename Te&gt; //顶点类型，边类型void Graph&lt;Tv,Te&gt;::BFS(int v,int &amp; clock)&#123;    Queue&lt;int&gt; Q; status(v) = DISCOVERED; Q.enqueue(v); //初始化    while (!Q.empty())&#123;        int v = Q.dequeue();        dTime(v) = ++clock; //取出队首顶点v，并        for (int u = firstNbr(v); -1 &lt; u;u = nextNbr(v,u)) //考察v的每一邻居u            /*视u的状态，分别处理...*/            status(v) = VISITED; //至此，顶点访问完毕    &#125;&#125;\n\nwhile (!Q.empty())&#123;       int v = Q.dequeue();       dTime(v) = ++clock; //取出队首顶点v，并       for (int u = firstNbr(v); -1 &lt; u;u = nextNbr(v,u)) //考察v的每一邻居u           if (UNDISCOVERED == status(u))&#123;               status(u) = DISCOVERED; Q.enqueue(u); //发现该顶点               status(v,u) = TREE; parent(u) = v; //引入树边           &#125; else //若u已被发现（正在队列中），或者甚至已访问完毕（已出队列）               status(v,u) = CROSS; //将(v,u)归类于跨边           status(v) = VISITED; //至此，顶点访问完毕   &#125;\n\n实例\n\n\n\n当不再有新的tree edge生成，所有节点都已转成visited状态，剩下的tree edge生成一棵遍历支撑树\n多连通在含有多个连用域时，从多个起点s出发未必能够抵达其他连通域，如何使得BFS搜索足以覆盖整幅图，而不是某个连通域\ntemplate&lt;typename Tv,typename Te&gt; //顶点类型、边类型void Graph&lt;Tv,Te&gt;::bfs(int s)&#123; //s为起始顶点    reset(); int clock = 0; int v = s; //初始化O(n+e)    do //逐一检查所有顶点，一旦遇到尚未发现的顶点        if (UNDISCOVERED == status(v)) //累计O(n)            BFS(v,clock); //即从该顶点出发启动一次BFS    while (s != (v = (++v % n)));    //按序号访问，故不漏不重&#125;\n\n并非对每个顶点都启动搜索，此方法可保证对于每个连通域只有一个顶点可以作为起点引起它所属的那个连通域被完全遍历，每个连通域只启动一次BFS，搜索时间累计全图的一次遍历\n复杂度外部while循环因为每个顶点都会仅一次入队，所以dequeue操作也将执行O(n)次\n内部for(循环)是对顶点v所对应的行向量进行线性扫描n个单元\n在对整个行向量的访问过程中，所有的元素都有极高的概率处于高速缓存中\n\n连续、规则、紧凑的组织形式利于高速缓冲机制发挥作用\n存储级别之间巨大的速度差异，在实际应用中往往更为举足轻重\n\n\n最短路径树结构中，相对于树根节点，都对应于一条唯一的通路，路径的长度称为顶点v的深度，每一个等价类的深度指标都是相等的，树的层次遍历则是按照这一指标将所有顶点枚举出来\nBFS所给出的顶点序列，也是按照非降次序单调排列的。\n在最终生成的BFS树中，每个顶点与s之间的那条通路恰好就是这两个顶点之间的最短通路\n深度优先搜索深度优先搜索算法策略更为简明，过程更为复杂，功能更为强大\nDFS(s) \n​    访问顶点s\n​    若s尚有未被访问的邻居，则任取其一u，递归执行DFS(u)\n​    否则，返回\n\n框架template &lt;typename Tv,typename Te&gt; //顶点类型、边类型void Graph&lt;Tv,Te&gt;::DFS(int v,int &amp; clock)&#123;    dTime(v) = ++clock; status(v) = DISCOVERED; //发现当前顶点v    for (int u = firstNbr(v);-1 &lt; u;u = nextNbr(v,u)) //枚举v的每一邻居u        /*...视u的状态，分别处理...*/        /*...与BFS不同，含有递归...*/        status(v) = VISITED; fTime(v) = ++clock; //\t至此，当前顶点v方告访问完毕&#125;\n\n细节for (int u = firstNbr(v);-1 &lt; u;u = nextNbr(v,u)) //枚举v的每一邻居u    switch (status(u))&#123;        case UNDISCOVERED:            status(v,u) = TREE; parent(u) = v; DFS(u,clock); break; //递归        case DISCOVERED: //u已被发现但尚未访问完毕，应属被后代指向的祖先            status(v,u) = BACKWARD; break;        default: //U已放我完毕，则视承袭关系分为前向边或跨边            status(v,u) = dTime(v) &lt; dTime(u) ? FORWARD : CROSS; break;    &#125;\n\n无向图\n\n有向图\n\n一旦发现了backward边，则出现了一条回路\na的可达区都扫描完毕，第一轮循环结束\n\n粗边构成两颗遍历树\n嵌套引理顶点的活动期：active[u] = (dTime[u] , fTime[u])\n没有血缘关系的节点，活跃期彼此不搭\n\n拓扑排序零入度任给有向图G(不一定是DAG)，尝试将所有顶点排成一个线性序列，使其次序须与原图相容(每一顶点都不会通过边指向前驱顶点)\n\n提出不需要前驱的点，逐渐递归\n\n零出度\n\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"图应用","url":"/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E5%BA%94%E7%94%A8/","content":"图应用双连通分量判定准则\n\n给定无向图，如何确定BCC？\n从任一顶点出发，构造DFS树，根据DFS留下的标记，甄别是否是关节点\n\nDFS之后得到的那个叶子不会是关键点，因为删除节点后，连通量不会增加。因此，所有叶子可排除在外\n根：根在DFS中是随机的，只要不是只有1度，那必然是关节点。\n内部节点：\n根据回边是否指向比v高的祖先，指向，则v不是；若刚好指向v，则v是。\n\n\n\n\n算法#define hca(x) (fTime) //利用此处闲置的fTimetemplate&lt;typename Tv,typename Te&gt;void Graph&lt;Tv,Te&gt;::BCC(int v,int &amp; clock,stack&lt;int&gt; &amp; S)&#123;    hca(v) = dTime(v) = ++clock; status(v) = DISCOVERED;S.push(v);    for (int u = firstNbr(v);-1 &lt; u;u = nextNbr(v,u))        switch(status(u))            case UNDISCOVERED:    \t\t\tparent(u) = v; type(v,u) = TREE; //拓展树边    \t\t\tBCC(u,clock,S); //从u开始遍历，返回后...    \t\t\tif(hca(u) &lt; dTime(v)) //若u经后向边指向v的真祖先                    hca(v) = min(hca(v),hca(u)); //则v亦必如此    \t\t\telse //否则，则v为关节点(u即是一个BCC，且其中顶点此时正集中于栈S的顶部)                    while(u != S.pop());//弹出当前BCC中(除v外)的所有节点    \t\t\tbreak;            case DISCOVERED:    \t\t\ttype(v,u) = BACKWARD;    \t\t\tif(u != parent(v))                    hca(v) = min(hca(v),dTime(u));//更新hca[v],越小越高    \t\t\tbreak;    \t\tdefault: //VISITED(digraphs only)    \t\ttype(v,u) = dTime(v) &lt; dTime(u) ? FORWRD : CROSS;    \tbreak;&#125;\n\n实例\n\n\n\n优先级搜索早期向量和列表的访问次序是根据其结构本身，线性的次序，是显示可预测的。\nPFS：用某种数据结构把元素组织起来，并给各个元素分配一个优先级数，每一次做一个选择，对象就是优先级的拥有者，取出访问，循环至结束\nADT：\n\n\nDijkstra算法最短路径算法：O(1)\n\n一张网，拉离桌面，随着每一个点被拉离桌面，就能知道他们的次序，精确的记下拉离桌面的时间，则知道了最短距离\n每个点的优先级都是根据离开了桌面的前人来更新的\n拒绝负权边\n\n\nPrim算法最小支撑树\n\n\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"栈与队列","url":"/2021/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","content":"栈与队列last in first out\n\n栈既然属于序列的特例，故可直接基于向量或列表派生\ntemplate&lt;typename T&gt; class Stack:public vector&lt;T&gt;&#123; //由向量派生public: //size()、empty()以及其他开放接口均可直接沿用    void push(T const &amp; e)&#123; insert(size(),e);&#125; //入栈    T pop()&#123; return remove(size() - 1);&#125; //出栈    T &amp; top()&#123; return (*this)[size() - 1];&#125; //取顶&#125;; //以向量首/末端为栈底/顶——颠倒过来呢？每一次操作都会涉及到向量中的所有元素\n\n进制转换在计算过程中，没得到一个数位就通过push压入栈中\n\nvoid convert(stack&lt;char&gt; &amp; s,int64 n,int base)&#123;    static char digit[] = //新进制下的数位符号，可视base取值范围适当扩充    &#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;    while(n &gt; 0)    &#123; //由低到高，逐一计算出新进制下的各数位        s.push(digit[n % base]); //余数（对应的数位）入栈        n /= base; //更新为其对base的除商    &#125;&#125;\n\nmain()&#123;    stack&lt;char&gt; S;    convert(s,n,base); //用栈记录转换得到的各数位    while( !S.empty())         printf( &quot;%c&quot;,S.pop()); //逆序输出&#125;\n\n括号匹配\n\n平凡：无括号的表达式是匹配的\n\n\nbool paren(const char exp[],int lo,int hi)&#123; //exp[lo,hi)    stack&lt;char&gt; S; //使用栈记录已发现但尚未匹配的左括号    for(int i = 0;i &lt; hi;i++) //逐一检查当前字符        if(&#x27;(&#x27; == exp[i]) S.push(exp[i]);//遇左括号：则进栈    \telse if( !S.empty()) S.pop(); //遇右括号；若栈非空，则弹出左括号    \telse return false; //否则（遇有括号时栈已空），必不匹配    return S.empty(); //最终，栈空当且仅当匹配&#125;\n\n\n之所以不采用计数器方式是，无法用于多种括号并存情况，栈只需约定“括号”的通用格式，而不必事先固定括号的类型与数目\n栈混洗\n通过中转栈S，将A的元素转入B中\nS.push(A.pop())B.push(S.pop())\n\n\n\n甄别\n\n对于任何1&lt;=j&lt;k&lt;=n，[…,k…,i,…,j,…&gt; 必非栈混洗\nO（n）算法：直接借助栈A、B和S，模拟混洗过程\n​                        每次S.pop()之前，检测S是否已空；或需弹出的元素在S中，却非顶元素\n\n合法的栈混洗序列与合法的括号匹配表达式之间存在着一一对应的关系，n个元素的栈混洗有多少种，n对括号所能构成的合法表达式也就有多少种\n中缀表达式求值典型应用场合\n逆序输出：输出次序与处理过程颠倒；递归深度和输出长度不易预知\n递归嵌套：具有相似性的问题可递归描述，但分支位置和嵌套深度不固定\n延迟缓冲：线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀\n栈式计算：基于栈结构的特定计算模式\n\n在面对比较长的表达式时，很难定位当前可以计算的运算符，如果以线性扫描的次序处理表达式，计算的次序未必与扫描的次序完全一致\n可以利用栈结构，所有扫描过的部分保存为栈\n\n然而有一些栈顶的表达式并不自然，所以需要把运算符和运算数分别对待\nfloat evaluate(char* S,char* &amp; RPN)&#123;//中缀表达式求值    stack&lt;float&gt; opnd; stack&lt;char&gt; optr; //运算数栈，运算符栈    optr.push(&#x27;\\0&#x27;);    while(!optr.empty())    &#123; //逐个处理各字符，直至运算符栈空        if(isdigit(*S)) //若当前字符为操作数，则读入（可能多位的）操作数            readNumber(S,opne);        else //若当前字符为运算符，则视其与栈顶运算符之间优先级的高低            switch(orderBetween(optr.top(),*S))            &#123;/*分别处理*/&#125;    &#125;    return opnd.pop(); //弹出最后的计算结果&#125;\n\n不同优先级处理方法\nswitch(orderBetween(optr.top(),*S))&#123;    case &#x27;&lt;&#x27;: //栈顶运算符优先级更低        optr.push(*S);        S++;        break; //计算推迟，当前运算符进栈    case &#x27;=&#x27;: //优先级相等(当前运算符为右括号，或尾部哨兵&#x27;\\0&#x27;)        optr.pop();        S++;        break; //脱括号并接收下一个字符    case &#x27;&gt;&#x27;:        &#123; //栈顶运算符优先级更高，实施相应的计算，结果入栈            char op = optr.pop(); //栈顶运算符出栈，执行对应的运算            if(&#x27;!&#x27; == op) opnd.push(calc(op,opne.pop()); //一元运算符            else               &#123;                float pOpnd2 = opnd.pop(),pOpnd1 = opnd.pop(); //二元运算符                opnd.push(calcu(pOpnd1,op,pOpnd2)); //实施计算，结果入栈               &#125;                break;              &#125;        &#125;\n\n当前栈顶左括号，当前字符右括号，表明右括号之前的子表达式已都执行完毕，所以左括号弹出，字符指向下一个，末尾\\0同理\n逆波兰表达式（RPN）\n将表达式优先级转化为运算符在RPN表达式序列中出现的次序，谁先出现谁就优先计算\n手工转换\n转换后运算符的次序有可能颠倒改变，然而运算数却是不变的\n\n队列First in first out\n只能在队尾插入（查询）：enqueue（） + rear（）\n只能在队头插入（查询）：dequeue（） + front（）\n队列属于序列的特例，则可直接基于向量或列表派生\ntemplate&lt;typename T&gt; class Queue:public List&lt;T&gt;&#123;public:    void enqueue(T const &amp; e)&#123; insertAsLast(e);&#125; //尾部入队    T dequeue() &#123; return remove(first()); &#125; //首部出队    T &amp; front() &#123; return first()-&gt;data; &#125; //队首&#125;；\n\n如此实现的队列接口，均只需O(1)时间\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"绪论","url":"/2021/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/","content":"绪论计算计算是：\n\n研究对象：研究计算过程中所蕴含本质的内在规律，总结挖掘出其中的一般性的方法以及典型的技巧\n研究目的：实现高效，低耗的计算\n\n算法：即在特定计算模型下，旨在解决特定问题的指令序列\n程序！=算法\n有穷性：\n对于任何输入，经有穷次基本操作，都可以得到输出 \n好算法=正确+健壮+可读+效率（速度快，空间少）\n图灵机\n进行复位是为了在软件开发过程中相互合作的准则，即规范\nRAM模型\n一个算法好不好并不取决于CPU主频运行的快慢， 而取决于它本身需要执行多少次CPU的计算\n\n\n执行过程可以记录为一张表\n表的行数既是所执行基本指令的总条数\n能够客观度量算法的执行时间\n\n图灵机、RAM等模型为度量算法性能提供了准确的尺度\n渐进复杂度在考察DSA时应该更多看中它的长远（处理更大问题时的潜力如何），也不必过多的纠结于它的细微不足，应该更多的看到它的主要方面，主流\n大O记号从悲观的角度做分析\n\n长远，当n足够大；主流，忽略所有常系数与低次项这些非主流的因素，使得主流信息可以突出\n复杂度分析算法分析的两个主要任务=正确性（不变形x单调性）+复杂度\n复杂度分析的主要方法\n\n迭代：级数求和\n递归：递归跟踪+递归方程\n猜测+验证\n\n级数\n\n循环\n从渐进的阶次而言，二者是完全相等的，都是平方的量级\n起泡排序\n问题：该算法必然会结束？至多需迭代多少趟？\n不变形：经k轮扫描交换后，最大的k个元素必然就位\n单调性：经k轮扫描后交换后，问题规模缩减至n-k\n正确性：经至多n趟扫描后，算法必然会终止，且能给出正确的答案\n\n封底估算除了大O计算这种定性的定界方法，在很多时候需要准确的定量估算\n迭代与递归减而治之\n空间复杂度考量除了输入本身所占的空间之外，所需要的另加用于计算所必须的空间总量\n\n为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡，另一规模缩减\n递归跟踪：直观形象，仅适用于简明的递归模式\n\n递推方程：间接抽象，更适用于复杂的递归模式\n\n\n分而治之为求解一个大规模的问题，可以将其划分为若干子（通常两个）问题，规模大体相当\n\n\n动态规划fib的封底估算\n\nfib递归跟踪\n\nfib迭代\n\n解决方法（记忆）：将已计算过实例的结果制表备查\n解决方法（动态规划）：颠倒计算方法，由自顶而下递归，为自底而上迭代 \n\n公共子序列\n减而治之：将相同的末字符切掉，分成一个平凡的问题和一个小于1的相同规模问题\n\n分而治之：若末尾字符不相同，则大胆切除\n\n单调性：无论如何，每经过一次对比，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩短一个单位\n最好情况（不出现第2种情况）下，只需O（n+m）时间\n但问题在于，（在第2种情况）原问题将分解为两个子问题，更糟糕的是，它们在随后进一步导出的子问题，可能雷同\n","categories":["数据结构"],"tags":["数据结构与算法"]},{"title":"应用层","url":"/2022/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/","content":"应用层概述\n客户/服务器方式和对等方式\n动态主机配置协议DHCP\n\n动态主机配置协议DHCP(Dynamic Host Configuration Protocol)提供了一种机制， 称为即插即用连网，这种机制允许一台计算机加入新网络时可自动获取IP地址等网络配置信息而不用手工参与。\n\nDHCP报文在运输层使用UDP协议封装\n\nDHCP客户使用的UDP端口号为68\nDHCP服务器使用的UDP端口号为67\n\n\nDHCP客户在未获取到IP地址时使用地址0.0.0.0\n\n在每一个网络上都设置一个DHCP服务器会使DHCP服务器的数量太多。因此现在是使每一个网络至少有一个**DHCP中继代理(通常是一台路由器)**，它配置了DHCP服务器的IP地址信息，作为各网络中计算机与DHCP服务器的桥梁。\n\n\n域名系统DNS\n文件传送协议FTP\n电子邮件\n万维网WWW\n","categories":["计算机网络"],"tags":["网络","DNS"]},{"title":"数据链路层","url":"/2022/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","content":"概述\n链路：就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点\n数据链路：是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路\n数据链路层以帧为单位传输和处理数据\n\n三个重要问题：封装成帧，差错检测，可靠传输\n封装成帧\n数据链路层给上层交付的协议数据单元添加帧头和帧尾使之称为帧\n\n帧头和帧尾中包含有重要的控制信息\n帧头和帧尾的作用之一就是帧定界\n\n\n透明传输是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样\n\n为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些\n\n考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU\n\n\n差错检测\n实际的通信链路都不是理想的，比特在传输过程中可能产生差错，这称为比特差错\n在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER\n使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一\n\n可靠传输数据链路层向上提供的服务类型\n\n不可靠传输服务：仅仅丢弃误码的帧，其他什么也不做\n\n可靠传输服务：想办法实现发送管发送什么，接收端就收到什么\n\n一般情况下，有线链路的误码率比较低，为了减少开销，并不要求数据链路层想向上提供可靠传输服务。即使出现误码，可靠传输的问题由其上层处理\n\n无线链路易受干扰，误码率较高，因此必须提供\n\n可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输\n\n可靠传输的实现比较复杂，开销也比较小，是否使用应根据实际应用需求\n\n\n停止-等待协议SW\n回退N帧协议GBN停止-等待协议的信道利用率很低，若出现超时重传，则信道利用率更低\n\n选择重传协议SR回退N帧协议的接受窗口WR只能等于1，因此接受方只能按序接受正确到达的数据分组\n一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接受而丢弃（尽管他们无乱序和误码）。这必然会造成发送方对这些数据分组的超市重传，显然这是对通信资源的极大浪费\n\n为了进一步提高性能，可设法只重传误码和数据分组。因此，接受窗口的尺寸WR不应再等于1，以便接受方先收下失序到达但无误码并且序号落在接受窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层\n\n\n点对点协议PPP\n媒体接入控制 \n\nMAC地址\n当多个主机连接在同一广播信道上，要想实现两个主机之间的通信，则每个主机必须有一个唯一的标识，即一个数据链路层的地址\n\n在每个主机发送的帧中必须携带标识发送主机和接受主机的地址。由于这类地址是用于媒体接入控制MAC（Media Access Contronl），因此这类地址被称为MAC地址\n\nMAC地址一般被固话在网卡（网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址\nMAC地址有时也被称为物理地址。但是这并不意味着MAC地址属于网络体系结构中的物理层\n\n\n一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识\n\n\nIP地址（简要）\nIP地址是因特网上的主机和路由器所使用的地址，用于标识两部分信息：\n\n网络编号：标识因特网上数以百万计的网络\n主机编号：标识同一网络上不同主机（或路由器各接口）\n\n\n很显然，MAC地址并不具备区分不同网络的功能\n\n如果只是一个单独的网络，不接入因特网，可以只使用MAC地址\n如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用\n\n\n\n\n\n数据包转发过程中源IP地址和目的IP地址保持不变\n源MAC地址逐个链路或逐个网络改变 \n\nARP协议如何通过IP地址找到相应的MAC地址\n\n源主机在自己的ARP高速缓存表中查找目的主机的IP地址所对应的MAC地址，若找到了,则可以封装MAC帧进行发送;若找不到，则发送ARP请求(封装在广播MAC帧中) ;\n目的主机收到ARP请求后，将源主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后给源主机发送ARP响应(封装在单播MAC帧中)，ARP响应中包含有目的主机的IP地址和MAC地址;\n源主机收到ARP响应后，将目的主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后就可以封装之前想发送的MAC帧并发送给目的主机:\nARP的作用范围:逐段链路或逐个网络使用:\n除ARP请求和响应外，ARP还有其他类型的报文(例如用于检查IP地址冲突的“无故ARP.免费ARP(Gratuitous ARP)”) ;\nARP没有安全验证机制，存在ARP欺骗(攻击)问题。\n\n集线器和交换机的区别\n集线器HUB： 半双工\n\n早期以太网的互连设备\n工作在OSI体系结构的物理层\n对接收到的信号进行放大、转发\n使用集线器作为互连设备的以太网仍然属于共享总线式以太网。集线器互连起来的所有主机共享总线带宽，属于同个碰撞域和广播域。\n\n交换机SWITCH：全双工\n\n目前以太网中使用最广 泛的互连设备\n工作在OSI体系结构的数据链路层(也包括物理层)根据MAC地址对帧进行转发\n使用交换机作为互连设备的以太网，称为交换式以太网。交换机可以根据MAC地址过滤帧，即隔离碰撞域。\n交换机的每个接口是一个独立的碰撞域\n交换机隔离碰撞域但不隔离广播域(VLAN除外)\n\n以太网交换机自学习和转发帧的过程\n生成树协议STP\n以太网交换机使用生成树协议STP(Spanning Tree Protocol),可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题\n不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的(无逻辑环路) ;\n最终生成的树型逻辑拓扑要确保连通整个网络;\n当首次连接交换机或网络物理拓扑发生变化时(有可能是人为改变或故障) ,交换机都将进行生成树的重新计算。\n\n\n虚拟局域网VLAN概述\n以太网交换机工作在数据链路层(也包括物理层)\n使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于同一一个广播域。随着交换式以太网规模的扩大，广播域相应扩大。\n巨大的广播域会带来很多弊端:广播风暴，难以管理和维护，潜在的安全问题\n网络中会频繁出现广播信息(TCP/IP协议栈中很多协议都会使用广播，例如ARP、RIP、DHCP等)\n分割广播域的方法:使用路由器可以隔离广播域，但路由器成本较高，虚拟局域网VLAN技术应运而生。\n虚拟局域网VLAN(Virtual Local Area Network)是种将局域网内的设备划分成与物理位无关的逻辑组的技术，这些逻辑组具有某些共同的需求。\n\n\n实现机制端口：\n\n","categories":["计算机网络"],"tags":["网络","数据链路层","IP地址","MAC地址"]},{"title":"概述","url":"/2022/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0/","content":"概述因特网概述\n网络由若干个结点和连接这些结点的链路组成\n\n多个网络还可通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网，因此，互联网是“网络的网络”\n\n因特网是世界上最大的互连网络\nISP：因特网服务提供者\n\n\n\n三种交换方式\n电路交换：电话交换机接通电话线的方式。使用这种方式传送计算机数据，其线路的传输效率往往较低\n\n分组交换：\n\n发送方：构造分组，发送分组\n路由器：缓存分组，转发分组\n接收方：接受分组，还原报文\n\n\n报文交换\n\n\n\n计算机网络的定义和分类定义\n计算机网络的精确定义并未统一\n\n计算机网络最简单得定义是：一些互相连接的、自治的计算机的集合\n\n互联：是指计算机之间可以通过有线或无线的方式进行数据通信\n自治：是指独立的计算机，它有自己的硬件和软件，可以单独运行使用\n集合 ：是指至少需要两台计算机\n\n\n计算机网络较好的定义：计算机网络主要是由一些通用的，可编程的硬件互联而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛和日益增长的应用\n\n计算机网络所连接的硬件，并不限于一般的计算机，而是包括了只能手机等只能硬件\n计算机网络并非专门用来传送数据，而是能够支持很多种的应用\n\n\n\n分类按交换技术分类：\n电路交换，报文交换，分组交换\n按使用者分类：\n公用网（电信公司出资建造的大型网络），专用网（某个部门为本单位的业务需要建立的网络）\n按传输介质分类：\n有线网络，无线网络\n按覆盖范围分类：\n广域网WAN，城域网MAN，局域网LAN，个域网PAN\n按拓扑结构分类：\n总线型网络，星型网络，环型网络，网状型网络\n\n计算机网络的性能指标性能指标可以从不同的方面来度量计算机网络的性能\n速率\n带宽\n吞吐量\n时延\n在处理时延忽略不计的情况下，发送时延或处理时延做主导，应该具体问题具体分析\n时延带宽积\n往返时间\n源主机发送分组开始知道源主机收到来自目的主机的确认分组为止，所需要的时间\n利用率\n丢包率\n计算机网络体系结构常见的计算机网络体系结构\n\n\n分层的必要性\n”分层“可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理\n\n\n\n专用术语实体任何可发送或接受信息的硬件或软件进程\n对等实体：处于双方相同层次中的实体\n协议控制两个对等实体进行逻辑通信的规则的集合\n协议三要素：语法，语义，同步\n服务在协议通知下，两个对等实体间逻辑通信使得本层能够向上一层提供服务\n\n要实本层协议，还需要使用下面一层所提供的的服务\n\n实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议，也就是说，下面的协议对上面的实体是透明的\n\n\n服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型\n服务原语：同一系统内，层与层之间交换的数据包称为服务数据单元\n\n","categories":["计算机网络"],"tags":["网络"]},{"title":"物理层","url":"/2022/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/","content":"物理层基本概念\n物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流\n物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么\n\n\n物理层下的传输媒体\n传输方式串行传输：比特一个接一个在一根传输线上进行传输，适合远距离传输，计算机网络采用这种传输\n并行传输：多个比特同时在多根传输线上传输，不适合远距离传输，成本太高。计算机内部采用这种传输\n同步传输：比特一个接一个传输，中间没有间隔，各比特持续时长相等。需要收发双发时间同步，有两种方法\n异步传输：以字节为单位进行传输，字节之间的间隔不固定，但每个字节内的比特持续时长是相等的，换句话说，字节间异步，比特间仍是同步。为此，需要给每个字节添加起始位和结束位\n\n编码与调制信道的极限容量","categories":["计算机网络"],"tags":["网络"]},{"title":"网络层","url":"/2022/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/","content":"网络层概述\n网络层而定主要任务是实现网络互联，进而实现数据包在各网络之间的传输\n\n 要实现网络层任务，需要解决以下主要问题：\n\n网络层运输层提供怎样的服务（可靠传输还是不可靠传输）\n\n网络层寻址问题\n\n路由选择问题\n\n因特网是目前全世界用户数量最多的互联网，它使用TCP/IP协议栈\n\n由于TCP/IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为网际层\n\n\n网络层提供的两种服务\nIPv4地址\n分类编制的IPv4地址\n划分子网的IPv4地址\n\n32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号\n子网掩码使用连续的比特1来对应网络号和子网号\n子网掩码使用连续的比特0来对应主机号\n将划分子网的IPv4地址与其对应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址\n\n\n\n无分类编制的IPv4地址斜线记法，在斜线后面写上网络前缀所占的比特数量\n我们只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节：\n地址块最小地址，地址块最大地址，地址块中的地址数量，地址块聚合类网络的数量，地址掩码（子网掩码）\nIPV4地址的应用规划定长的子网掩码：\n\n使用同一个子网掩码来划分子网\n子网划分方式不灵魂：只能划分出2n个子网（n是从主机号部分借用的用来作为子网号的比特数量\n每个子网所分配的IP地址数量相同，容易造成IP地址浪费\n\n变长的子网掩码VLSM：\n\n使用不同的子网掩码来划分子网\n子网划分方式灵魂：可以按需分配\n每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费\n\nIP数据包的发送和转发过程包含以下两部分：\n\n主机发送IP数据报\n\n判断目的主机是否与自己在同一个网络\n若在同一个网络，则属于直接交付\n若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发\n\n\n\n\n路由器转发IP数据报\n\n检查IP数据报首部是否出错：\n\n若出错，则直接丢弃该IP数据报并通告源主机\n若没有出错，则进行转发\n\n\n根据IP数据报的目的地址在路由表中查找匹配的条目：\n\n若找到匹配条目，则转发给条目中指示的下一跳\n若找不到，则丢弃该IP数据报并通告源主机\n\n\n\n\n\n静态路由配置及其可能产生的路由环路问题\n路由选择协议 静态路由选择：\n\n由人工配置的网络路由，默认路由，特定主机路由，黑洞路由等都属于静态路由\n这种人工配置方式简单、开销小，但不能及时适应网络状态（流量，拓扑等）的变化\n一般只在小规模网络中采用\n\n动态路由选择：\n\n路由器通过路由选择协议自动获取路由信息\n比较复杂，开销比较大，能较好地适应网络状态的变化\n适用于大规模网络\n\n\n路由信息协议RIP\n开放最短路径优先OSPF的基本工作原理\n\n边界网关协议BGP的基本工作原理\n网际控制报文协议ICMP\n虚拟专用网VPN与网络地址转换NAT\n","categories":["计算机网络"],"tags":["网络","IP地址"]},{"title":"运输层","url":"/2022/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/","content":"运输层概述\n之前课程所介绍的计算机网络体系结构中的物理层、 数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。\n但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。\n如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。\n运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等)， 它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。\n根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP，这两种协议就是本章要讨论的主要内容。\n\n端口号、复用与分用的概念\nUDP和TCP对比\nTCP的流量控制\n一般来说， 我们总是希望数据传输得更快一些。\n但如果发送方把数据发送得过快， 接收方就可能来不及接收，这就会造成数据的丢失。\n\n\n所谓流量控制 (low control)就是让发送方的发送速率不要太快，要让接收方来得及接收。\n利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。\nTCP接收方利用自 己的接收窗口的大小来限制发送方发送窗口的大小\nTCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文。\n\n\n\nTCP的拥塞控制 \nTCP超时重传时间的选择TCP可靠传输的实现\nTCP基于以字节为单位的滑动窗口来实现可靠传输。\n\n发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去;\n接收方只接收序号落入发送窗口内的数据;\n\n\n虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。\n\n网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。\n发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。\n\n\n对于不按序到达的数据应如何处理，TCP井无明确规定。\n\n如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。\nTCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。\n\n\nTCP要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。\n\n接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。\nTCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认[RFC 1122]\n\n捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。\n\n\n\nTCP的通信是全双工通信。通信中的每方都在发送和接收报文段。因此，每方都有自己的发送窗口和接收窗口，在谈到这些窗口时，一定要弄清楚是哪一方的窗口。\n\n\nTCP的运输连接管理三报文握手\nTCP是面向连接的协议，它基于运输连接来传送TCP报文段\nTCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程\nTCP的连接建立要解决一下三个问题：\n使TCP双方能够确知对方的存在\n使TCP双方能够协商一些参数（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等）\n使TCP双方能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配\n\n\n\n\n四报文挥手\nTCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器（两小时定时）\n若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接\n\n \nTCP报文段首部格式\n","categories":["计算机网络"],"tags":["网络","TCP","UDP"]}]